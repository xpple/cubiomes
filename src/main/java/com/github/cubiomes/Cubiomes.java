// Generated by jextract

package com.github.cubiomes;

import java.lang.invoke.*;
import java.lang.foreign.*;
import java.nio.ByteOrder;
import java.util.*;
import java.util.function.*;
import java.util.stream.*;

import static java.lang.foreign.ValueLayout.*;
import static java.lang.foreign.MemoryLayout.PathElement.*;

public class Cubiomes {

    Cubiomes() {
        // Should not be called directly
    }

    static final Arena LIBRARY_ARENA = Arena.ofAuto();
    static final boolean TRACE_DOWNCALLS = Boolean.getBoolean("jextract.trace.downcalls");

    static void traceDowncall(String name, Object... args) {
         String traceArgs = Arrays.stream(args)
                       .map(Object::toString)
                       .collect(Collectors.joining(", "));
         System.out.printf("%s(%s)\n", name, traceArgs);
    }

    static MethodHandle upcallHandle(Class<?> fi, String name, FunctionDescriptor fdesc) {
        try {
            return MethodHandles.lookup().findVirtual(fi, name, fdesc.toMethodType());
        } catch (ReflectiveOperationException ex) {
            throw new AssertionError(ex);
        }
    }

    static MemoryLayout align(MemoryLayout layout, long align) {
        return switch (layout) {
            case PaddingLayout p -> p;
            case ValueLayout v -> v.withByteAlignment(align);
            case GroupLayout g -> {
                MemoryLayout[] alignedMembers = g.memberLayouts().stream()
                        .map(m -> align(m, align)).toArray(MemoryLayout[]::new);
                yield g instanceof StructLayout ?
                        MemoryLayout.structLayout(alignedMembers) : MemoryLayout.unionLayout(alignedMembers);
            }
            case SequenceLayout s -> MemoryLayout.sequenceLayout(s.elementCount(), align(s.elementLayout(), align));
        };
    }


    static {
    }

    static final SymbolLookup SYMBOL_LOOKUP = SymbolLookup.loaderLookup()
            .or(Linker.nativeLinker().defaultLookup());

    public static final ValueLayout.OfBoolean C_BOOL = (ValueLayout.OfBoolean) Linker.nativeLinker().canonicalLayouts().get("bool");
    public static final ValueLayout.OfByte C_CHAR =(ValueLayout.OfByte)Linker.nativeLinker().canonicalLayouts().get("char");
    public static final ValueLayout.OfShort C_SHORT = (ValueLayout.OfShort) Linker.nativeLinker().canonicalLayouts().get("short");
    public static final ValueLayout.OfInt C_INT = (ValueLayout.OfInt) Linker.nativeLinker().canonicalLayouts().get("int");
    public static final ValueLayout.OfLong C_LONG_LONG = (ValueLayout.OfLong) Linker.nativeLinker().canonicalLayouts().get("long long");
    public static final ValueLayout.OfFloat C_FLOAT = (ValueLayout.OfFloat) Linker.nativeLinker().canonicalLayouts().get("float");
    public static final ValueLayout.OfDouble C_DOUBLE = (ValueLayout.OfDouble) Linker.nativeLinker().canonicalLayouts().get("double");
    public static final AddressLayout C_POINTER = ((AddressLayout) Linker.nativeLinker().canonicalLayouts().get("void*"))
            .withTargetLayout(MemoryLayout.sequenceLayout(java.lang.Long.MAX_VALUE, C_CHAR));
    public static final ValueLayout.OfLong C_LONG = ValueLayout.JAVA_LONG;
    private static final int __STDC_FORMAT_MACROS = (int)1L;
    /**
     * {@snippet lang=c :
     * #define __STDC_FORMAT_MACROS 1
     * }
     */
    public static int __STDC_FORMAT_MACROS() {
        return __STDC_FORMAT_MACROS;
    }
    /**
     * {@snippet lang=c :
     * typedef int8_t i8
     * }
     */
    public static final OfByte i8 = Cubiomes.C_CHAR;
    /**
     * {@snippet lang=c :
     * typedef uint8_t u8
     * }
     */
    public static final OfByte u8 = Cubiomes.C_CHAR;
    /**
     * {@snippet lang=c :
     * typedef int16_t i16
     * }
     */
    public static final OfShort i16 = Cubiomes.C_SHORT;
    /**
     * {@snippet lang=c :
     * typedef uint16_t u16
     * }
     */
    public static final OfShort u16 = Cubiomes.C_SHORT;
    /**
     * {@snippet lang=c :
     * typedef int32_t i32
     * }
     */
    public static final OfInt i32 = Cubiomes.C_INT;
    /**
     * {@snippet lang=c :
     * typedef uint32_t u32
     * }
     */
    public static final OfInt u32 = Cubiomes.C_INT;
    /**
     * {@snippet lang=c :
     * typedef int64_t i64
     * }
     */
    public static final OfLong i64 = Cubiomes.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef uint64_t u64
     * }
     */
    public static final OfLong u64 = Cubiomes.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef float f32
     * }
     */
    public static final OfFloat f32 = Cubiomes.C_FLOAT;
    /**
     * {@snippet lang=c :
     * typedef double f64
     * }
     */
    public static final OfDouble f64 = Cubiomes.C_DOUBLE;

    private static class perlinInit {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            Cubiomes.C_POINTER,
            Cubiomes.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("perlinInit");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void perlinInit(PerlinNoise *noise, uint64_t *seed)
     * }
     */
    public static FunctionDescriptor perlinInit$descriptor() {
        return perlinInit.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void perlinInit(PerlinNoise *noise, uint64_t *seed)
     * }
     */
    public static MethodHandle perlinInit$handle() {
        return perlinInit.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void perlinInit(PerlinNoise *noise, uint64_t *seed)
     * }
     */
    public static MemorySegment perlinInit$address() {
        return perlinInit.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void perlinInit(PerlinNoise *noise, uint64_t *seed)
     * }
     */
    public static void perlinInit(MemorySegment noise, MemorySegment seed) {
        var mh$ = perlinInit.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("perlinInit", noise, seed);
            }
            mh$.invokeExact(noise, seed);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class xPerlinInit {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            Cubiomes.C_POINTER,
            Cubiomes.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("xPerlinInit");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void xPerlinInit(PerlinNoise *noise, Xoroshiro *xr)
     * }
     */
    public static FunctionDescriptor xPerlinInit$descriptor() {
        return xPerlinInit.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void xPerlinInit(PerlinNoise *noise, Xoroshiro *xr)
     * }
     */
    public static MethodHandle xPerlinInit$handle() {
        return xPerlinInit.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void xPerlinInit(PerlinNoise *noise, Xoroshiro *xr)
     * }
     */
    public static MemorySegment xPerlinInit$address() {
        return xPerlinInit.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void xPerlinInit(PerlinNoise *noise, Xoroshiro *xr)
     * }
     */
    public static void xPerlinInit(MemorySegment noise, MemorySegment xr) {
        var mh$ = xPerlinInit.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("xPerlinInit", noise, xr);
            }
            mh$.invokeExact(noise, xr);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class samplePerlin {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Cubiomes.C_DOUBLE,
            Cubiomes.C_POINTER,
            Cubiomes.C_DOUBLE,
            Cubiomes.C_DOUBLE,
            Cubiomes.C_DOUBLE,
            Cubiomes.C_DOUBLE,
            Cubiomes.C_DOUBLE
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("samplePerlin");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * double samplePerlin(const PerlinNoise *noise, double x, double y, double z, double yamp, double ymax)
     * }
     */
    public static FunctionDescriptor samplePerlin$descriptor() {
        return samplePerlin.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * double samplePerlin(const PerlinNoise *noise, double x, double y, double z, double yamp, double ymax)
     * }
     */
    public static MethodHandle samplePerlin$handle() {
        return samplePerlin.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * double samplePerlin(const PerlinNoise *noise, double x, double y, double z, double yamp, double ymax)
     * }
     */
    public static MemorySegment samplePerlin$address() {
        return samplePerlin.ADDR;
    }

    /**
     * {@snippet lang=c :
     * double samplePerlin(const PerlinNoise *noise, double x, double y, double z, double yamp, double ymax)
     * }
     */
    public static double samplePerlin(MemorySegment noise, double x, double y, double z, double yamp, double ymax) {
        var mh$ = samplePerlin.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("samplePerlin", noise, x, y, z, yamp, ymax);
            }
            return (double)mh$.invokeExact(noise, x, y, z, yamp, ymax);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class sampleSimplex2D {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Cubiomes.C_DOUBLE,
            Cubiomes.C_POINTER,
            Cubiomes.C_DOUBLE,
            Cubiomes.C_DOUBLE
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("sampleSimplex2D");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * double sampleSimplex2D(const PerlinNoise *noise, double x, double y)
     * }
     */
    public static FunctionDescriptor sampleSimplex2D$descriptor() {
        return sampleSimplex2D.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * double sampleSimplex2D(const PerlinNoise *noise, double x, double y)
     * }
     */
    public static MethodHandle sampleSimplex2D$handle() {
        return sampleSimplex2D.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * double sampleSimplex2D(const PerlinNoise *noise, double x, double y)
     * }
     */
    public static MemorySegment sampleSimplex2D$address() {
        return sampleSimplex2D.ADDR;
    }

    /**
     * {@snippet lang=c :
     * double sampleSimplex2D(const PerlinNoise *noise, double x, double y)
     * }
     */
    public static double sampleSimplex2D(MemorySegment noise, double x, double y) {
        var mh$ = sampleSimplex2D.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("sampleSimplex2D", noise, x, y);
            }
            return (double)mh$.invokeExact(noise, x, y);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class octaveInit {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            Cubiomes.C_POINTER,
            Cubiomes.C_POINTER,
            Cubiomes.C_POINTER,
            Cubiomes.C_INT,
            Cubiomes.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("octaveInit");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void octaveInit(OctaveNoise *noise, uint64_t *seed, PerlinNoise *octaves, int omin, int len)
     * }
     */
    public static FunctionDescriptor octaveInit$descriptor() {
        return octaveInit.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void octaveInit(OctaveNoise *noise, uint64_t *seed, PerlinNoise *octaves, int omin, int len)
     * }
     */
    public static MethodHandle octaveInit$handle() {
        return octaveInit.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void octaveInit(OctaveNoise *noise, uint64_t *seed, PerlinNoise *octaves, int omin, int len)
     * }
     */
    public static MemorySegment octaveInit$address() {
        return octaveInit.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void octaveInit(OctaveNoise *noise, uint64_t *seed, PerlinNoise *octaves, int omin, int len)
     * }
     */
    public static void octaveInit(MemorySegment noise, MemorySegment seed, MemorySegment octaves, int omin, int len) {
        var mh$ = octaveInit.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("octaveInit", noise, seed, octaves, omin, len);
            }
            mh$.invokeExact(noise, seed, octaves, omin, len);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class xOctaveLegacyInit {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            Cubiomes.C_POINTER,
            Cubiomes.C_POINTER,
            Cubiomes.C_POINTER,
            Cubiomes.C_INT,
            Cubiomes.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("xOctaveLegacyInit");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void xOctaveLegacyInit(OctaveNoise *noise, Xoroshiro *xr, PerlinNoise *octaves, int omin, int len)
     * }
     */
    public static FunctionDescriptor xOctaveLegacyInit$descriptor() {
        return xOctaveLegacyInit.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void xOctaveLegacyInit(OctaveNoise *noise, Xoroshiro *xr, PerlinNoise *octaves, int omin, int len)
     * }
     */
    public static MethodHandle xOctaveLegacyInit$handle() {
        return xOctaveLegacyInit.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void xOctaveLegacyInit(OctaveNoise *noise, Xoroshiro *xr, PerlinNoise *octaves, int omin, int len)
     * }
     */
    public static MemorySegment xOctaveLegacyInit$address() {
        return xOctaveLegacyInit.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void xOctaveLegacyInit(OctaveNoise *noise, Xoroshiro *xr, PerlinNoise *octaves, int omin, int len)
     * }
     */
    public static void xOctaveLegacyInit(MemorySegment noise, MemorySegment xr, MemorySegment octaves, int omin, int len) {
        var mh$ = xOctaveLegacyInit.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("xOctaveLegacyInit", noise, xr, octaves, omin, len);
            }
            mh$.invokeExact(noise, xr, octaves, omin, len);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class octaveInitBeta {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            Cubiomes.C_POINTER,
            Cubiomes.C_POINTER,
            Cubiomes.C_POINTER,
            Cubiomes.C_INT,
            Cubiomes.C_DOUBLE,
            Cubiomes.C_DOUBLE,
            Cubiomes.C_DOUBLE,
            Cubiomes.C_DOUBLE
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("octaveInitBeta");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void octaveInitBeta(OctaveNoise *noise, uint64_t *seed, PerlinNoise *octaves, int octcnt, double lac, double lacMul, double persist, double persistMul)
     * }
     */
    public static FunctionDescriptor octaveInitBeta$descriptor() {
        return octaveInitBeta.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void octaveInitBeta(OctaveNoise *noise, uint64_t *seed, PerlinNoise *octaves, int octcnt, double lac, double lacMul, double persist, double persistMul)
     * }
     */
    public static MethodHandle octaveInitBeta$handle() {
        return octaveInitBeta.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void octaveInitBeta(OctaveNoise *noise, uint64_t *seed, PerlinNoise *octaves, int octcnt, double lac, double lacMul, double persist, double persistMul)
     * }
     */
    public static MemorySegment octaveInitBeta$address() {
        return octaveInitBeta.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void octaveInitBeta(OctaveNoise *noise, uint64_t *seed, PerlinNoise *octaves, int octcnt, double lac, double lacMul, double persist, double persistMul)
     * }
     */
    public static void octaveInitBeta(MemorySegment noise, MemorySegment seed, MemorySegment octaves, int octcnt, double lac, double lacMul, double persist, double persistMul) {
        var mh$ = octaveInitBeta.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("octaveInitBeta", noise, seed, octaves, octcnt, lac, lacMul, persist, persistMul);
            }
            mh$.invokeExact(noise, seed, octaves, octcnt, lac, lacMul, persist, persistMul);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class xOctaveInit {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Cubiomes.C_INT,
            Cubiomes.C_POINTER,
            Cubiomes.C_POINTER,
            Cubiomes.C_POINTER,
            Cubiomes.C_POINTER,
            Cubiomes.C_INT,
            Cubiomes.C_INT,
            Cubiomes.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("xOctaveInit");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int xOctaveInit(OctaveNoise *noise, Xoroshiro *xr, PerlinNoise *octaves, const double *amplitudes, int omin, int len, int nmax)
     * }
     */
    public static FunctionDescriptor xOctaveInit$descriptor() {
        return xOctaveInit.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int xOctaveInit(OctaveNoise *noise, Xoroshiro *xr, PerlinNoise *octaves, const double *amplitudes, int omin, int len, int nmax)
     * }
     */
    public static MethodHandle xOctaveInit$handle() {
        return xOctaveInit.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int xOctaveInit(OctaveNoise *noise, Xoroshiro *xr, PerlinNoise *octaves, const double *amplitudes, int omin, int len, int nmax)
     * }
     */
    public static MemorySegment xOctaveInit$address() {
        return xOctaveInit.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int xOctaveInit(OctaveNoise *noise, Xoroshiro *xr, PerlinNoise *octaves, const double *amplitudes, int omin, int len, int nmax)
     * }
     */
    public static int xOctaveInit(MemorySegment noise, MemorySegment xr, MemorySegment octaves, MemorySegment amplitudes, int omin, int len, int nmax) {
        var mh$ = xOctaveInit.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("xOctaveInit", noise, xr, octaves, amplitudes, omin, len, nmax);
            }
            return (int)mh$.invokeExact(noise, xr, octaves, amplitudes, omin, len, nmax);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class sampleOctave {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Cubiomes.C_DOUBLE,
            Cubiomes.C_POINTER,
            Cubiomes.C_DOUBLE,
            Cubiomes.C_DOUBLE,
            Cubiomes.C_DOUBLE
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("sampleOctave");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * double sampleOctave(const OctaveNoise *noise, double x, double y, double z)
     * }
     */
    public static FunctionDescriptor sampleOctave$descriptor() {
        return sampleOctave.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * double sampleOctave(const OctaveNoise *noise, double x, double y, double z)
     * }
     */
    public static MethodHandle sampleOctave$handle() {
        return sampleOctave.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * double sampleOctave(const OctaveNoise *noise, double x, double y, double z)
     * }
     */
    public static MemorySegment sampleOctave$address() {
        return sampleOctave.ADDR;
    }

    /**
     * {@snippet lang=c :
     * double sampleOctave(const OctaveNoise *noise, double x, double y, double z)
     * }
     */
    public static double sampleOctave(MemorySegment noise, double x, double y, double z) {
        var mh$ = sampleOctave.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("sampleOctave", noise, x, y, z);
            }
            return (double)mh$.invokeExact(noise, x, y, z);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class sampleOctaveAmp {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Cubiomes.C_DOUBLE,
            Cubiomes.C_POINTER,
            Cubiomes.C_DOUBLE,
            Cubiomes.C_DOUBLE,
            Cubiomes.C_DOUBLE,
            Cubiomes.C_DOUBLE,
            Cubiomes.C_DOUBLE,
            Cubiomes.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("sampleOctaveAmp");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * double sampleOctaveAmp(const OctaveNoise *noise, double x, double y, double z, double yamp, double ymin, int ydefault)
     * }
     */
    public static FunctionDescriptor sampleOctaveAmp$descriptor() {
        return sampleOctaveAmp.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * double sampleOctaveAmp(const OctaveNoise *noise, double x, double y, double z, double yamp, double ymin, int ydefault)
     * }
     */
    public static MethodHandle sampleOctaveAmp$handle() {
        return sampleOctaveAmp.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * double sampleOctaveAmp(const OctaveNoise *noise, double x, double y, double z, double yamp, double ymin, int ydefault)
     * }
     */
    public static MemorySegment sampleOctaveAmp$address() {
        return sampleOctaveAmp.ADDR;
    }

    /**
     * {@snippet lang=c :
     * double sampleOctaveAmp(const OctaveNoise *noise, double x, double y, double z, double yamp, double ymin, int ydefault)
     * }
     */
    public static double sampleOctaveAmp(MemorySegment noise, double x, double y, double z, double yamp, double ymin, int ydefault) {
        var mh$ = sampleOctaveAmp.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("sampleOctaveAmp", noise, x, y, z, yamp, ymin, ydefault);
            }
            return (double)mh$.invokeExact(noise, x, y, z, yamp, ymin, ydefault);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class sampleOctave2D {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Cubiomes.C_DOUBLE,
            Cubiomes.C_POINTER,
            Cubiomes.C_DOUBLE,
            Cubiomes.C_DOUBLE
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("sampleOctave2D");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * double sampleOctave2D(const OctaveNoise *noise, double x, double z)
     * }
     */
    public static FunctionDescriptor sampleOctave2D$descriptor() {
        return sampleOctave2D.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * double sampleOctave2D(const OctaveNoise *noise, double x, double z)
     * }
     */
    public static MethodHandle sampleOctave2D$handle() {
        return sampleOctave2D.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * double sampleOctave2D(const OctaveNoise *noise, double x, double z)
     * }
     */
    public static MemorySegment sampleOctave2D$address() {
        return sampleOctave2D.ADDR;
    }

    /**
     * {@snippet lang=c :
     * double sampleOctave2D(const OctaveNoise *noise, double x, double z)
     * }
     */
    public static double sampleOctave2D(MemorySegment noise, double x, double z) {
        var mh$ = sampleOctave2D.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("sampleOctave2D", noise, x, z);
            }
            return (double)mh$.invokeExact(noise, x, z);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class sampleOctaveBeta17Biome {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Cubiomes.C_DOUBLE,
            Cubiomes.C_POINTER,
            Cubiomes.C_DOUBLE,
            Cubiomes.C_DOUBLE
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("sampleOctaveBeta17Biome");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * double sampleOctaveBeta17Biome(const OctaveNoise *noise, double x, double z)
     * }
     */
    public static FunctionDescriptor sampleOctaveBeta17Biome$descriptor() {
        return sampleOctaveBeta17Biome.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * double sampleOctaveBeta17Biome(const OctaveNoise *noise, double x, double z)
     * }
     */
    public static MethodHandle sampleOctaveBeta17Biome$handle() {
        return sampleOctaveBeta17Biome.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * double sampleOctaveBeta17Biome(const OctaveNoise *noise, double x, double z)
     * }
     */
    public static MemorySegment sampleOctaveBeta17Biome$address() {
        return sampleOctaveBeta17Biome.ADDR;
    }

    /**
     * {@snippet lang=c :
     * double sampleOctaveBeta17Biome(const OctaveNoise *noise, double x, double z)
     * }
     */
    public static double sampleOctaveBeta17Biome(MemorySegment noise, double x, double z) {
        var mh$ = sampleOctaveBeta17Biome.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("sampleOctaveBeta17Biome", noise, x, z);
            }
            return (double)mh$.invokeExact(noise, x, z);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class sampleOctaveBeta17Terrain {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            Cubiomes.C_POINTER,
            Cubiomes.C_POINTER,
            Cubiomes.C_DOUBLE,
            Cubiomes.C_DOUBLE,
            Cubiomes.C_INT,
            Cubiomes.C_DOUBLE
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("sampleOctaveBeta17Terrain");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void sampleOctaveBeta17Terrain(const OctaveNoise *noise, double *v, double x, double z, int yLacFlag, double lacmin)
     * }
     */
    public static FunctionDescriptor sampleOctaveBeta17Terrain$descriptor() {
        return sampleOctaveBeta17Terrain.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void sampleOctaveBeta17Terrain(const OctaveNoise *noise, double *v, double x, double z, int yLacFlag, double lacmin)
     * }
     */
    public static MethodHandle sampleOctaveBeta17Terrain$handle() {
        return sampleOctaveBeta17Terrain.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void sampleOctaveBeta17Terrain(const OctaveNoise *noise, double *v, double x, double z, int yLacFlag, double lacmin)
     * }
     */
    public static MemorySegment sampleOctaveBeta17Terrain$address() {
        return sampleOctaveBeta17Terrain.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void sampleOctaveBeta17Terrain(const OctaveNoise *noise, double *v, double x, double z, int yLacFlag, double lacmin)
     * }
     */
    public static void sampleOctaveBeta17Terrain(MemorySegment noise, MemorySegment v, double x, double z, int yLacFlag, double lacmin) {
        var mh$ = sampleOctaveBeta17Terrain.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("sampleOctaveBeta17Terrain", noise, v, x, z, yLacFlag, lacmin);
            }
            mh$.invokeExact(noise, v, x, z, yLacFlag, lacmin);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class doublePerlinInit {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            Cubiomes.C_POINTER,
            Cubiomes.C_POINTER,
            Cubiomes.C_POINTER,
            Cubiomes.C_POINTER,
            Cubiomes.C_INT,
            Cubiomes.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("doublePerlinInit");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void doublePerlinInit(DoublePerlinNoise *noise, uint64_t *seed, PerlinNoise *octavesA, PerlinNoise *octavesB, int omin, int len)
     * }
     */
    public static FunctionDescriptor doublePerlinInit$descriptor() {
        return doublePerlinInit.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void doublePerlinInit(DoublePerlinNoise *noise, uint64_t *seed, PerlinNoise *octavesA, PerlinNoise *octavesB, int omin, int len)
     * }
     */
    public static MethodHandle doublePerlinInit$handle() {
        return doublePerlinInit.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void doublePerlinInit(DoublePerlinNoise *noise, uint64_t *seed, PerlinNoise *octavesA, PerlinNoise *octavesB, int omin, int len)
     * }
     */
    public static MemorySegment doublePerlinInit$address() {
        return doublePerlinInit.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void doublePerlinInit(DoublePerlinNoise *noise, uint64_t *seed, PerlinNoise *octavesA, PerlinNoise *octavesB, int omin, int len)
     * }
     */
    public static void doublePerlinInit(MemorySegment noise, MemorySegment seed, MemorySegment octavesA, MemorySegment octavesB, int omin, int len) {
        var mh$ = doublePerlinInit.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("doublePerlinInit", noise, seed, octavesA, octavesB, omin, len);
            }
            mh$.invokeExact(noise, seed, octavesA, octavesB, omin, len);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class xDoublePerlinInit {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Cubiomes.C_INT,
            Cubiomes.C_POINTER,
            Cubiomes.C_POINTER,
            Cubiomes.C_POINTER,
            Cubiomes.C_POINTER,
            Cubiomes.C_INT,
            Cubiomes.C_INT,
            Cubiomes.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("xDoublePerlinInit");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int xDoublePerlinInit(DoublePerlinNoise *noise, Xoroshiro *xr, PerlinNoise *octaves, const double *amplitudes, int omin, int len, int nmax)
     * }
     */
    public static FunctionDescriptor xDoublePerlinInit$descriptor() {
        return xDoublePerlinInit.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int xDoublePerlinInit(DoublePerlinNoise *noise, Xoroshiro *xr, PerlinNoise *octaves, const double *amplitudes, int omin, int len, int nmax)
     * }
     */
    public static MethodHandle xDoublePerlinInit$handle() {
        return xDoublePerlinInit.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int xDoublePerlinInit(DoublePerlinNoise *noise, Xoroshiro *xr, PerlinNoise *octaves, const double *amplitudes, int omin, int len, int nmax)
     * }
     */
    public static MemorySegment xDoublePerlinInit$address() {
        return xDoublePerlinInit.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int xDoublePerlinInit(DoublePerlinNoise *noise, Xoroshiro *xr, PerlinNoise *octaves, const double *amplitudes, int omin, int len, int nmax)
     * }
     */
    public static int xDoublePerlinInit(MemorySegment noise, MemorySegment xr, MemorySegment octaves, MemorySegment amplitudes, int omin, int len, int nmax) {
        var mh$ = xDoublePerlinInit.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("xDoublePerlinInit", noise, xr, octaves, amplitudes, omin, len, nmax);
            }
            return (int)mh$.invokeExact(noise, xr, octaves, amplitudes, omin, len, nmax);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class sampleDoublePerlin {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Cubiomes.C_DOUBLE,
            Cubiomes.C_POINTER,
            Cubiomes.C_DOUBLE,
            Cubiomes.C_DOUBLE,
            Cubiomes.C_DOUBLE
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("sampleDoublePerlin");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * double sampleDoublePerlin(const DoublePerlinNoise *noise, double x, double y, double z)
     * }
     */
    public static FunctionDescriptor sampleDoublePerlin$descriptor() {
        return sampleDoublePerlin.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * double sampleDoublePerlin(const DoublePerlinNoise *noise, double x, double y, double z)
     * }
     */
    public static MethodHandle sampleDoublePerlin$handle() {
        return sampleDoublePerlin.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * double sampleDoublePerlin(const DoublePerlinNoise *noise, double x, double y, double z)
     * }
     */
    public static MemorySegment sampleDoublePerlin$address() {
        return sampleDoublePerlin.ADDR;
    }

    /**
     * {@snippet lang=c :
     * double sampleDoublePerlin(const DoublePerlinNoise *noise, double x, double y, double z)
     * }
     */
    public static double sampleDoublePerlin(MemorySegment noise, double x, double y, double z) {
        var mh$ = sampleDoublePerlin.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("sampleDoublePerlin", noise, x, y, z);
            }
            return (double)mh$.invokeExact(noise, x, y, z);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    private static final int MC_UNDEF = (int)0L;
    /**
     * {@snippet lang=c :
     * enum MCVersion.MC_UNDEF = 0
     * }
     */
    public static int MC_UNDEF() {
        return MC_UNDEF;
    }
    private static final int MC_B1_7 = (int)1L;
    /**
     * {@snippet lang=c :
     * enum MCVersion.MC_B1_7 = 1
     * }
     */
    public static int MC_B1_7() {
        return MC_B1_7;
    }
    private static final int MC_B1_8 = (int)2L;
    /**
     * {@snippet lang=c :
     * enum MCVersion.MC_B1_8 = 2
     * }
     */
    public static int MC_B1_8() {
        return MC_B1_8;
    }
    private static final int MC_1_0_0 = (int)3L;
    /**
     * {@snippet lang=c :
     * enum MCVersion.MC_1_0_0 = 3
     * }
     */
    public static int MC_1_0_0() {
        return MC_1_0_0;
    }
    private static final int MC_1_0 = (int)3L;
    /**
     * {@snippet lang=c :
     * enum MCVersion.MC_1_0 = 3
     * }
     */
    public static int MC_1_0() {
        return MC_1_0;
    }
    private static final int MC_1_1_0 = (int)4L;
    /**
     * {@snippet lang=c :
     * enum MCVersion.MC_1_1_0 = 4
     * }
     */
    public static int MC_1_1_0() {
        return MC_1_1_0;
    }
    private static final int MC_1_1 = (int)4L;
    /**
     * {@snippet lang=c :
     * enum MCVersion.MC_1_1 = 4
     * }
     */
    public static int MC_1_1() {
        return MC_1_1;
    }
    private static final int MC_1_2_5 = (int)5L;
    /**
     * {@snippet lang=c :
     * enum MCVersion.MC_1_2_5 = 5
     * }
     */
    public static int MC_1_2_5() {
        return MC_1_2_5;
    }
    private static final int MC_1_2 = (int)5L;
    /**
     * {@snippet lang=c :
     * enum MCVersion.MC_1_2 = 5
     * }
     */
    public static int MC_1_2() {
        return MC_1_2;
    }
    private static final int MC_1_3_2 = (int)6L;
    /**
     * {@snippet lang=c :
     * enum MCVersion.MC_1_3_2 = 6
     * }
     */
    public static int MC_1_3_2() {
        return MC_1_3_2;
    }
    private static final int MC_1_3 = (int)6L;
    /**
     * {@snippet lang=c :
     * enum MCVersion.MC_1_3 = 6
     * }
     */
    public static int MC_1_3() {
        return MC_1_3;
    }
    private static final int MC_1_4_7 = (int)7L;
    /**
     * {@snippet lang=c :
     * enum MCVersion.MC_1_4_7 = 7
     * }
     */
    public static int MC_1_4_7() {
        return MC_1_4_7;
    }
    private static final int MC_1_4 = (int)7L;
    /**
     * {@snippet lang=c :
     * enum MCVersion.MC_1_4 = 7
     * }
     */
    public static int MC_1_4() {
        return MC_1_4;
    }
    private static final int MC_1_5_2 = (int)8L;
    /**
     * {@snippet lang=c :
     * enum MCVersion.MC_1_5_2 = 8
     * }
     */
    public static int MC_1_5_2() {
        return MC_1_5_2;
    }
    private static final int MC_1_5 = (int)8L;
    /**
     * {@snippet lang=c :
     * enum MCVersion.MC_1_5 = 8
     * }
     */
    public static int MC_1_5() {
        return MC_1_5;
    }
    private static final int MC_1_6_4 = (int)9L;
    /**
     * {@snippet lang=c :
     * enum MCVersion.MC_1_6_4 = 9
     * }
     */
    public static int MC_1_6_4() {
        return MC_1_6_4;
    }
    private static final int MC_1_6 = (int)9L;
    /**
     * {@snippet lang=c :
     * enum MCVersion.MC_1_6 = 9
     * }
     */
    public static int MC_1_6() {
        return MC_1_6;
    }
    private static final int MC_1_7_10 = (int)10L;
    /**
     * {@snippet lang=c :
     * enum MCVersion.MC_1_7_10 = 10
     * }
     */
    public static int MC_1_7_10() {
        return MC_1_7_10;
    }
    private static final int MC_1_7 = (int)10L;
    /**
     * {@snippet lang=c :
     * enum MCVersion.MC_1_7 = 10
     * }
     */
    public static int MC_1_7() {
        return MC_1_7;
    }
    private static final int MC_1_8_9 = (int)11L;
    /**
     * {@snippet lang=c :
     * enum MCVersion.MC_1_8_9 = 11
     * }
     */
    public static int MC_1_8_9() {
        return MC_1_8_9;
    }
    private static final int MC_1_8 = (int)11L;
    /**
     * {@snippet lang=c :
     * enum MCVersion.MC_1_8 = 11
     * }
     */
    public static int MC_1_8() {
        return MC_1_8;
    }
    private static final int MC_1_9_4 = (int)12L;
    /**
     * {@snippet lang=c :
     * enum MCVersion.MC_1_9_4 = 12
     * }
     */
    public static int MC_1_9_4() {
        return MC_1_9_4;
    }
    private static final int MC_1_9 = (int)12L;
    /**
     * {@snippet lang=c :
     * enum MCVersion.MC_1_9 = 12
     * }
     */
    public static int MC_1_9() {
        return MC_1_9;
    }
    private static final int MC_1_10_2 = (int)13L;
    /**
     * {@snippet lang=c :
     * enum MCVersion.MC_1_10_2 = 13
     * }
     */
    public static int MC_1_10_2() {
        return MC_1_10_2;
    }
    private static final int MC_1_10 = (int)13L;
    /**
     * {@snippet lang=c :
     * enum MCVersion.MC_1_10 = 13
     * }
     */
    public static int MC_1_10() {
        return MC_1_10;
    }
    private static final int MC_1_11_2 = (int)14L;
    /**
     * {@snippet lang=c :
     * enum MCVersion.MC_1_11_2 = 14
     * }
     */
    public static int MC_1_11_2() {
        return MC_1_11_2;
    }
    private static final int MC_1_11 = (int)14L;
    /**
     * {@snippet lang=c :
     * enum MCVersion.MC_1_11 = 14
     * }
     */
    public static int MC_1_11() {
        return MC_1_11;
    }
    private static final int MC_1_12_2 = (int)15L;
    /**
     * {@snippet lang=c :
     * enum MCVersion.MC_1_12_2 = 15
     * }
     */
    public static int MC_1_12_2() {
        return MC_1_12_2;
    }
    private static final int MC_1_12 = (int)15L;
    /**
     * {@snippet lang=c :
     * enum MCVersion.MC_1_12 = 15
     * }
     */
    public static int MC_1_12() {
        return MC_1_12;
    }
    private static final int MC_1_13_2 = (int)16L;
    /**
     * {@snippet lang=c :
     * enum MCVersion.MC_1_13_2 = 16
     * }
     */
    public static int MC_1_13_2() {
        return MC_1_13_2;
    }
    private static final int MC_1_13 = (int)16L;
    /**
     * {@snippet lang=c :
     * enum MCVersion.MC_1_13 = 16
     * }
     */
    public static int MC_1_13() {
        return MC_1_13;
    }
    private static final int MC_1_14_4 = (int)17L;
    /**
     * {@snippet lang=c :
     * enum MCVersion.MC_1_14_4 = 17
     * }
     */
    public static int MC_1_14_4() {
        return MC_1_14_4;
    }
    private static final int MC_1_14 = (int)17L;
    /**
     * {@snippet lang=c :
     * enum MCVersion.MC_1_14 = 17
     * }
     */
    public static int MC_1_14() {
        return MC_1_14;
    }
    private static final int MC_1_15_2 = (int)18L;
    /**
     * {@snippet lang=c :
     * enum MCVersion.MC_1_15_2 = 18
     * }
     */
    public static int MC_1_15_2() {
        return MC_1_15_2;
    }
    private static final int MC_1_15 = (int)18L;
    /**
     * {@snippet lang=c :
     * enum MCVersion.MC_1_15 = 18
     * }
     */
    public static int MC_1_15() {
        return MC_1_15;
    }
    private static final int MC_1_16_1 = (int)19L;
    /**
     * {@snippet lang=c :
     * enum MCVersion.MC_1_16_1 = 19
     * }
     */
    public static int MC_1_16_1() {
        return MC_1_16_1;
    }
    private static final int MC_1_16_5 = (int)20L;
    /**
     * {@snippet lang=c :
     * enum MCVersion.MC_1_16_5 = 20
     * }
     */
    public static int MC_1_16_5() {
        return MC_1_16_5;
    }
    private static final int MC_1_16 = (int)20L;
    /**
     * {@snippet lang=c :
     * enum MCVersion.MC_1_16 = 20
     * }
     */
    public static int MC_1_16() {
        return MC_1_16;
    }
    private static final int MC_1_17_1 = (int)21L;
    /**
     * {@snippet lang=c :
     * enum MCVersion.MC_1_17_1 = 21
     * }
     */
    public static int MC_1_17_1() {
        return MC_1_17_1;
    }
    private static final int MC_1_17 = (int)21L;
    /**
     * {@snippet lang=c :
     * enum MCVersion.MC_1_17 = 21
     * }
     */
    public static int MC_1_17() {
        return MC_1_17;
    }
    private static final int MC_1_18_2 = (int)22L;
    /**
     * {@snippet lang=c :
     * enum MCVersion.MC_1_18_2 = 22
     * }
     */
    public static int MC_1_18_2() {
        return MC_1_18_2;
    }
    private static final int MC_1_18 = (int)22L;
    /**
     * {@snippet lang=c :
     * enum MCVersion.MC_1_18 = 22
     * }
     */
    public static int MC_1_18() {
        return MC_1_18;
    }
    private static final int MC_1_19_2 = (int)23L;
    /**
     * {@snippet lang=c :
     * enum MCVersion.MC_1_19_2 = 23
     * }
     */
    public static int MC_1_19_2() {
        return MC_1_19_2;
    }
    private static final int MC_1_19_4 = (int)24L;
    /**
     * {@snippet lang=c :
     * enum MCVersion.MC_1_19_4 = 24
     * }
     */
    public static int MC_1_19_4() {
        return MC_1_19_4;
    }
    private static final int MC_1_19 = (int)24L;
    /**
     * {@snippet lang=c :
     * enum MCVersion.MC_1_19 = 24
     * }
     */
    public static int MC_1_19() {
        return MC_1_19;
    }
    private static final int MC_1_20_6 = (int)25L;
    /**
     * {@snippet lang=c :
     * enum MCVersion.MC_1_20_6 = 25
     * }
     */
    public static int MC_1_20_6() {
        return MC_1_20_6;
    }
    private static final int MC_1_20 = (int)25L;
    /**
     * {@snippet lang=c :
     * enum MCVersion.MC_1_20 = 25
     * }
     */
    public static int MC_1_20() {
        return MC_1_20;
    }
    private static final int MC_1_21_1 = (int)26L;
    /**
     * {@snippet lang=c :
     * enum MCVersion.MC_1_21_1 = 26
     * }
     */
    public static int MC_1_21_1() {
        return MC_1_21_1;
    }
    private static final int MC_1_21_3 = (int)27L;
    /**
     * {@snippet lang=c :
     * enum MCVersion.MC_1_21_3 = 27
     * }
     */
    public static int MC_1_21_3() {
        return MC_1_21_3;
    }
    private static final int MC_1_21_WD = (int)28L;
    /**
     * {@snippet lang=c :
     * enum MCVersion.MC_1_21_WD = 28
     * }
     */
    public static int MC_1_21_WD() {
        return MC_1_21_WD;
    }
    private static final int MC_1_21_4 = (int)28L;
    /**
     * {@snippet lang=c :
     * enum MCVersion.MC_1_21_4 = 28
     * }
     */
    public static int MC_1_21_4() {
        return MC_1_21_4;
    }
    private static final int MC_1_21_5 = (int)29L;
    /**
     * {@snippet lang=c :
     * enum MCVersion.MC_1_21_5 = 29
     * }
     */
    public static int MC_1_21_5() {
        return MC_1_21_5;
    }
    private static final int MC_1_21_6 = (int)30L;
    /**
     * {@snippet lang=c :
     * enum MCVersion.MC_1_21_6 = 30
     * }
     */
    public static int MC_1_21_6() {
        return MC_1_21_6;
    }
    private static final int MC_1_21_9 = (int)31L;
    /**
     * {@snippet lang=c :
     * enum MCVersion.MC_1_21_9 = 31
     * }
     */
    public static int MC_1_21_9() {
        return MC_1_21_9;
    }
    private static final int MC_1_21_11 = (int)32L;
    /**
     * {@snippet lang=c :
     * enum MCVersion.MC_1_21_11 = 32
     * }
     */
    public static int MC_1_21_11() {
        return MC_1_21_11;
    }
    private static final int MC_1_21 = (int)32L;
    /**
     * {@snippet lang=c :
     * enum MCVersion.MC_1_21 = 32
     * }
     */
    public static int MC_1_21() {
        return MC_1_21;
    }
    private static final int MC_NEWEST = (int)32L;
    /**
     * {@snippet lang=c :
     * enum MCVersion.MC_NEWEST = 32
     * }
     */
    public static int MC_NEWEST() {
        return MC_NEWEST;
    }
    private static final int DIM_NETHER = (int)-1L;
    /**
     * {@snippet lang=c :
     * enum Dimension.DIM_NETHER = -1
     * }
     */
    public static int DIM_NETHER() {
        return DIM_NETHER;
    }
    private static final int DIM_OVERWORLD = (int)0L;
    /**
     * {@snippet lang=c :
     * enum Dimension.DIM_OVERWORLD = 0
     * }
     */
    public static int DIM_OVERWORLD() {
        return DIM_OVERWORLD;
    }
    private static final int DIM_END = (int)1L;
    /**
     * {@snippet lang=c :
     * enum Dimension.DIM_END = 1
     * }
     */
    public static int DIM_END() {
        return DIM_END;
    }
    private static final int DIM_UNDEF = (int)1000L;
    /**
     * {@snippet lang=c :
     * enum Dimension.DIM_UNDEF = 1000
     * }
     */
    public static int DIM_UNDEF() {
        return DIM_UNDEF;
    }
    private static final int none = (int)-1L;
    /**
     * {@snippet lang=c :
     * enum BiomeID.none = -1
     * }
     */
    public static int none() {
        return none;
    }
    private static final int ocean = (int)0L;
    /**
     * {@snippet lang=c :
     * enum BiomeID.ocean = 0
     * }
     */
    public static int ocean() {
        return ocean;
    }
    private static final int plains = (int)1L;
    /**
     * {@snippet lang=c :
     * enum BiomeID.plains = 1
     * }
     */
    public static int plains() {
        return plains;
    }
    private static final int desert = (int)2L;
    /**
     * {@snippet lang=c :
     * enum BiomeID.desert = 2
     * }
     */
    public static int desert() {
        return desert;
    }
    private static final int mountains = (int)3L;
    /**
     * {@snippet lang=c :
     * enum BiomeID.mountains = 3
     * }
     */
    public static int mountains() {
        return mountains;
    }
    private static final int extremeHills = (int)3L;
    /**
     * {@snippet lang=c :
     * enum BiomeID.extremeHills = 3
     * }
     */
    public static int extremeHills() {
        return extremeHills;
    }
    private static final int forest = (int)4L;
    /**
     * {@snippet lang=c :
     * enum BiomeID.forest = 4
     * }
     */
    public static int forest() {
        return forest;
    }
    private static final int taiga = (int)5L;
    /**
     * {@snippet lang=c :
     * enum BiomeID.taiga = 5
     * }
     */
    public static int taiga() {
        return taiga;
    }
    private static final int swamp = (int)6L;
    /**
     * {@snippet lang=c :
     * enum BiomeID.swamp = 6
     * }
     */
    public static int swamp() {
        return swamp;
    }
    private static final int swampland = (int)6L;
    /**
     * {@snippet lang=c :
     * enum BiomeID.swampland = 6
     * }
     */
    public static int swampland() {
        return swampland;
    }
    private static final int river = (int)7L;
    /**
     * {@snippet lang=c :
     * enum BiomeID.river = 7
     * }
     */
    public static int river() {
        return river;
    }
    private static final int nether_wastes = (int)8L;
    /**
     * {@snippet lang=c :
     * enum BiomeID.nether_wastes = 8
     * }
     */
    public static int nether_wastes() {
        return nether_wastes;
    }
    private static final int hell = (int)8L;
    /**
     * {@snippet lang=c :
     * enum BiomeID.hell = 8
     * }
     */
    public static int hell() {
        return hell;
    }
    private static final int the_end = (int)9L;
    /**
     * {@snippet lang=c :
     * enum BiomeID.the_end = 9
     * }
     */
    public static int the_end() {
        return the_end;
    }
    private static final int sky = (int)9L;
    /**
     * {@snippet lang=c :
     * enum BiomeID.sky = 9
     * }
     */
    public static int sky() {
        return sky;
    }
    private static final int frozen_ocean = (int)10L;
    /**
     * {@snippet lang=c :
     * enum BiomeID.frozen_ocean = 10
     * }
     */
    public static int frozen_ocean() {
        return frozen_ocean;
    }
    private static final int frozenOcean = (int)10L;
    /**
     * {@snippet lang=c :
     * enum BiomeID.frozenOcean = 10
     * }
     */
    public static int frozenOcean() {
        return frozenOcean;
    }
    private static final int frozen_river = (int)11L;
    /**
     * {@snippet lang=c :
     * enum BiomeID.frozen_river = 11
     * }
     */
    public static int frozen_river() {
        return frozen_river;
    }
    private static final int frozenRiver = (int)11L;
    /**
     * {@snippet lang=c :
     * enum BiomeID.frozenRiver = 11
     * }
     */
    public static int frozenRiver() {
        return frozenRiver;
    }
    private static final int snowy_tundra = (int)12L;
    /**
     * {@snippet lang=c :
     * enum BiomeID.snowy_tundra = 12
     * }
     */
    public static int snowy_tundra() {
        return snowy_tundra;
    }
    private static final int icePlains = (int)12L;
    /**
     * {@snippet lang=c :
     * enum BiomeID.icePlains = 12
     * }
     */
    public static int icePlains() {
        return icePlains;
    }
    private static final int snowy_mountains = (int)13L;
    /**
     * {@snippet lang=c :
     * enum BiomeID.snowy_mountains = 13
     * }
     */
    public static int snowy_mountains() {
        return snowy_mountains;
    }
    private static final int iceMountains = (int)13L;
    /**
     * {@snippet lang=c :
     * enum BiomeID.iceMountains = 13
     * }
     */
    public static int iceMountains() {
        return iceMountains;
    }
    private static final int mushroom_fields = (int)14L;
    /**
     * {@snippet lang=c :
     * enum BiomeID.mushroom_fields = 14
     * }
     */
    public static int mushroom_fields() {
        return mushroom_fields;
    }
    private static final int mushroomIsland = (int)14L;
    /**
     * {@snippet lang=c :
     * enum BiomeID.mushroomIsland = 14
     * }
     */
    public static int mushroomIsland() {
        return mushroomIsland;
    }
    private static final int mushroom_field_shore = (int)15L;
    /**
     * {@snippet lang=c :
     * enum BiomeID.mushroom_field_shore = 15
     * }
     */
    public static int mushroom_field_shore() {
        return mushroom_field_shore;
    }
    private static final int mushroomIslandShore = (int)15L;
    /**
     * {@snippet lang=c :
     * enum BiomeID.mushroomIslandShore = 15
     * }
     */
    public static int mushroomIslandShore() {
        return mushroomIslandShore;
    }
    private static final int beach = (int)16L;
    /**
     * {@snippet lang=c :
     * enum BiomeID.beach = 16
     * }
     */
    public static int beach() {
        return beach;
    }
    private static final int desert_hills = (int)17L;
    /**
     * {@snippet lang=c :
     * enum BiomeID.desert_hills = 17
     * }
     */
    public static int desert_hills() {
        return desert_hills;
    }
    private static final int desertHills = (int)17L;
    /**
     * {@snippet lang=c :
     * enum BiomeID.desertHills = 17
     * }
     */
    public static int desertHills() {
        return desertHills;
    }
    private static final int wooded_hills = (int)18L;
    /**
     * {@snippet lang=c :
     * enum BiomeID.wooded_hills = 18
     * }
     */
    public static int wooded_hills() {
        return wooded_hills;
    }
    private static final int forestHills = (int)18L;
    /**
     * {@snippet lang=c :
     * enum BiomeID.forestHills = 18
     * }
     */
    public static int forestHills() {
        return forestHills;
    }
    private static final int taiga_hills = (int)19L;
    /**
     * {@snippet lang=c :
     * enum BiomeID.taiga_hills = 19
     * }
     */
    public static int taiga_hills() {
        return taiga_hills;
    }
    private static final int taigaHills = (int)19L;
    /**
     * {@snippet lang=c :
     * enum BiomeID.taigaHills = 19
     * }
     */
    public static int taigaHills() {
        return taigaHills;
    }
    private static final int mountain_edge = (int)20L;
    /**
     * {@snippet lang=c :
     * enum BiomeID.mountain_edge = 20
     * }
     */
    public static int mountain_edge() {
        return mountain_edge;
    }
    private static final int extremeHillsEdge = (int)20L;
    /**
     * {@snippet lang=c :
     * enum BiomeID.extremeHillsEdge = 20
     * }
     */
    public static int extremeHillsEdge() {
        return extremeHillsEdge;
    }
    private static final int jungle = (int)21L;
    /**
     * {@snippet lang=c :
     * enum BiomeID.jungle = 21
     * }
     */
    public static int jungle() {
        return jungle;
    }
    private static final int jungle_hills = (int)22L;
    /**
     * {@snippet lang=c :
     * enum BiomeID.jungle_hills = 22
     * }
     */
    public static int jungle_hills() {
        return jungle_hills;
    }
    private static final int jungleHills = (int)22L;
    /**
     * {@snippet lang=c :
     * enum BiomeID.jungleHills = 22
     * }
     */
    public static int jungleHills() {
        return jungleHills;
    }
    private static final int jungle_edge = (int)23L;
    /**
     * {@snippet lang=c :
     * enum BiomeID.jungle_edge = 23
     * }
     */
    public static int jungle_edge() {
        return jungle_edge;
    }
    private static final int jungleEdge = (int)23L;
    /**
     * {@snippet lang=c :
     * enum BiomeID.jungleEdge = 23
     * }
     */
    public static int jungleEdge() {
        return jungleEdge;
    }
    private static final int deep_ocean = (int)24L;
    /**
     * {@snippet lang=c :
     * enum BiomeID.deep_ocean = 24
     * }
     */
    public static int deep_ocean() {
        return deep_ocean;
    }
    private static final int deepOcean = (int)24L;
    /**
     * {@snippet lang=c :
     * enum BiomeID.deepOcean = 24
     * }
     */
    public static int deepOcean() {
        return deepOcean;
    }
    private static final int stone_shore = (int)25L;
    /**
     * {@snippet lang=c :
     * enum BiomeID.stone_shore = 25
     * }
     */
    public static int stone_shore() {
        return stone_shore;
    }
    private static final int stoneBeach = (int)25L;
    /**
     * {@snippet lang=c :
     * enum BiomeID.stoneBeach = 25
     * }
     */
    public static int stoneBeach() {
        return stoneBeach;
    }
    private static final int snowy_beach = (int)26L;
    /**
     * {@snippet lang=c :
     * enum BiomeID.snowy_beach = 26
     * }
     */
    public static int snowy_beach() {
        return snowy_beach;
    }
    private static final int coldBeach = (int)26L;
    /**
     * {@snippet lang=c :
     * enum BiomeID.coldBeach = 26
     * }
     */
    public static int coldBeach() {
        return coldBeach;
    }
    private static final int birch_forest = (int)27L;
    /**
     * {@snippet lang=c :
     * enum BiomeID.birch_forest = 27
     * }
     */
    public static int birch_forest() {
        return birch_forest;
    }
    private static final int birchForest = (int)27L;
    /**
     * {@snippet lang=c :
     * enum BiomeID.birchForest = 27
     * }
     */
    public static int birchForest() {
        return birchForest;
    }
    private static final int birch_forest_hills = (int)28L;
    /**
     * {@snippet lang=c :
     * enum BiomeID.birch_forest_hills = 28
     * }
     */
    public static int birch_forest_hills() {
        return birch_forest_hills;
    }
    private static final int birchForestHills = (int)28L;
    /**
     * {@snippet lang=c :
     * enum BiomeID.birchForestHills = 28
     * }
     */
    public static int birchForestHills() {
        return birchForestHills;
    }
    private static final int dark_forest = (int)29L;
    /**
     * {@snippet lang=c :
     * enum BiomeID.dark_forest = 29
     * }
     */
    public static int dark_forest() {
        return dark_forest;
    }
    private static final int roofedForest = (int)29L;
    /**
     * {@snippet lang=c :
     * enum BiomeID.roofedForest = 29
     * }
     */
    public static int roofedForest() {
        return roofedForest;
    }
    private static final int snowy_taiga = (int)30L;
    /**
     * {@snippet lang=c :
     * enum BiomeID.snowy_taiga = 30
     * }
     */
    public static int snowy_taiga() {
        return snowy_taiga;
    }
    private static final int coldTaiga = (int)30L;
    /**
     * {@snippet lang=c :
     * enum BiomeID.coldTaiga = 30
     * }
     */
    public static int coldTaiga() {
        return coldTaiga;
    }
    private static final int snowy_taiga_hills = (int)31L;
    /**
     * {@snippet lang=c :
     * enum BiomeID.snowy_taiga_hills = 31
     * }
     */
    public static int snowy_taiga_hills() {
        return snowy_taiga_hills;
    }
    private static final int coldTaigaHills = (int)31L;
    /**
     * {@snippet lang=c :
     * enum BiomeID.coldTaigaHills = 31
     * }
     */
    public static int coldTaigaHills() {
        return coldTaigaHills;
    }
    private static final int giant_tree_taiga = (int)32L;
    /**
     * {@snippet lang=c :
     * enum BiomeID.giant_tree_taiga = 32
     * }
     */
    public static int giant_tree_taiga() {
        return giant_tree_taiga;
    }
    private static final int megaTaiga = (int)32L;
    /**
     * {@snippet lang=c :
     * enum BiomeID.megaTaiga = 32
     * }
     */
    public static int megaTaiga() {
        return megaTaiga;
    }
    private static final int giant_tree_taiga_hills = (int)33L;
    /**
     * {@snippet lang=c :
     * enum BiomeID.giant_tree_taiga_hills = 33
     * }
     */
    public static int giant_tree_taiga_hills() {
        return giant_tree_taiga_hills;
    }
    private static final int megaTaigaHills = (int)33L;
    /**
     * {@snippet lang=c :
     * enum BiomeID.megaTaigaHills = 33
     * }
     */
    public static int megaTaigaHills() {
        return megaTaigaHills;
    }
    private static final int wooded_mountains = (int)34L;
    /**
     * {@snippet lang=c :
     * enum BiomeID.wooded_mountains = 34
     * }
     */
    public static int wooded_mountains() {
        return wooded_mountains;
    }
    private static final int extremeHillsPlus = (int)34L;
    /**
     * {@snippet lang=c :
     * enum BiomeID.extremeHillsPlus = 34
     * }
     */
    public static int extremeHillsPlus() {
        return extremeHillsPlus;
    }
    private static final int savanna = (int)35L;
    /**
     * {@snippet lang=c :
     * enum BiomeID.savanna = 35
     * }
     */
    public static int savanna() {
        return savanna;
    }
    private static final int savanna_plateau = (int)36L;
    /**
     * {@snippet lang=c :
     * enum BiomeID.savanna_plateau = 36
     * }
     */
    public static int savanna_plateau() {
        return savanna_plateau;
    }
    private static final int savannaPlateau = (int)36L;
    /**
     * {@snippet lang=c :
     * enum BiomeID.savannaPlateau = 36
     * }
     */
    public static int savannaPlateau() {
        return savannaPlateau;
    }
    private static final int badlands = (int)37L;
    /**
     * {@snippet lang=c :
     * enum BiomeID.badlands = 37
     * }
     */
    public static int badlands() {
        return badlands;
    }
    private static final int mesa = (int)37L;
    /**
     * {@snippet lang=c :
     * enum BiomeID.mesa = 37
     * }
     */
    public static int mesa() {
        return mesa;
    }
    private static final int wooded_badlands_plateau = (int)38L;
    /**
     * {@snippet lang=c :
     * enum BiomeID.wooded_badlands_plateau = 38
     * }
     */
    public static int wooded_badlands_plateau() {
        return wooded_badlands_plateau;
    }
    private static final int mesaPlateau_F = (int)38L;
    /**
     * {@snippet lang=c :
     * enum BiomeID.mesaPlateau_F = 38
     * }
     */
    public static int mesaPlateau_F() {
        return mesaPlateau_F;
    }
    private static final int badlands_plateau = (int)39L;
    /**
     * {@snippet lang=c :
     * enum BiomeID.badlands_plateau = 39
     * }
     */
    public static int badlands_plateau() {
        return badlands_plateau;
    }
    private static final int mesaPlateau = (int)39L;
    /**
     * {@snippet lang=c :
     * enum BiomeID.mesaPlateau = 39
     * }
     */
    public static int mesaPlateau() {
        return mesaPlateau;
    }
    private static final int small_end_islands = (int)40L;
    /**
     * {@snippet lang=c :
     * enum BiomeID.small_end_islands = 40
     * }
     */
    public static int small_end_islands() {
        return small_end_islands;
    }
    private static final int end_midlands = (int)41L;
    /**
     * {@snippet lang=c :
     * enum BiomeID.end_midlands = 41
     * }
     */
    public static int end_midlands() {
        return end_midlands;
    }
    private static final int end_highlands = (int)42L;
    /**
     * {@snippet lang=c :
     * enum BiomeID.end_highlands = 42
     * }
     */
    public static int end_highlands() {
        return end_highlands;
    }
    private static final int end_barrens = (int)43L;
    /**
     * {@snippet lang=c :
     * enum BiomeID.end_barrens = 43
     * }
     */
    public static int end_barrens() {
        return end_barrens;
    }
    private static final int warm_ocean = (int)44L;
    /**
     * {@snippet lang=c :
     * enum BiomeID.warm_ocean = 44
     * }
     */
    public static int warm_ocean() {
        return warm_ocean;
    }
    private static final int warmOcean = (int)44L;
    /**
     * {@snippet lang=c :
     * enum BiomeID.warmOcean = 44
     * }
     */
    public static int warmOcean() {
        return warmOcean;
    }
    private static final int lukewarm_ocean = (int)45L;
    /**
     * {@snippet lang=c :
     * enum BiomeID.lukewarm_ocean = 45
     * }
     */
    public static int lukewarm_ocean() {
        return lukewarm_ocean;
    }
    private static final int lukewarmOcean = (int)45L;
    /**
     * {@snippet lang=c :
     * enum BiomeID.lukewarmOcean = 45
     * }
     */
    public static int lukewarmOcean() {
        return lukewarmOcean;
    }
    private static final int cold_ocean = (int)46L;
    /**
     * {@snippet lang=c :
     * enum BiomeID.cold_ocean = 46
     * }
     */
    public static int cold_ocean() {
        return cold_ocean;
    }
    private static final int coldOcean = (int)46L;
    /**
     * {@snippet lang=c :
     * enum BiomeID.coldOcean = 46
     * }
     */
    public static int coldOcean() {
        return coldOcean;
    }
    private static final int deep_warm_ocean = (int)47L;
    /**
     * {@snippet lang=c :
     * enum BiomeID.deep_warm_ocean = 47
     * }
     */
    public static int deep_warm_ocean() {
        return deep_warm_ocean;
    }
    private static final int warmDeepOcean = (int)47L;
    /**
     * {@snippet lang=c :
     * enum BiomeID.warmDeepOcean = 47
     * }
     */
    public static int warmDeepOcean() {
        return warmDeepOcean;
    }
    private static final int deep_lukewarm_ocean = (int)48L;
    /**
     * {@snippet lang=c :
     * enum BiomeID.deep_lukewarm_ocean = 48
     * }
     */
    public static int deep_lukewarm_ocean() {
        return deep_lukewarm_ocean;
    }
    private static final int lukewarmDeepOcean = (int)48L;
    /**
     * {@snippet lang=c :
     * enum BiomeID.lukewarmDeepOcean = 48
     * }
     */
    public static int lukewarmDeepOcean() {
        return lukewarmDeepOcean;
    }
    private static final int deep_cold_ocean = (int)49L;
    /**
     * {@snippet lang=c :
     * enum BiomeID.deep_cold_ocean = 49
     * }
     */
    public static int deep_cold_ocean() {
        return deep_cold_ocean;
    }
    private static final int coldDeepOcean = (int)49L;
    /**
     * {@snippet lang=c :
     * enum BiomeID.coldDeepOcean = 49
     * }
     */
    public static int coldDeepOcean() {
        return coldDeepOcean;
    }
    private static final int deep_frozen_ocean = (int)50L;
    /**
     * {@snippet lang=c :
     * enum BiomeID.deep_frozen_ocean = 50
     * }
     */
    public static int deep_frozen_ocean() {
        return deep_frozen_ocean;
    }
    private static final int frozenDeepOcean = (int)50L;
    /**
     * {@snippet lang=c :
     * enum BiomeID.frozenDeepOcean = 50
     * }
     */
    public static int frozenDeepOcean() {
        return frozenDeepOcean;
    }
    private static final int seasonal_forest = (int)51L;
    /**
     * {@snippet lang=c :
     * enum BiomeID.seasonal_forest = 51
     * }
     */
    public static int seasonal_forest() {
        return seasonal_forest;
    }
    private static final int rainforest = (int)52L;
    /**
     * {@snippet lang=c :
     * enum BiomeID.rainforest = 52
     * }
     */
    public static int rainforest() {
        return rainforest;
    }
    private static final int shrubland = (int)53L;
    /**
     * {@snippet lang=c :
     * enum BiomeID.shrubland = 53
     * }
     */
    public static int shrubland() {
        return shrubland;
    }
    private static final int the_void = (int)127L;
    /**
     * {@snippet lang=c :
     * enum BiomeID.the_void = 127
     * }
     */
    public static int the_void() {
        return the_void;
    }
    private static final int sunflower_plains = (int)129L;
    /**
     * {@snippet lang=c :
     * enum BiomeID.sunflower_plains = 129
     * }
     */
    public static int sunflower_plains() {
        return sunflower_plains;
    }
    private static final int desert_lakes = (int)130L;
    /**
     * {@snippet lang=c :
     * enum BiomeID.desert_lakes = 130
     * }
     */
    public static int desert_lakes() {
        return desert_lakes;
    }
    private static final int gravelly_mountains = (int)131L;
    /**
     * {@snippet lang=c :
     * enum BiomeID.gravelly_mountains = 131
     * }
     */
    public static int gravelly_mountains() {
        return gravelly_mountains;
    }
    private static final int flower_forest = (int)132L;
    /**
     * {@snippet lang=c :
     * enum BiomeID.flower_forest = 132
     * }
     */
    public static int flower_forest() {
        return flower_forest;
    }
    private static final int taiga_mountains = (int)133L;
    /**
     * {@snippet lang=c :
     * enum BiomeID.taiga_mountains = 133
     * }
     */
    public static int taiga_mountains() {
        return taiga_mountains;
    }
    private static final int swamp_hills = (int)134L;
    /**
     * {@snippet lang=c :
     * enum BiomeID.swamp_hills = 134
     * }
     */
    public static int swamp_hills() {
        return swamp_hills;
    }
    private static final int ice_spikes = (int)140L;
    /**
     * {@snippet lang=c :
     * enum BiomeID.ice_spikes = 140
     * }
     */
    public static int ice_spikes() {
        return ice_spikes;
    }
    private static final int modified_jungle = (int)149L;
    /**
     * {@snippet lang=c :
     * enum BiomeID.modified_jungle = 149
     * }
     */
    public static int modified_jungle() {
        return modified_jungle;
    }
    private static final int modified_jungle_edge = (int)151L;
    /**
     * {@snippet lang=c :
     * enum BiomeID.modified_jungle_edge = 151
     * }
     */
    public static int modified_jungle_edge() {
        return modified_jungle_edge;
    }
    private static final int tall_birch_forest = (int)155L;
    /**
     * {@snippet lang=c :
     * enum BiomeID.tall_birch_forest = 155
     * }
     */
    public static int tall_birch_forest() {
        return tall_birch_forest;
    }
    private static final int tall_birch_hills = (int)156L;
    /**
     * {@snippet lang=c :
     * enum BiomeID.tall_birch_hills = 156
     * }
     */
    public static int tall_birch_hills() {
        return tall_birch_hills;
    }
    private static final int dark_forest_hills = (int)157L;
    /**
     * {@snippet lang=c :
     * enum BiomeID.dark_forest_hills = 157
     * }
     */
    public static int dark_forest_hills() {
        return dark_forest_hills;
    }
    private static final int snowy_taiga_mountains = (int)158L;
    /**
     * {@snippet lang=c :
     * enum BiomeID.snowy_taiga_mountains = 158
     * }
     */
    public static int snowy_taiga_mountains() {
        return snowy_taiga_mountains;
    }
    private static final int giant_spruce_taiga = (int)160L;
    /**
     * {@snippet lang=c :
     * enum BiomeID.giant_spruce_taiga = 160
     * }
     */
    public static int giant_spruce_taiga() {
        return giant_spruce_taiga;
    }
    private static final int giant_spruce_taiga_hills = (int)161L;
    /**
     * {@snippet lang=c :
     * enum BiomeID.giant_spruce_taiga_hills = 161
     * }
     */
    public static int giant_spruce_taiga_hills() {
        return giant_spruce_taiga_hills;
    }
    private static final int modified_gravelly_mountains = (int)162L;
    /**
     * {@snippet lang=c :
     * enum BiomeID.modified_gravelly_mountains = 162
     * }
     */
    public static int modified_gravelly_mountains() {
        return modified_gravelly_mountains;
    }
    private static final int shattered_savanna = (int)163L;
    /**
     * {@snippet lang=c :
     * enum BiomeID.shattered_savanna = 163
     * }
     */
    public static int shattered_savanna() {
        return shattered_savanna;
    }
    private static final int shattered_savanna_plateau = (int)164L;
    /**
     * {@snippet lang=c :
     * enum BiomeID.shattered_savanna_plateau = 164
     * }
     */
    public static int shattered_savanna_plateau() {
        return shattered_savanna_plateau;
    }
    private static final int eroded_badlands = (int)165L;
    /**
     * {@snippet lang=c :
     * enum BiomeID.eroded_badlands = 165
     * }
     */
    public static int eroded_badlands() {
        return eroded_badlands;
    }
    private static final int modified_wooded_badlands_plateau = (int)166L;
    /**
     * {@snippet lang=c :
     * enum BiomeID.modified_wooded_badlands_plateau = 166
     * }
     */
    public static int modified_wooded_badlands_plateau() {
        return modified_wooded_badlands_plateau;
    }
    private static final int modified_badlands_plateau = (int)167L;
    /**
     * {@snippet lang=c :
     * enum BiomeID.modified_badlands_plateau = 167
     * }
     */
    public static int modified_badlands_plateau() {
        return modified_badlands_plateau;
    }
    private static final int bamboo_jungle = (int)168L;
    /**
     * {@snippet lang=c :
     * enum BiomeID.bamboo_jungle = 168
     * }
     */
    public static int bamboo_jungle() {
        return bamboo_jungle;
    }
    private static final int bamboo_jungle_hills = (int)169L;
    /**
     * {@snippet lang=c :
     * enum BiomeID.bamboo_jungle_hills = 169
     * }
     */
    public static int bamboo_jungle_hills() {
        return bamboo_jungle_hills;
    }
    private static final int soul_sand_valley = (int)170L;
    /**
     * {@snippet lang=c :
     * enum BiomeID.soul_sand_valley = 170
     * }
     */
    public static int soul_sand_valley() {
        return soul_sand_valley;
    }
    private static final int crimson_forest = (int)171L;
    /**
     * {@snippet lang=c :
     * enum BiomeID.crimson_forest = 171
     * }
     */
    public static int crimson_forest() {
        return crimson_forest;
    }
    private static final int warped_forest = (int)172L;
    /**
     * {@snippet lang=c :
     * enum BiomeID.warped_forest = 172
     * }
     */
    public static int warped_forest() {
        return warped_forest;
    }
    private static final int basalt_deltas = (int)173L;
    /**
     * {@snippet lang=c :
     * enum BiomeID.basalt_deltas = 173
     * }
     */
    public static int basalt_deltas() {
        return basalt_deltas;
    }
    private static final int dripstone_caves = (int)174L;
    /**
     * {@snippet lang=c :
     * enum BiomeID.dripstone_caves = 174
     * }
     */
    public static int dripstone_caves() {
        return dripstone_caves;
    }
    private static final int lush_caves = (int)175L;
    /**
     * {@snippet lang=c :
     * enum BiomeID.lush_caves = 175
     * }
     */
    public static int lush_caves() {
        return lush_caves;
    }
    private static final int meadow = (int)177L;
    /**
     * {@snippet lang=c :
     * enum BiomeID.meadow = 177
     * }
     */
    public static int meadow() {
        return meadow;
    }
    private static final int grove = (int)178L;
    /**
     * {@snippet lang=c :
     * enum BiomeID.grove = 178
     * }
     */
    public static int grove() {
        return grove;
    }
    private static final int snowy_slopes = (int)179L;
    /**
     * {@snippet lang=c :
     * enum BiomeID.snowy_slopes = 179
     * }
     */
    public static int snowy_slopes() {
        return snowy_slopes;
    }
    private static final int jagged_peaks = (int)180L;
    /**
     * {@snippet lang=c :
     * enum BiomeID.jagged_peaks = 180
     * }
     */
    public static int jagged_peaks() {
        return jagged_peaks;
    }
    private static final int frozen_peaks = (int)181L;
    /**
     * {@snippet lang=c :
     * enum BiomeID.frozen_peaks = 181
     * }
     */
    public static int frozen_peaks() {
        return frozen_peaks;
    }
    private static final int stony_peaks = (int)182L;
    /**
     * {@snippet lang=c :
     * enum BiomeID.stony_peaks = 182
     * }
     */
    public static int stony_peaks() {
        return stony_peaks;
    }
    private static final int old_growth_birch_forest = (int)155L;
    /**
     * {@snippet lang=c :
     * enum BiomeID.old_growth_birch_forest = 155
     * }
     */
    public static int old_growth_birch_forest() {
        return old_growth_birch_forest;
    }
    private static final int old_growth_pine_taiga = (int)32L;
    /**
     * {@snippet lang=c :
     * enum BiomeID.old_growth_pine_taiga = 32
     * }
     */
    public static int old_growth_pine_taiga() {
        return old_growth_pine_taiga;
    }
    private static final int old_growth_spruce_taiga = (int)160L;
    /**
     * {@snippet lang=c :
     * enum BiomeID.old_growth_spruce_taiga = 160
     * }
     */
    public static int old_growth_spruce_taiga() {
        return old_growth_spruce_taiga;
    }
    private static final int snowy_plains = (int)12L;
    /**
     * {@snippet lang=c :
     * enum BiomeID.snowy_plains = 12
     * }
     */
    public static int snowy_plains() {
        return snowy_plains;
    }
    private static final int sparse_jungle = (int)23L;
    /**
     * {@snippet lang=c :
     * enum BiomeID.sparse_jungle = 23
     * }
     */
    public static int sparse_jungle() {
        return sparse_jungle;
    }
    private static final int stony_shore = (int)25L;
    /**
     * {@snippet lang=c :
     * enum BiomeID.stony_shore = 25
     * }
     */
    public static int stony_shore() {
        return stony_shore;
    }
    private static final int windswept_hills = (int)3L;
    /**
     * {@snippet lang=c :
     * enum BiomeID.windswept_hills = 3
     * }
     */
    public static int windswept_hills() {
        return windswept_hills;
    }
    private static final int windswept_forest = (int)34L;
    /**
     * {@snippet lang=c :
     * enum BiomeID.windswept_forest = 34
     * }
     */
    public static int windswept_forest() {
        return windswept_forest;
    }
    private static final int windswept_gravelly_hills = (int)131L;
    /**
     * {@snippet lang=c :
     * enum BiomeID.windswept_gravelly_hills = 131
     * }
     */
    public static int windswept_gravelly_hills() {
        return windswept_gravelly_hills;
    }
    private static final int windswept_savanna = (int)163L;
    /**
     * {@snippet lang=c :
     * enum BiomeID.windswept_savanna = 163
     * }
     */
    public static int windswept_savanna() {
        return windswept_savanna;
    }
    private static final int wooded_badlands = (int)38L;
    /**
     * {@snippet lang=c :
     * enum BiomeID.wooded_badlands = 38
     * }
     */
    public static int wooded_badlands() {
        return wooded_badlands;
    }
    private static final int deep_dark = (int)183L;
    /**
     * {@snippet lang=c :
     * enum BiomeID.deep_dark = 183
     * }
     */
    public static int deep_dark() {
        return deep_dark;
    }
    private static final int mangrove_swamp = (int)184L;
    /**
     * {@snippet lang=c :
     * enum BiomeID.mangrove_swamp = 184
     * }
     */
    public static int mangrove_swamp() {
        return mangrove_swamp;
    }
    private static final int cherry_grove = (int)185L;
    /**
     * {@snippet lang=c :
     * enum BiomeID.cherry_grove = 185
     * }
     */
    public static int cherry_grove() {
        return cherry_grove;
    }
    private static final int pale_garden = (int)186L;
    /**
     * {@snippet lang=c :
     * enum BiomeID.pale_garden = 186
     * }
     */
    public static int pale_garden() {
        return pale_garden;
    }

    private static class biomeExists {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Cubiomes.C_INT,
            Cubiomes.C_INT,
            Cubiomes.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("biomeExists");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int biomeExists(int mc, int id)
     * }
     */
    public static FunctionDescriptor biomeExists$descriptor() {
        return biomeExists.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int biomeExists(int mc, int id)
     * }
     */
    public static MethodHandle biomeExists$handle() {
        return biomeExists.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int biomeExists(int mc, int id)
     * }
     */
    public static MemorySegment biomeExists$address() {
        return biomeExists.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int biomeExists(int mc, int id)
     * }
     */
    public static int biomeExists(int mc, int id) {
        var mh$ = biomeExists.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("biomeExists", mc, id);
            }
            return (int)mh$.invokeExact(mc, id);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class isOverworld {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Cubiomes.C_INT,
            Cubiomes.C_INT,
            Cubiomes.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("isOverworld");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int isOverworld(int mc, int id)
     * }
     */
    public static FunctionDescriptor isOverworld$descriptor() {
        return isOverworld.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int isOverworld(int mc, int id)
     * }
     */
    public static MethodHandle isOverworld$handle() {
        return isOverworld.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int isOverworld(int mc, int id)
     * }
     */
    public static MemorySegment isOverworld$address() {
        return isOverworld.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int isOverworld(int mc, int id)
     * }
     */
    public static int isOverworld(int mc, int id) {
        var mh$ = isOverworld.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("isOverworld", mc, id);
            }
            return (int)mh$.invokeExact(mc, id);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class getDimension {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Cubiomes.C_INT,
            Cubiomes.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("getDimension");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int getDimension(int id)
     * }
     */
    public static FunctionDescriptor getDimension$descriptor() {
        return getDimension.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int getDimension(int id)
     * }
     */
    public static MethodHandle getDimension$handle() {
        return getDimension.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int getDimension(int id)
     * }
     */
    public static MemorySegment getDimension$address() {
        return getDimension.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int getDimension(int id)
     * }
     */
    public static int getDimension(int id) {
        var mh$ = getDimension.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("getDimension", id);
            }
            return (int)mh$.invokeExact(id);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class getMutated {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Cubiomes.C_INT,
            Cubiomes.C_INT,
            Cubiomes.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("getMutated");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int getMutated(int mc, int id)
     * }
     */
    public static FunctionDescriptor getMutated$descriptor() {
        return getMutated.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int getMutated(int mc, int id)
     * }
     */
    public static MethodHandle getMutated$handle() {
        return getMutated.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int getMutated(int mc, int id)
     * }
     */
    public static MemorySegment getMutated$address() {
        return getMutated.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int getMutated(int mc, int id)
     * }
     */
    public static int getMutated(int mc, int id) {
        var mh$ = getMutated.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("getMutated", mc, id);
            }
            return (int)mh$.invokeExact(mc, id);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class getCategory {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Cubiomes.C_INT,
            Cubiomes.C_INT,
            Cubiomes.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("getCategory");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int getCategory(int mc, int id)
     * }
     */
    public static FunctionDescriptor getCategory$descriptor() {
        return getCategory.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int getCategory(int mc, int id)
     * }
     */
    public static MethodHandle getCategory$handle() {
        return getCategory.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int getCategory(int mc, int id)
     * }
     */
    public static MemorySegment getCategory$address() {
        return getCategory.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int getCategory(int mc, int id)
     * }
     */
    public static int getCategory(int mc, int id) {
        var mh$ = getCategory.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("getCategory", mc, id);
            }
            return (int)mh$.invokeExact(mc, id);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class areSimilar {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Cubiomes.C_INT,
            Cubiomes.C_INT,
            Cubiomes.C_INT,
            Cubiomes.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("areSimilar");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int areSimilar(int mc, int id1, int id2)
     * }
     */
    public static FunctionDescriptor areSimilar$descriptor() {
        return areSimilar.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int areSimilar(int mc, int id1, int id2)
     * }
     */
    public static MethodHandle areSimilar$handle() {
        return areSimilar.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int areSimilar(int mc, int id1, int id2)
     * }
     */
    public static MemorySegment areSimilar$address() {
        return areSimilar.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int areSimilar(int mc, int id1, int id2)
     * }
     */
    public static int areSimilar(int mc, int id1, int id2) {
        var mh$ = areSimilar.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("areSimilar", mc, id1, id2);
            }
            return (int)mh$.invokeExact(mc, id1, id2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class isMesa {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Cubiomes.C_INT,
            Cubiomes.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("isMesa");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int isMesa(int id)
     * }
     */
    public static FunctionDescriptor isMesa$descriptor() {
        return isMesa.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int isMesa(int id)
     * }
     */
    public static MethodHandle isMesa$handle() {
        return isMesa.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int isMesa(int id)
     * }
     */
    public static MemorySegment isMesa$address() {
        return isMesa.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int isMesa(int id)
     * }
     */
    public static int isMesa(int id) {
        var mh$ = isMesa.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("isMesa", id);
            }
            return (int)mh$.invokeExact(id);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class isShallowOcean {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Cubiomes.C_INT,
            Cubiomes.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("isShallowOcean");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int isShallowOcean(int id)
     * }
     */
    public static FunctionDescriptor isShallowOcean$descriptor() {
        return isShallowOcean.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int isShallowOcean(int id)
     * }
     */
    public static MethodHandle isShallowOcean$handle() {
        return isShallowOcean.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int isShallowOcean(int id)
     * }
     */
    public static MemorySegment isShallowOcean$address() {
        return isShallowOcean.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int isShallowOcean(int id)
     * }
     */
    public static int isShallowOcean(int id) {
        var mh$ = isShallowOcean.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("isShallowOcean", id);
            }
            return (int)mh$.invokeExact(id);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class isDeepOcean {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Cubiomes.C_INT,
            Cubiomes.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("isDeepOcean");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int isDeepOcean(int id)
     * }
     */
    public static FunctionDescriptor isDeepOcean$descriptor() {
        return isDeepOcean.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int isDeepOcean(int id)
     * }
     */
    public static MethodHandle isDeepOcean$handle() {
        return isDeepOcean.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int isDeepOcean(int id)
     * }
     */
    public static MemorySegment isDeepOcean$address() {
        return isDeepOcean.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int isDeepOcean(int id)
     * }
     */
    public static int isDeepOcean(int id) {
        var mh$ = isDeepOcean.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("isDeepOcean", id);
            }
            return (int)mh$.invokeExact(id);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class isOceanic {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Cubiomes.C_INT,
            Cubiomes.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("isOceanic");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int isOceanic(int id)
     * }
     */
    public static FunctionDescriptor isOceanic$descriptor() {
        return isOceanic.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int isOceanic(int id)
     * }
     */
    public static MethodHandle isOceanic$handle() {
        return isOceanic.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int isOceanic(int id)
     * }
     */
    public static MemorySegment isOceanic$address() {
        return isOceanic.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int isOceanic(int id)
     * }
     */
    public static int isOceanic(int id) {
        var mh$ = isOceanic.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("isOceanic", id);
            }
            return (int)mh$.invokeExact(id);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class isSnowy {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Cubiomes.C_INT,
            Cubiomes.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("isSnowy");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int isSnowy(int id)
     * }
     */
    public static FunctionDescriptor isSnowy$descriptor() {
        return isSnowy.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int isSnowy(int id)
     * }
     */
    public static MethodHandle isSnowy$handle() {
        return isSnowy.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int isSnowy(int id)
     * }
     */
    public static MemorySegment isSnowy$address() {
        return isSnowy.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int isSnowy(int id)
     * }
     */
    public static int isSnowy(int id) {
        var mh$ = isSnowy.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("isSnowy", id);
            }
            return (int)mh$.invokeExact(id);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    private static final int Oceanic = (int)0L;
    /**
     * {@snippet lang=c :
     * enum BiomeTempCategory.Oceanic = 0
     * }
     */
    public static int Oceanic() {
        return Oceanic;
    }
    private static final int Warm = (int)1L;
    /**
     * {@snippet lang=c :
     * enum BiomeTempCategory.Warm = 1
     * }
     */
    public static int Warm() {
        return Warm;
    }
    private static final int Lush = (int)2L;
    /**
     * {@snippet lang=c :
     * enum BiomeTempCategory.Lush = 2
     * }
     */
    public static int Lush() {
        return Lush;
    }
    private static final int Cold = (int)3L;
    /**
     * {@snippet lang=c :
     * enum BiomeTempCategory.Cold = 3
     * }
     */
    public static int Cold() {
        return Cold;
    }
    private static final int Freezing = (int)4L;
    /**
     * {@snippet lang=c :
     * enum BiomeTempCategory.Freezing = 4
     * }
     */
    public static int Freezing() {
        return Freezing;
    }
    private static final int Special = (int)5L;
    /**
     * {@snippet lang=c :
     * enum BiomeTempCategory.Special = 5
     * }
     */
    public static int Special() {
        return Special;
    }
    private static final int L_CONTINENT_4096 = (int)0L;
    /**
     * {@snippet lang=c :
     * enum LayerId.L_CONTINENT_4096 = 0
     * }
     */
    public static int L_CONTINENT_4096() {
        return L_CONTINENT_4096;
    }
    private static final int L_ISLAND_4096 = (int)0L;
    /**
     * {@snippet lang=c :
     * enum LayerId.L_ISLAND_4096 = 0
     * }
     */
    public static int L_ISLAND_4096() {
        return L_ISLAND_4096;
    }
    private static final int L_ZOOM_4096 = (int)1L;
    /**
     * {@snippet lang=c :
     * enum LayerId.L_ZOOM_4096 = 1
     * }
     */
    public static int L_ZOOM_4096() {
        return L_ZOOM_4096;
    }
    private static final int L_LAND_4096 = (int)2L;
    /**
     * {@snippet lang=c :
     * enum LayerId.L_LAND_4096 = 2
     * }
     */
    public static int L_LAND_4096() {
        return L_LAND_4096;
    }
    private static final int L_ZOOM_2048 = (int)3L;
    /**
     * {@snippet lang=c :
     * enum LayerId.L_ZOOM_2048 = 3
     * }
     */
    public static int L_ZOOM_2048() {
        return L_ZOOM_2048;
    }
    private static final int L_LAND_2048 = (int)4L;
    /**
     * {@snippet lang=c :
     * enum LayerId.L_LAND_2048 = 4
     * }
     */
    public static int L_LAND_2048() {
        return L_LAND_2048;
    }
    private static final int L_ADD_ISLAND_2048 = (int)4L;
    /**
     * {@snippet lang=c :
     * enum LayerId.L_ADD_ISLAND_2048 = 4
     * }
     */
    public static int L_ADD_ISLAND_2048() {
        return L_ADD_ISLAND_2048;
    }
    private static final int L_ZOOM_1024 = (int)5L;
    /**
     * {@snippet lang=c :
     * enum LayerId.L_ZOOM_1024 = 5
     * }
     */
    public static int L_ZOOM_1024() {
        return L_ZOOM_1024;
    }
    private static final int L_LAND_1024_A = (int)6L;
    /**
     * {@snippet lang=c :
     * enum LayerId.L_LAND_1024_A = 6
     * }
     */
    public static int L_LAND_1024_A() {
        return L_LAND_1024_A;
    }
    private static final int L_ADD_ISLAND_1024A = (int)6L;
    /**
     * {@snippet lang=c :
     * enum LayerId.L_ADD_ISLAND_1024A = 6
     * }
     */
    public static int L_ADD_ISLAND_1024A() {
        return L_ADD_ISLAND_1024A;
    }
    private static final int L_LAND_1024_B = (int)7L;
    /**
     * {@snippet lang=c :
     * enum LayerId.L_LAND_1024_B = 7
     * }
     */
    public static int L_LAND_1024_B() {
        return L_LAND_1024_B;
    }
    private static final int L_ADD_ISLAND_1024B = (int)7L;
    /**
     * {@snippet lang=c :
     * enum LayerId.L_ADD_ISLAND_1024B = 7
     * }
     */
    public static int L_ADD_ISLAND_1024B() {
        return L_ADD_ISLAND_1024B;
    }
    private static final int L_LAND_1024_C = (int)8L;
    /**
     * {@snippet lang=c :
     * enum LayerId.L_LAND_1024_C = 8
     * }
     */
    public static int L_LAND_1024_C() {
        return L_LAND_1024_C;
    }
    private static final int L_ADD_ISLAND_1024C = (int)8L;
    /**
     * {@snippet lang=c :
     * enum LayerId.L_ADD_ISLAND_1024C = 8
     * }
     */
    public static int L_ADD_ISLAND_1024C() {
        return L_ADD_ISLAND_1024C;
    }
    private static final int L_ISLAND_1024 = (int)9L;
    /**
     * {@snippet lang=c :
     * enum LayerId.L_ISLAND_1024 = 9
     * }
     */
    public static int L_ISLAND_1024() {
        return L_ISLAND_1024;
    }
    private static final int L_REMOVE_OCEAN_1024 = (int)9L;
    /**
     * {@snippet lang=c :
     * enum LayerId.L_REMOVE_OCEAN_1024 = 9
     * }
     */
    public static int L_REMOVE_OCEAN_1024() {
        return L_REMOVE_OCEAN_1024;
    }
    private static final int L_SNOW_1024 = (int)10L;
    /**
     * {@snippet lang=c :
     * enum LayerId.L_SNOW_1024 = 10
     * }
     */
    public static int L_SNOW_1024() {
        return L_SNOW_1024;
    }
    private static final int L_ADD_SNOW_1024 = (int)10L;
    /**
     * {@snippet lang=c :
     * enum LayerId.L_ADD_SNOW_1024 = 10
     * }
     */
    public static int L_ADD_SNOW_1024() {
        return L_ADD_SNOW_1024;
    }
    private static final int L_LAND_1024_D = (int)11L;
    /**
     * {@snippet lang=c :
     * enum LayerId.L_LAND_1024_D = 11
     * }
     */
    public static int L_LAND_1024_D() {
        return L_LAND_1024_D;
    }
    private static final int L_ADD_ISLAND_1024D = (int)11L;
    /**
     * {@snippet lang=c :
     * enum LayerId.L_ADD_ISLAND_1024D = 11
     * }
     */
    public static int L_ADD_ISLAND_1024D() {
        return L_ADD_ISLAND_1024D;
    }
    private static final int L_COOL_1024 = (int)12L;
    /**
     * {@snippet lang=c :
     * enum LayerId.L_COOL_1024 = 12
     * }
     */
    public static int L_COOL_1024() {
        return L_COOL_1024;
    }
    private static final int L_COOL_WARM_1024 = (int)12L;
    /**
     * {@snippet lang=c :
     * enum LayerId.L_COOL_WARM_1024 = 12
     * }
     */
    public static int L_COOL_WARM_1024() {
        return L_COOL_WARM_1024;
    }
    private static final int L_HEAT_1024 = (int)13L;
    /**
     * {@snippet lang=c :
     * enum LayerId.L_HEAT_1024 = 13
     * }
     */
    public static int L_HEAT_1024() {
        return L_HEAT_1024;
    }
    private static final int L_HEAT_ICE_1024 = (int)13L;
    /**
     * {@snippet lang=c :
     * enum LayerId.L_HEAT_ICE_1024 = 13
     * }
     */
    public static int L_HEAT_ICE_1024() {
        return L_HEAT_ICE_1024;
    }
    private static final int L_SPECIAL_1024 = (int)14L;
    /**
     * {@snippet lang=c :
     * enum LayerId.L_SPECIAL_1024 = 14
     * }
     */
    public static int L_SPECIAL_1024() {
        return L_SPECIAL_1024;
    }
    private static final int L_ZOOM_512 = (int)15L;
    /**
     * {@snippet lang=c :
     * enum LayerId.L_ZOOM_512 = 15
     * }
     */
    public static int L_ZOOM_512() {
        return L_ZOOM_512;
    }
    private static final int L_LAND_512 = (int)16L;
    /**
     * {@snippet lang=c :
     * enum LayerId.L_LAND_512 = 16
     * }
     */
    public static int L_LAND_512() {
        return L_LAND_512;
    }
    private static final int L_ZOOM_256 = (int)17L;
    /**
     * {@snippet lang=c :
     * enum LayerId.L_ZOOM_256 = 17
     * }
     */
    public static int L_ZOOM_256() {
        return L_ZOOM_256;
    }
    private static final int L_LAND_256 = (int)18L;
    /**
     * {@snippet lang=c :
     * enum LayerId.L_LAND_256 = 18
     * }
     */
    public static int L_LAND_256() {
        return L_LAND_256;
    }
    private static final int L_ADD_ISLAND_256 = (int)18L;
    /**
     * {@snippet lang=c :
     * enum LayerId.L_ADD_ISLAND_256 = 18
     * }
     */
    public static int L_ADD_ISLAND_256() {
        return L_ADD_ISLAND_256;
    }
    private static final int L_MUSHROOM_256 = (int)19L;
    /**
     * {@snippet lang=c :
     * enum LayerId.L_MUSHROOM_256 = 19
     * }
     */
    public static int L_MUSHROOM_256() {
        return L_MUSHROOM_256;
    }
    private static final int L_ADD_MUSHROOM_256 = (int)19L;
    /**
     * {@snippet lang=c :
     * enum LayerId.L_ADD_MUSHROOM_256 = 19
     * }
     */
    public static int L_ADD_MUSHROOM_256() {
        return L_ADD_MUSHROOM_256;
    }
    private static final int L_DEEP_OCEAN_256 = (int)20L;
    /**
     * {@snippet lang=c :
     * enum LayerId.L_DEEP_OCEAN_256 = 20
     * }
     */
    public static int L_DEEP_OCEAN_256() {
        return L_DEEP_OCEAN_256;
    }
    private static final int L_BIOME_256 = (int)21L;
    /**
     * {@snippet lang=c :
     * enum LayerId.L_BIOME_256 = 21
     * }
     */
    public static int L_BIOME_256() {
        return L_BIOME_256;
    }
    private static final int L_BAMBOO_256 = (int)22L;
    /**
     * {@snippet lang=c :
     * enum LayerId.L_BAMBOO_256 = 22
     * }
     */
    public static int L_BAMBOO_256() {
        return L_BAMBOO_256;
    }
    private static final int L14_BAMBOO_256 = (int)22L;
    /**
     * {@snippet lang=c :
     * enum LayerId.L14_BAMBOO_256 = 22
     * }
     */
    public static int L14_BAMBOO_256() {
        return L14_BAMBOO_256;
    }
    private static final int L_ZOOM_128 = (int)23L;
    /**
     * {@snippet lang=c :
     * enum LayerId.L_ZOOM_128 = 23
     * }
     */
    public static int L_ZOOM_128() {
        return L_ZOOM_128;
    }
    private static final int L_ZOOM_64 = (int)24L;
    /**
     * {@snippet lang=c :
     * enum LayerId.L_ZOOM_64 = 24
     * }
     */
    public static int L_ZOOM_64() {
        return L_ZOOM_64;
    }
    private static final int L_BIOME_EDGE_64 = (int)25L;
    /**
     * {@snippet lang=c :
     * enum LayerId.L_BIOME_EDGE_64 = 25
     * }
     */
    public static int L_BIOME_EDGE_64() {
        return L_BIOME_EDGE_64;
    }
    private static final int L_NOISE_256 = (int)26L;
    /**
     * {@snippet lang=c :
     * enum LayerId.L_NOISE_256 = 26
     * }
     */
    public static int L_NOISE_256() {
        return L_NOISE_256;
    }
    private static final int L_RIVER_INIT_256 = (int)26L;
    /**
     * {@snippet lang=c :
     * enum LayerId.L_RIVER_INIT_256 = 26
     * }
     */
    public static int L_RIVER_INIT_256() {
        return L_RIVER_INIT_256;
    }
    private static final int L_ZOOM_128_HILLS = (int)27L;
    /**
     * {@snippet lang=c :
     * enum LayerId.L_ZOOM_128_HILLS = 27
     * }
     */
    public static int L_ZOOM_128_HILLS() {
        return L_ZOOM_128_HILLS;
    }
    private static final int L_ZOOM_64_HILLS = (int)28L;
    /**
     * {@snippet lang=c :
     * enum LayerId.L_ZOOM_64_HILLS = 28
     * }
     */
    public static int L_ZOOM_64_HILLS() {
        return L_ZOOM_64_HILLS;
    }
    private static final int L_HILLS_64 = (int)29L;
    /**
     * {@snippet lang=c :
     * enum LayerId.L_HILLS_64 = 29
     * }
     */
    public static int L_HILLS_64() {
        return L_HILLS_64;
    }
    private static final int L_SUNFLOWER_64 = (int)30L;
    /**
     * {@snippet lang=c :
     * enum LayerId.L_SUNFLOWER_64 = 30
     * }
     */
    public static int L_SUNFLOWER_64() {
        return L_SUNFLOWER_64;
    }
    private static final int L_RARE_BIOME_64 = (int)30L;
    /**
     * {@snippet lang=c :
     * enum LayerId.L_RARE_BIOME_64 = 30
     * }
     */
    public static int L_RARE_BIOME_64() {
        return L_RARE_BIOME_64;
    }
    private static final int L_ZOOM_32 = (int)31L;
    /**
     * {@snippet lang=c :
     * enum LayerId.L_ZOOM_32 = 31
     * }
     */
    public static int L_ZOOM_32() {
        return L_ZOOM_32;
    }
    private static final int L_LAND_32 = (int)32L;
    /**
     * {@snippet lang=c :
     * enum LayerId.L_LAND_32 = 32
     * }
     */
    public static int L_LAND_32() {
        return L_LAND_32;
    }
    private static final int L_ADD_ISLAND_32 = (int)32L;
    /**
     * {@snippet lang=c :
     * enum LayerId.L_ADD_ISLAND_32 = 32
     * }
     */
    public static int L_ADD_ISLAND_32() {
        return L_ADD_ISLAND_32;
    }
    private static final int L_ZOOM_16 = (int)33L;
    /**
     * {@snippet lang=c :
     * enum LayerId.L_ZOOM_16 = 33
     * }
     */
    public static int L_ZOOM_16() {
        return L_ZOOM_16;
    }
    private static final int L_SHORE_16 = (int)34L;
    /**
     * {@snippet lang=c :
     * enum LayerId.L_SHORE_16 = 34
     * }
     */
    public static int L_SHORE_16() {
        return L_SHORE_16;
    }
    private static final int L_SWAMP_RIVER_16 = (int)35L;
    /**
     * {@snippet lang=c :
     * enum LayerId.L_SWAMP_RIVER_16 = 35
     * }
     */
    public static int L_SWAMP_RIVER_16() {
        return L_SWAMP_RIVER_16;
    }
    private static final int L_ZOOM_8 = (int)36L;
    /**
     * {@snippet lang=c :
     * enum LayerId.L_ZOOM_8 = 36
     * }
     */
    public static int L_ZOOM_8() {
        return L_ZOOM_8;
    }
    private static final int L_ZOOM_4 = (int)37L;
    /**
     * {@snippet lang=c :
     * enum LayerId.L_ZOOM_4 = 37
     * }
     */
    public static int L_ZOOM_4() {
        return L_ZOOM_4;
    }
    private static final int L_SMOOTH_4 = (int)38L;
    /**
     * {@snippet lang=c :
     * enum LayerId.L_SMOOTH_4 = 38
     * }
     */
    public static int L_SMOOTH_4() {
        return L_SMOOTH_4;
    }
    private static final int L_ZOOM_128_RIVER = (int)39L;
    /**
     * {@snippet lang=c :
     * enum LayerId.L_ZOOM_128_RIVER = 39
     * }
     */
    public static int L_ZOOM_128_RIVER() {
        return L_ZOOM_128_RIVER;
    }
    private static final int L_ZOOM_64_RIVER = (int)40L;
    /**
     * {@snippet lang=c :
     * enum LayerId.L_ZOOM_64_RIVER = 40
     * }
     */
    public static int L_ZOOM_64_RIVER() {
        return L_ZOOM_64_RIVER;
    }
    private static final int L_ZOOM_32_RIVER = (int)41L;
    /**
     * {@snippet lang=c :
     * enum LayerId.L_ZOOM_32_RIVER = 41
     * }
     */
    public static int L_ZOOM_32_RIVER() {
        return L_ZOOM_32_RIVER;
    }
    private static final int L_ZOOM_16_RIVER = (int)42L;
    /**
     * {@snippet lang=c :
     * enum LayerId.L_ZOOM_16_RIVER = 42
     * }
     */
    public static int L_ZOOM_16_RIVER() {
        return L_ZOOM_16_RIVER;
    }
    private static final int L_ZOOM_8_RIVER = (int)43L;
    /**
     * {@snippet lang=c :
     * enum LayerId.L_ZOOM_8_RIVER = 43
     * }
     */
    public static int L_ZOOM_8_RIVER() {
        return L_ZOOM_8_RIVER;
    }
    private static final int L_ZOOM_4_RIVER = (int)44L;
    /**
     * {@snippet lang=c :
     * enum LayerId.L_ZOOM_4_RIVER = 44
     * }
     */
    public static int L_ZOOM_4_RIVER() {
        return L_ZOOM_4_RIVER;
    }
    private static final int L_RIVER_4 = (int)45L;
    /**
     * {@snippet lang=c :
     * enum LayerId.L_RIVER_4 = 45
     * }
     */
    public static int L_RIVER_4() {
        return L_RIVER_4;
    }
    private static final int L_SMOOTH_4_RIVER = (int)46L;
    /**
     * {@snippet lang=c :
     * enum LayerId.L_SMOOTH_4_RIVER = 46
     * }
     */
    public static int L_SMOOTH_4_RIVER() {
        return L_SMOOTH_4_RIVER;
    }
    private static final int L_RIVER_MIX_4 = (int)47L;
    /**
     * {@snippet lang=c :
     * enum LayerId.L_RIVER_MIX_4 = 47
     * }
     */
    public static int L_RIVER_MIX_4() {
        return L_RIVER_MIX_4;
    }
    private static final int L_OCEAN_TEMP_256 = (int)48L;
    /**
     * {@snippet lang=c :
     * enum LayerId.L_OCEAN_TEMP_256 = 48
     * }
     */
    public static int L_OCEAN_TEMP_256() {
        return L_OCEAN_TEMP_256;
    }
    private static final int L13_OCEAN_TEMP_256 = (int)48L;
    /**
     * {@snippet lang=c :
     * enum LayerId.L13_OCEAN_TEMP_256 = 48
     * }
     */
    public static int L13_OCEAN_TEMP_256() {
        return L13_OCEAN_TEMP_256;
    }
    private static final int L_ZOOM_128_OCEAN = (int)49L;
    /**
     * {@snippet lang=c :
     * enum LayerId.L_ZOOM_128_OCEAN = 49
     * }
     */
    public static int L_ZOOM_128_OCEAN() {
        return L_ZOOM_128_OCEAN;
    }
    private static final int L13_ZOOM_128 = (int)49L;
    /**
     * {@snippet lang=c :
     * enum LayerId.L13_ZOOM_128 = 49
     * }
     */
    public static int L13_ZOOM_128() {
        return L13_ZOOM_128;
    }
    private static final int L_ZOOM_64_OCEAN = (int)50L;
    /**
     * {@snippet lang=c :
     * enum LayerId.L_ZOOM_64_OCEAN = 50
     * }
     */
    public static int L_ZOOM_64_OCEAN() {
        return L_ZOOM_64_OCEAN;
    }
    private static final int L13_ZOOM_64 = (int)50L;
    /**
     * {@snippet lang=c :
     * enum LayerId.L13_ZOOM_64 = 50
     * }
     */
    public static int L13_ZOOM_64() {
        return L13_ZOOM_64;
    }
    private static final int L_ZOOM_32_OCEAN = (int)51L;
    /**
     * {@snippet lang=c :
     * enum LayerId.L_ZOOM_32_OCEAN = 51
     * }
     */
    public static int L_ZOOM_32_OCEAN() {
        return L_ZOOM_32_OCEAN;
    }
    private static final int L13_ZOOM_32 = (int)51L;
    /**
     * {@snippet lang=c :
     * enum LayerId.L13_ZOOM_32 = 51
     * }
     */
    public static int L13_ZOOM_32() {
        return L13_ZOOM_32;
    }
    private static final int L_ZOOM_16_OCEAN = (int)52L;
    /**
     * {@snippet lang=c :
     * enum LayerId.L_ZOOM_16_OCEAN = 52
     * }
     */
    public static int L_ZOOM_16_OCEAN() {
        return L_ZOOM_16_OCEAN;
    }
    private static final int L13_ZOOM_16 = (int)52L;
    /**
     * {@snippet lang=c :
     * enum LayerId.L13_ZOOM_16 = 52
     * }
     */
    public static int L13_ZOOM_16() {
        return L13_ZOOM_16;
    }
    private static final int L_ZOOM_8_OCEAN = (int)53L;
    /**
     * {@snippet lang=c :
     * enum LayerId.L_ZOOM_8_OCEAN = 53
     * }
     */
    public static int L_ZOOM_8_OCEAN() {
        return L_ZOOM_8_OCEAN;
    }
    private static final int L13_ZOOM_8 = (int)53L;
    /**
     * {@snippet lang=c :
     * enum LayerId.L13_ZOOM_8 = 53
     * }
     */
    public static int L13_ZOOM_8() {
        return L13_ZOOM_8;
    }
    private static final int L_ZOOM_4_OCEAN = (int)54L;
    /**
     * {@snippet lang=c :
     * enum LayerId.L_ZOOM_4_OCEAN = 54
     * }
     */
    public static int L_ZOOM_4_OCEAN() {
        return L_ZOOM_4_OCEAN;
    }
    private static final int L13_ZOOM_4 = (int)54L;
    /**
     * {@snippet lang=c :
     * enum LayerId.L13_ZOOM_4 = 54
     * }
     */
    public static int L13_ZOOM_4() {
        return L13_ZOOM_4;
    }
    private static final int L_OCEAN_MIX_4 = (int)55L;
    /**
     * {@snippet lang=c :
     * enum LayerId.L_OCEAN_MIX_4 = 55
     * }
     */
    public static int L_OCEAN_MIX_4() {
        return L_OCEAN_MIX_4;
    }
    private static final int L13_OCEAN_MIX_4 = (int)55L;
    /**
     * {@snippet lang=c :
     * enum LayerId.L13_OCEAN_MIX_4 = 55
     * }
     */
    public static int L13_OCEAN_MIX_4() {
        return L13_OCEAN_MIX_4;
    }
    private static final int L_VORONOI_1 = (int)56L;
    /**
     * {@snippet lang=c :
     * enum LayerId.L_VORONOI_1 = 56
     * }
     */
    public static int L_VORONOI_1() {
        return L_VORONOI_1;
    }
    private static final int L_VORONOI_ZOOM_1 = (int)56L;
    /**
     * {@snippet lang=c :
     * enum LayerId.L_VORONOI_ZOOM_1 = 56
     * }
     */
    public static int L_VORONOI_ZOOM_1() {
        return L_VORONOI_ZOOM_1;
    }
    private static final int L_ZOOM_LARGE_A = (int)57L;
    /**
     * {@snippet lang=c :
     * enum LayerId.L_ZOOM_LARGE_A = 57
     * }
     */
    public static int L_ZOOM_LARGE_A() {
        return L_ZOOM_LARGE_A;
    }
    private static final int L_ZOOM_LARGE_B = (int)58L;
    /**
     * {@snippet lang=c :
     * enum LayerId.L_ZOOM_LARGE_B = 58
     * }
     */
    public static int L_ZOOM_LARGE_B() {
        return L_ZOOM_LARGE_B;
    }
    private static final int L_ZOOM_L_RIVER_A = (int)59L;
    /**
     * {@snippet lang=c :
     * enum LayerId.L_ZOOM_L_RIVER_A = 59
     * }
     */
    public static int L_ZOOM_L_RIVER_A() {
        return L_ZOOM_L_RIVER_A;
    }
    private static final int L_ZOOM_L_RIVER_B = (int)60L;
    /**
     * {@snippet lang=c :
     * enum LayerId.L_ZOOM_L_RIVER_B = 60
     * }
     */
    public static int L_ZOOM_L_RIVER_B() {
        return L_ZOOM_L_RIVER_B;
    }
    private static final int L_NUM = (int)61L;
    /**
     * {@snippet lang=c :
     * enum LayerId.L_NUM = 61
     * }
     */
    public static int L_NUM() {
        return L_NUM;
    }

    private static class setLayerSeed {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            Cubiomes.C_POINTER,
            Cubiomes.C_LONG
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("setLayerSeed");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void setLayerSeed(Layer *layer, uint64_t worldSeed)
     * }
     */
    public static FunctionDescriptor setLayerSeed$descriptor() {
        return setLayerSeed.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void setLayerSeed(Layer *layer, uint64_t worldSeed)
     * }
     */
    public static MethodHandle setLayerSeed$handle() {
        return setLayerSeed.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void setLayerSeed(Layer *layer, uint64_t worldSeed)
     * }
     */
    public static MemorySegment setLayerSeed$address() {
        return setLayerSeed.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void setLayerSeed(Layer *layer, uint64_t worldSeed)
     * }
     */
    public static void setLayerSeed(MemorySegment layer, long worldSeed) {
        var mh$ = setLayerSeed.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("setLayerSeed", layer, worldSeed);
            }
            mh$.invokeExact(layer, worldSeed);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class mapContinent {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Cubiomes.C_INT,
            Cubiomes.C_POINTER,
            Cubiomes.C_POINTER,
            Cubiomes.C_INT,
            Cubiomes.C_INT,
            Cubiomes.C_INT,
            Cubiomes.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("mapContinent");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int mapContinent(const struct Layer *, int *, int, int, int, int)
     * }
     */
    public static FunctionDescriptor mapContinent$descriptor() {
        return mapContinent.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int mapContinent(const struct Layer *, int *, int, int, int, int)
     * }
     */
    public static MethodHandle mapContinent$handle() {
        return mapContinent.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int mapContinent(const struct Layer *, int *, int, int, int, int)
     * }
     */
    public static MemorySegment mapContinent$address() {
        return mapContinent.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int mapContinent(const struct Layer *, int *, int, int, int, int)
     * }
     */
    public static int mapContinent(MemorySegment x0, MemorySegment x1, int x2, int x3, int x4, int x5) {
        var mh$ = mapContinent.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("mapContinent", x0, x1, x2, x3, x4, x5);
            }
            return (int)mh$.invokeExact(x0, x1, x2, x3, x4, x5);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class mapZoomFuzzy {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Cubiomes.C_INT,
            Cubiomes.C_POINTER,
            Cubiomes.C_POINTER,
            Cubiomes.C_INT,
            Cubiomes.C_INT,
            Cubiomes.C_INT,
            Cubiomes.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("mapZoomFuzzy");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int mapZoomFuzzy(const struct Layer *, int *, int, int, int, int)
     * }
     */
    public static FunctionDescriptor mapZoomFuzzy$descriptor() {
        return mapZoomFuzzy.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int mapZoomFuzzy(const struct Layer *, int *, int, int, int, int)
     * }
     */
    public static MethodHandle mapZoomFuzzy$handle() {
        return mapZoomFuzzy.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int mapZoomFuzzy(const struct Layer *, int *, int, int, int, int)
     * }
     */
    public static MemorySegment mapZoomFuzzy$address() {
        return mapZoomFuzzy.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int mapZoomFuzzy(const struct Layer *, int *, int, int, int, int)
     * }
     */
    public static int mapZoomFuzzy(MemorySegment x0, MemorySegment x1, int x2, int x3, int x4, int x5) {
        var mh$ = mapZoomFuzzy.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("mapZoomFuzzy", x0, x1, x2, x3, x4, x5);
            }
            return (int)mh$.invokeExact(x0, x1, x2, x3, x4, x5);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class mapZoom {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Cubiomes.C_INT,
            Cubiomes.C_POINTER,
            Cubiomes.C_POINTER,
            Cubiomes.C_INT,
            Cubiomes.C_INT,
            Cubiomes.C_INT,
            Cubiomes.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("mapZoom");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int mapZoom(const struct Layer *, int *, int, int, int, int)
     * }
     */
    public static FunctionDescriptor mapZoom$descriptor() {
        return mapZoom.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int mapZoom(const struct Layer *, int *, int, int, int, int)
     * }
     */
    public static MethodHandle mapZoom$handle() {
        return mapZoom.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int mapZoom(const struct Layer *, int *, int, int, int, int)
     * }
     */
    public static MemorySegment mapZoom$address() {
        return mapZoom.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int mapZoom(const struct Layer *, int *, int, int, int, int)
     * }
     */
    public static int mapZoom(MemorySegment x0, MemorySegment x1, int x2, int x3, int x4, int x5) {
        var mh$ = mapZoom.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("mapZoom", x0, x1, x2, x3, x4, x5);
            }
            return (int)mh$.invokeExact(x0, x1, x2, x3, x4, x5);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class mapLand {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Cubiomes.C_INT,
            Cubiomes.C_POINTER,
            Cubiomes.C_POINTER,
            Cubiomes.C_INT,
            Cubiomes.C_INT,
            Cubiomes.C_INT,
            Cubiomes.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("mapLand");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int mapLand(const struct Layer *, int *, int, int, int, int)
     * }
     */
    public static FunctionDescriptor mapLand$descriptor() {
        return mapLand.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int mapLand(const struct Layer *, int *, int, int, int, int)
     * }
     */
    public static MethodHandle mapLand$handle() {
        return mapLand.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int mapLand(const struct Layer *, int *, int, int, int, int)
     * }
     */
    public static MemorySegment mapLand$address() {
        return mapLand.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int mapLand(const struct Layer *, int *, int, int, int, int)
     * }
     */
    public static int mapLand(MemorySegment x0, MemorySegment x1, int x2, int x3, int x4, int x5) {
        var mh$ = mapLand.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("mapLand", x0, x1, x2, x3, x4, x5);
            }
            return (int)mh$.invokeExact(x0, x1, x2, x3, x4, x5);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class mapLand16 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Cubiomes.C_INT,
            Cubiomes.C_POINTER,
            Cubiomes.C_POINTER,
            Cubiomes.C_INT,
            Cubiomes.C_INT,
            Cubiomes.C_INT,
            Cubiomes.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("mapLand16");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int mapLand16(const struct Layer *, int *, int, int, int, int)
     * }
     */
    public static FunctionDescriptor mapLand16$descriptor() {
        return mapLand16.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int mapLand16(const struct Layer *, int *, int, int, int, int)
     * }
     */
    public static MethodHandle mapLand16$handle() {
        return mapLand16.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int mapLand16(const struct Layer *, int *, int, int, int, int)
     * }
     */
    public static MemorySegment mapLand16$address() {
        return mapLand16.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int mapLand16(const struct Layer *, int *, int, int, int, int)
     * }
     */
    public static int mapLand16(MemorySegment x0, MemorySegment x1, int x2, int x3, int x4, int x5) {
        var mh$ = mapLand16.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("mapLand16", x0, x1, x2, x3, x4, x5);
            }
            return (int)mh$.invokeExact(x0, x1, x2, x3, x4, x5);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class mapLandB18 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Cubiomes.C_INT,
            Cubiomes.C_POINTER,
            Cubiomes.C_POINTER,
            Cubiomes.C_INT,
            Cubiomes.C_INT,
            Cubiomes.C_INT,
            Cubiomes.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("mapLandB18");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int mapLandB18(const struct Layer *, int *, int, int, int, int)
     * }
     */
    public static FunctionDescriptor mapLandB18$descriptor() {
        return mapLandB18.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int mapLandB18(const struct Layer *, int *, int, int, int, int)
     * }
     */
    public static MethodHandle mapLandB18$handle() {
        return mapLandB18.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int mapLandB18(const struct Layer *, int *, int, int, int, int)
     * }
     */
    public static MemorySegment mapLandB18$address() {
        return mapLandB18.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int mapLandB18(const struct Layer *, int *, int, int, int, int)
     * }
     */
    public static int mapLandB18(MemorySegment x0, MemorySegment x1, int x2, int x3, int x4, int x5) {
        var mh$ = mapLandB18.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("mapLandB18", x0, x1, x2, x3, x4, x5);
            }
            return (int)mh$.invokeExact(x0, x1, x2, x3, x4, x5);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class mapIsland {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Cubiomes.C_INT,
            Cubiomes.C_POINTER,
            Cubiomes.C_POINTER,
            Cubiomes.C_INT,
            Cubiomes.C_INT,
            Cubiomes.C_INT,
            Cubiomes.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("mapIsland");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int mapIsland(const struct Layer *, int *, int, int, int, int)
     * }
     */
    public static FunctionDescriptor mapIsland$descriptor() {
        return mapIsland.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int mapIsland(const struct Layer *, int *, int, int, int, int)
     * }
     */
    public static MethodHandle mapIsland$handle() {
        return mapIsland.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int mapIsland(const struct Layer *, int *, int, int, int, int)
     * }
     */
    public static MemorySegment mapIsland$address() {
        return mapIsland.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int mapIsland(const struct Layer *, int *, int, int, int, int)
     * }
     */
    public static int mapIsland(MemorySegment x0, MemorySegment x1, int x2, int x3, int x4, int x5) {
        var mh$ = mapIsland.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("mapIsland", x0, x1, x2, x3, x4, x5);
            }
            return (int)mh$.invokeExact(x0, x1, x2, x3, x4, x5);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class mapSnow {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Cubiomes.C_INT,
            Cubiomes.C_POINTER,
            Cubiomes.C_POINTER,
            Cubiomes.C_INT,
            Cubiomes.C_INT,
            Cubiomes.C_INT,
            Cubiomes.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("mapSnow");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int mapSnow(const struct Layer *, int *, int, int, int, int)
     * }
     */
    public static FunctionDescriptor mapSnow$descriptor() {
        return mapSnow.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int mapSnow(const struct Layer *, int *, int, int, int, int)
     * }
     */
    public static MethodHandle mapSnow$handle() {
        return mapSnow.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int mapSnow(const struct Layer *, int *, int, int, int, int)
     * }
     */
    public static MemorySegment mapSnow$address() {
        return mapSnow.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int mapSnow(const struct Layer *, int *, int, int, int, int)
     * }
     */
    public static int mapSnow(MemorySegment x0, MemorySegment x1, int x2, int x3, int x4, int x5) {
        var mh$ = mapSnow.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("mapSnow", x0, x1, x2, x3, x4, x5);
            }
            return (int)mh$.invokeExact(x0, x1, x2, x3, x4, x5);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class mapSnow16 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Cubiomes.C_INT,
            Cubiomes.C_POINTER,
            Cubiomes.C_POINTER,
            Cubiomes.C_INT,
            Cubiomes.C_INT,
            Cubiomes.C_INT,
            Cubiomes.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("mapSnow16");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int mapSnow16(const struct Layer *, int *, int, int, int, int)
     * }
     */
    public static FunctionDescriptor mapSnow16$descriptor() {
        return mapSnow16.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int mapSnow16(const struct Layer *, int *, int, int, int, int)
     * }
     */
    public static MethodHandle mapSnow16$handle() {
        return mapSnow16.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int mapSnow16(const struct Layer *, int *, int, int, int, int)
     * }
     */
    public static MemorySegment mapSnow16$address() {
        return mapSnow16.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int mapSnow16(const struct Layer *, int *, int, int, int, int)
     * }
     */
    public static int mapSnow16(MemorySegment x0, MemorySegment x1, int x2, int x3, int x4, int x5) {
        var mh$ = mapSnow16.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("mapSnow16", x0, x1, x2, x3, x4, x5);
            }
            return (int)mh$.invokeExact(x0, x1, x2, x3, x4, x5);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class mapCool {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Cubiomes.C_INT,
            Cubiomes.C_POINTER,
            Cubiomes.C_POINTER,
            Cubiomes.C_INT,
            Cubiomes.C_INT,
            Cubiomes.C_INT,
            Cubiomes.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("mapCool");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int mapCool(const struct Layer *, int *, int, int, int, int)
     * }
     */
    public static FunctionDescriptor mapCool$descriptor() {
        return mapCool.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int mapCool(const struct Layer *, int *, int, int, int, int)
     * }
     */
    public static MethodHandle mapCool$handle() {
        return mapCool.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int mapCool(const struct Layer *, int *, int, int, int, int)
     * }
     */
    public static MemorySegment mapCool$address() {
        return mapCool.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int mapCool(const struct Layer *, int *, int, int, int, int)
     * }
     */
    public static int mapCool(MemorySegment x0, MemorySegment x1, int x2, int x3, int x4, int x5) {
        var mh$ = mapCool.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("mapCool", x0, x1, x2, x3, x4, x5);
            }
            return (int)mh$.invokeExact(x0, x1, x2, x3, x4, x5);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class mapHeat {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Cubiomes.C_INT,
            Cubiomes.C_POINTER,
            Cubiomes.C_POINTER,
            Cubiomes.C_INT,
            Cubiomes.C_INT,
            Cubiomes.C_INT,
            Cubiomes.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("mapHeat");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int mapHeat(const struct Layer *, int *, int, int, int, int)
     * }
     */
    public static FunctionDescriptor mapHeat$descriptor() {
        return mapHeat.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int mapHeat(const struct Layer *, int *, int, int, int, int)
     * }
     */
    public static MethodHandle mapHeat$handle() {
        return mapHeat.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int mapHeat(const struct Layer *, int *, int, int, int, int)
     * }
     */
    public static MemorySegment mapHeat$address() {
        return mapHeat.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int mapHeat(const struct Layer *, int *, int, int, int, int)
     * }
     */
    public static int mapHeat(MemorySegment x0, MemorySegment x1, int x2, int x3, int x4, int x5) {
        var mh$ = mapHeat.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("mapHeat", x0, x1, x2, x3, x4, x5);
            }
            return (int)mh$.invokeExact(x0, x1, x2, x3, x4, x5);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class mapSpecial {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Cubiomes.C_INT,
            Cubiomes.C_POINTER,
            Cubiomes.C_POINTER,
            Cubiomes.C_INT,
            Cubiomes.C_INT,
            Cubiomes.C_INT,
            Cubiomes.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("mapSpecial");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int mapSpecial(const struct Layer *, int *, int, int, int, int)
     * }
     */
    public static FunctionDescriptor mapSpecial$descriptor() {
        return mapSpecial.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int mapSpecial(const struct Layer *, int *, int, int, int, int)
     * }
     */
    public static MethodHandle mapSpecial$handle() {
        return mapSpecial.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int mapSpecial(const struct Layer *, int *, int, int, int, int)
     * }
     */
    public static MemorySegment mapSpecial$address() {
        return mapSpecial.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int mapSpecial(const struct Layer *, int *, int, int, int, int)
     * }
     */
    public static int mapSpecial(MemorySegment x0, MemorySegment x1, int x2, int x3, int x4, int x5) {
        var mh$ = mapSpecial.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("mapSpecial", x0, x1, x2, x3, x4, x5);
            }
            return (int)mh$.invokeExact(x0, x1, x2, x3, x4, x5);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class mapMushroom {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Cubiomes.C_INT,
            Cubiomes.C_POINTER,
            Cubiomes.C_POINTER,
            Cubiomes.C_INT,
            Cubiomes.C_INT,
            Cubiomes.C_INT,
            Cubiomes.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("mapMushroom");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int mapMushroom(const struct Layer *, int *, int, int, int, int)
     * }
     */
    public static FunctionDescriptor mapMushroom$descriptor() {
        return mapMushroom.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int mapMushroom(const struct Layer *, int *, int, int, int, int)
     * }
     */
    public static MethodHandle mapMushroom$handle() {
        return mapMushroom.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int mapMushroom(const struct Layer *, int *, int, int, int, int)
     * }
     */
    public static MemorySegment mapMushroom$address() {
        return mapMushroom.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int mapMushroom(const struct Layer *, int *, int, int, int, int)
     * }
     */
    public static int mapMushroom(MemorySegment x0, MemorySegment x1, int x2, int x3, int x4, int x5) {
        var mh$ = mapMushroom.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("mapMushroom", x0, x1, x2, x3, x4, x5);
            }
            return (int)mh$.invokeExact(x0, x1, x2, x3, x4, x5);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class mapDeepOcean {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Cubiomes.C_INT,
            Cubiomes.C_POINTER,
            Cubiomes.C_POINTER,
            Cubiomes.C_INT,
            Cubiomes.C_INT,
            Cubiomes.C_INT,
            Cubiomes.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("mapDeepOcean");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int mapDeepOcean(const struct Layer *, int *, int, int, int, int)
     * }
     */
    public static FunctionDescriptor mapDeepOcean$descriptor() {
        return mapDeepOcean.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int mapDeepOcean(const struct Layer *, int *, int, int, int, int)
     * }
     */
    public static MethodHandle mapDeepOcean$handle() {
        return mapDeepOcean.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int mapDeepOcean(const struct Layer *, int *, int, int, int, int)
     * }
     */
    public static MemorySegment mapDeepOcean$address() {
        return mapDeepOcean.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int mapDeepOcean(const struct Layer *, int *, int, int, int, int)
     * }
     */
    public static int mapDeepOcean(MemorySegment x0, MemorySegment x1, int x2, int x3, int x4, int x5) {
        var mh$ = mapDeepOcean.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("mapDeepOcean", x0, x1, x2, x3, x4, x5);
            }
            return (int)mh$.invokeExact(x0, x1, x2, x3, x4, x5);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class mapBiome {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Cubiomes.C_INT,
            Cubiomes.C_POINTER,
            Cubiomes.C_POINTER,
            Cubiomes.C_INT,
            Cubiomes.C_INT,
            Cubiomes.C_INT,
            Cubiomes.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("mapBiome");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int mapBiome(const struct Layer *, int *, int, int, int, int)
     * }
     */
    public static FunctionDescriptor mapBiome$descriptor() {
        return mapBiome.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int mapBiome(const struct Layer *, int *, int, int, int, int)
     * }
     */
    public static MethodHandle mapBiome$handle() {
        return mapBiome.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int mapBiome(const struct Layer *, int *, int, int, int, int)
     * }
     */
    public static MemorySegment mapBiome$address() {
        return mapBiome.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int mapBiome(const struct Layer *, int *, int, int, int, int)
     * }
     */
    public static int mapBiome(MemorySegment x0, MemorySegment x1, int x2, int x3, int x4, int x5) {
        var mh$ = mapBiome.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("mapBiome", x0, x1, x2, x3, x4, x5);
            }
            return (int)mh$.invokeExact(x0, x1, x2, x3, x4, x5);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class mapBamboo {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Cubiomes.C_INT,
            Cubiomes.C_POINTER,
            Cubiomes.C_POINTER,
            Cubiomes.C_INT,
            Cubiomes.C_INT,
            Cubiomes.C_INT,
            Cubiomes.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("mapBamboo");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int mapBamboo(const struct Layer *, int *, int, int, int, int)
     * }
     */
    public static FunctionDescriptor mapBamboo$descriptor() {
        return mapBamboo.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int mapBamboo(const struct Layer *, int *, int, int, int, int)
     * }
     */
    public static MethodHandle mapBamboo$handle() {
        return mapBamboo.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int mapBamboo(const struct Layer *, int *, int, int, int, int)
     * }
     */
    public static MemorySegment mapBamboo$address() {
        return mapBamboo.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int mapBamboo(const struct Layer *, int *, int, int, int, int)
     * }
     */
    public static int mapBamboo(MemorySegment x0, MemorySegment x1, int x2, int x3, int x4, int x5) {
        var mh$ = mapBamboo.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("mapBamboo", x0, x1, x2, x3, x4, x5);
            }
            return (int)mh$.invokeExact(x0, x1, x2, x3, x4, x5);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class mapNoise {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Cubiomes.C_INT,
            Cubiomes.C_POINTER,
            Cubiomes.C_POINTER,
            Cubiomes.C_INT,
            Cubiomes.C_INT,
            Cubiomes.C_INT,
            Cubiomes.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("mapNoise");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int mapNoise(const struct Layer *, int *, int, int, int, int)
     * }
     */
    public static FunctionDescriptor mapNoise$descriptor() {
        return mapNoise.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int mapNoise(const struct Layer *, int *, int, int, int, int)
     * }
     */
    public static MethodHandle mapNoise$handle() {
        return mapNoise.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int mapNoise(const struct Layer *, int *, int, int, int, int)
     * }
     */
    public static MemorySegment mapNoise$address() {
        return mapNoise.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int mapNoise(const struct Layer *, int *, int, int, int, int)
     * }
     */
    public static int mapNoise(MemorySegment x0, MemorySegment x1, int x2, int x3, int x4, int x5) {
        var mh$ = mapNoise.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("mapNoise", x0, x1, x2, x3, x4, x5);
            }
            return (int)mh$.invokeExact(x0, x1, x2, x3, x4, x5);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class mapBiomeEdge {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Cubiomes.C_INT,
            Cubiomes.C_POINTER,
            Cubiomes.C_POINTER,
            Cubiomes.C_INT,
            Cubiomes.C_INT,
            Cubiomes.C_INT,
            Cubiomes.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("mapBiomeEdge");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int mapBiomeEdge(const struct Layer *, int *, int, int, int, int)
     * }
     */
    public static FunctionDescriptor mapBiomeEdge$descriptor() {
        return mapBiomeEdge.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int mapBiomeEdge(const struct Layer *, int *, int, int, int, int)
     * }
     */
    public static MethodHandle mapBiomeEdge$handle() {
        return mapBiomeEdge.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int mapBiomeEdge(const struct Layer *, int *, int, int, int, int)
     * }
     */
    public static MemorySegment mapBiomeEdge$address() {
        return mapBiomeEdge.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int mapBiomeEdge(const struct Layer *, int *, int, int, int, int)
     * }
     */
    public static int mapBiomeEdge(MemorySegment x0, MemorySegment x1, int x2, int x3, int x4, int x5) {
        var mh$ = mapBiomeEdge.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("mapBiomeEdge", x0, x1, x2, x3, x4, x5);
            }
            return (int)mh$.invokeExact(x0, x1, x2, x3, x4, x5);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class mapHills {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Cubiomes.C_INT,
            Cubiomes.C_POINTER,
            Cubiomes.C_POINTER,
            Cubiomes.C_INT,
            Cubiomes.C_INT,
            Cubiomes.C_INT,
            Cubiomes.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("mapHills");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int mapHills(const struct Layer *, int *, int, int, int, int)
     * }
     */
    public static FunctionDescriptor mapHills$descriptor() {
        return mapHills.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int mapHills(const struct Layer *, int *, int, int, int, int)
     * }
     */
    public static MethodHandle mapHills$handle() {
        return mapHills.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int mapHills(const struct Layer *, int *, int, int, int, int)
     * }
     */
    public static MemorySegment mapHills$address() {
        return mapHills.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int mapHills(const struct Layer *, int *, int, int, int, int)
     * }
     */
    public static int mapHills(MemorySegment x0, MemorySegment x1, int x2, int x3, int x4, int x5) {
        var mh$ = mapHills.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("mapHills", x0, x1, x2, x3, x4, x5);
            }
            return (int)mh$.invokeExact(x0, x1, x2, x3, x4, x5);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class mapRiver {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Cubiomes.C_INT,
            Cubiomes.C_POINTER,
            Cubiomes.C_POINTER,
            Cubiomes.C_INT,
            Cubiomes.C_INT,
            Cubiomes.C_INT,
            Cubiomes.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("mapRiver");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int mapRiver(const struct Layer *, int *, int, int, int, int)
     * }
     */
    public static FunctionDescriptor mapRiver$descriptor() {
        return mapRiver.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int mapRiver(const struct Layer *, int *, int, int, int, int)
     * }
     */
    public static MethodHandle mapRiver$handle() {
        return mapRiver.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int mapRiver(const struct Layer *, int *, int, int, int, int)
     * }
     */
    public static MemorySegment mapRiver$address() {
        return mapRiver.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int mapRiver(const struct Layer *, int *, int, int, int, int)
     * }
     */
    public static int mapRiver(MemorySegment x0, MemorySegment x1, int x2, int x3, int x4, int x5) {
        var mh$ = mapRiver.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("mapRiver", x0, x1, x2, x3, x4, x5);
            }
            return (int)mh$.invokeExact(x0, x1, x2, x3, x4, x5);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class mapSmooth {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Cubiomes.C_INT,
            Cubiomes.C_POINTER,
            Cubiomes.C_POINTER,
            Cubiomes.C_INT,
            Cubiomes.C_INT,
            Cubiomes.C_INT,
            Cubiomes.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("mapSmooth");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int mapSmooth(const struct Layer *, int *, int, int, int, int)
     * }
     */
    public static FunctionDescriptor mapSmooth$descriptor() {
        return mapSmooth.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int mapSmooth(const struct Layer *, int *, int, int, int, int)
     * }
     */
    public static MethodHandle mapSmooth$handle() {
        return mapSmooth.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int mapSmooth(const struct Layer *, int *, int, int, int, int)
     * }
     */
    public static MemorySegment mapSmooth$address() {
        return mapSmooth.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int mapSmooth(const struct Layer *, int *, int, int, int, int)
     * }
     */
    public static int mapSmooth(MemorySegment x0, MemorySegment x1, int x2, int x3, int x4, int x5) {
        var mh$ = mapSmooth.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("mapSmooth", x0, x1, x2, x3, x4, x5);
            }
            return (int)mh$.invokeExact(x0, x1, x2, x3, x4, x5);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class mapSunflower {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Cubiomes.C_INT,
            Cubiomes.C_POINTER,
            Cubiomes.C_POINTER,
            Cubiomes.C_INT,
            Cubiomes.C_INT,
            Cubiomes.C_INT,
            Cubiomes.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("mapSunflower");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int mapSunflower(const struct Layer *, int *, int, int, int, int)
     * }
     */
    public static FunctionDescriptor mapSunflower$descriptor() {
        return mapSunflower.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int mapSunflower(const struct Layer *, int *, int, int, int, int)
     * }
     */
    public static MethodHandle mapSunflower$handle() {
        return mapSunflower.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int mapSunflower(const struct Layer *, int *, int, int, int, int)
     * }
     */
    public static MemorySegment mapSunflower$address() {
        return mapSunflower.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int mapSunflower(const struct Layer *, int *, int, int, int, int)
     * }
     */
    public static int mapSunflower(MemorySegment x0, MemorySegment x1, int x2, int x3, int x4, int x5) {
        var mh$ = mapSunflower.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("mapSunflower", x0, x1, x2, x3, x4, x5);
            }
            return (int)mh$.invokeExact(x0, x1, x2, x3, x4, x5);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class mapShore {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Cubiomes.C_INT,
            Cubiomes.C_POINTER,
            Cubiomes.C_POINTER,
            Cubiomes.C_INT,
            Cubiomes.C_INT,
            Cubiomes.C_INT,
            Cubiomes.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("mapShore");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int mapShore(const struct Layer *, int *, int, int, int, int)
     * }
     */
    public static FunctionDescriptor mapShore$descriptor() {
        return mapShore.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int mapShore(const struct Layer *, int *, int, int, int, int)
     * }
     */
    public static MethodHandle mapShore$handle() {
        return mapShore.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int mapShore(const struct Layer *, int *, int, int, int, int)
     * }
     */
    public static MemorySegment mapShore$address() {
        return mapShore.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int mapShore(const struct Layer *, int *, int, int, int, int)
     * }
     */
    public static int mapShore(MemorySegment x0, MemorySegment x1, int x2, int x3, int x4, int x5) {
        var mh$ = mapShore.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("mapShore", x0, x1, x2, x3, x4, x5);
            }
            return (int)mh$.invokeExact(x0, x1, x2, x3, x4, x5);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class mapSwampRiver {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Cubiomes.C_INT,
            Cubiomes.C_POINTER,
            Cubiomes.C_POINTER,
            Cubiomes.C_INT,
            Cubiomes.C_INT,
            Cubiomes.C_INT,
            Cubiomes.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("mapSwampRiver");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int mapSwampRiver(const struct Layer *, int *, int, int, int, int)
     * }
     */
    public static FunctionDescriptor mapSwampRiver$descriptor() {
        return mapSwampRiver.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int mapSwampRiver(const struct Layer *, int *, int, int, int, int)
     * }
     */
    public static MethodHandle mapSwampRiver$handle() {
        return mapSwampRiver.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int mapSwampRiver(const struct Layer *, int *, int, int, int, int)
     * }
     */
    public static MemorySegment mapSwampRiver$address() {
        return mapSwampRiver.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int mapSwampRiver(const struct Layer *, int *, int, int, int, int)
     * }
     */
    public static int mapSwampRiver(MemorySegment x0, MemorySegment x1, int x2, int x3, int x4, int x5) {
        var mh$ = mapSwampRiver.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("mapSwampRiver", x0, x1, x2, x3, x4, x5);
            }
            return (int)mh$.invokeExact(x0, x1, x2, x3, x4, x5);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class mapRiverMix {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Cubiomes.C_INT,
            Cubiomes.C_POINTER,
            Cubiomes.C_POINTER,
            Cubiomes.C_INT,
            Cubiomes.C_INT,
            Cubiomes.C_INT,
            Cubiomes.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("mapRiverMix");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int mapRiverMix(const struct Layer *, int *, int, int, int, int)
     * }
     */
    public static FunctionDescriptor mapRiverMix$descriptor() {
        return mapRiverMix.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int mapRiverMix(const struct Layer *, int *, int, int, int, int)
     * }
     */
    public static MethodHandle mapRiverMix$handle() {
        return mapRiverMix.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int mapRiverMix(const struct Layer *, int *, int, int, int, int)
     * }
     */
    public static MemorySegment mapRiverMix$address() {
        return mapRiverMix.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int mapRiverMix(const struct Layer *, int *, int, int, int, int)
     * }
     */
    public static int mapRiverMix(MemorySegment x0, MemorySegment x1, int x2, int x3, int x4, int x5) {
        var mh$ = mapRiverMix.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("mapRiverMix", x0, x1, x2, x3, x4, x5);
            }
            return (int)mh$.invokeExact(x0, x1, x2, x3, x4, x5);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class mapOceanTemp {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Cubiomes.C_INT,
            Cubiomes.C_POINTER,
            Cubiomes.C_POINTER,
            Cubiomes.C_INT,
            Cubiomes.C_INT,
            Cubiomes.C_INT,
            Cubiomes.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("mapOceanTemp");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int mapOceanTemp(const struct Layer *, int *, int, int, int, int)
     * }
     */
    public static FunctionDescriptor mapOceanTemp$descriptor() {
        return mapOceanTemp.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int mapOceanTemp(const struct Layer *, int *, int, int, int, int)
     * }
     */
    public static MethodHandle mapOceanTemp$handle() {
        return mapOceanTemp.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int mapOceanTemp(const struct Layer *, int *, int, int, int, int)
     * }
     */
    public static MemorySegment mapOceanTemp$address() {
        return mapOceanTemp.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int mapOceanTemp(const struct Layer *, int *, int, int, int, int)
     * }
     */
    public static int mapOceanTemp(MemorySegment x0, MemorySegment x1, int x2, int x3, int x4, int x5) {
        var mh$ = mapOceanTemp.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("mapOceanTemp", x0, x1, x2, x3, x4, x5);
            }
            return (int)mh$.invokeExact(x0, x1, x2, x3, x4, x5);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class mapOceanMix {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Cubiomes.C_INT,
            Cubiomes.C_POINTER,
            Cubiomes.C_POINTER,
            Cubiomes.C_INT,
            Cubiomes.C_INT,
            Cubiomes.C_INT,
            Cubiomes.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("mapOceanMix");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int mapOceanMix(const struct Layer *, int *, int, int, int, int)
     * }
     */
    public static FunctionDescriptor mapOceanMix$descriptor() {
        return mapOceanMix.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int mapOceanMix(const struct Layer *, int *, int, int, int, int)
     * }
     */
    public static MethodHandle mapOceanMix$handle() {
        return mapOceanMix.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int mapOceanMix(const struct Layer *, int *, int, int, int, int)
     * }
     */
    public static MemorySegment mapOceanMix$address() {
        return mapOceanMix.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int mapOceanMix(const struct Layer *, int *, int, int, int, int)
     * }
     */
    public static int mapOceanMix(MemorySegment x0, MemorySegment x1, int x2, int x3, int x4, int x5) {
        var mh$ = mapOceanMix.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("mapOceanMix", x0, x1, x2, x3, x4, x5);
            }
            return (int)mh$.invokeExact(x0, x1, x2, x3, x4, x5);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class mapVoronoi {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Cubiomes.C_INT,
            Cubiomes.C_POINTER,
            Cubiomes.C_POINTER,
            Cubiomes.C_INT,
            Cubiomes.C_INT,
            Cubiomes.C_INT,
            Cubiomes.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("mapVoronoi");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int mapVoronoi(const struct Layer *, int *, int, int, int, int)
     * }
     */
    public static FunctionDescriptor mapVoronoi$descriptor() {
        return mapVoronoi.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int mapVoronoi(const struct Layer *, int *, int, int, int, int)
     * }
     */
    public static MethodHandle mapVoronoi$handle() {
        return mapVoronoi.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int mapVoronoi(const struct Layer *, int *, int, int, int, int)
     * }
     */
    public static MemorySegment mapVoronoi$address() {
        return mapVoronoi.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int mapVoronoi(const struct Layer *, int *, int, int, int, int)
     * }
     */
    public static int mapVoronoi(MemorySegment x0, MemorySegment x1, int x2, int x3, int x4, int x5) {
        var mh$ = mapVoronoi.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("mapVoronoi", x0, x1, x2, x3, x4, x5);
            }
            return (int)mh$.invokeExact(x0, x1, x2, x3, x4, x5);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class mapVoronoi114 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Cubiomes.C_INT,
            Cubiomes.C_POINTER,
            Cubiomes.C_POINTER,
            Cubiomes.C_INT,
            Cubiomes.C_INT,
            Cubiomes.C_INT,
            Cubiomes.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("mapVoronoi114");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int mapVoronoi114(const struct Layer *, int *, int, int, int, int)
     * }
     */
    public static FunctionDescriptor mapVoronoi114$descriptor() {
        return mapVoronoi114.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int mapVoronoi114(const struct Layer *, int *, int, int, int, int)
     * }
     */
    public static MethodHandle mapVoronoi114$handle() {
        return mapVoronoi114.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int mapVoronoi114(const struct Layer *, int *, int, int, int, int)
     * }
     */
    public static MemorySegment mapVoronoi114$address() {
        return mapVoronoi114.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int mapVoronoi114(const struct Layer *, int *, int, int, int, int)
     * }
     */
    public static int mapVoronoi114(MemorySegment x0, MemorySegment x1, int x2, int x3, int x4, int x5) {
        var mh$ = mapVoronoi114.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("mapVoronoi114", x0, x1, x2, x3, x4, x5);
            }
            return (int)mh$.invokeExact(x0, x1, x2, x3, x4, x5);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class getVoronoiSHA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Cubiomes.C_LONG,
            Cubiomes.C_LONG
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("getVoronoiSHA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * uint64_t getVoronoiSHA(uint64_t worldSeed)
     * }
     */
    public static FunctionDescriptor getVoronoiSHA$descriptor() {
        return getVoronoiSHA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * uint64_t getVoronoiSHA(uint64_t worldSeed)
     * }
     */
    public static MethodHandle getVoronoiSHA$handle() {
        return getVoronoiSHA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * uint64_t getVoronoiSHA(uint64_t worldSeed)
     * }
     */
    public static MemorySegment getVoronoiSHA$address() {
        return getVoronoiSHA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * uint64_t getVoronoiSHA(uint64_t worldSeed)
     * }
     */
    public static long getVoronoiSHA(long worldSeed) {
        var mh$ = getVoronoiSHA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("getVoronoiSHA", worldSeed);
            }
            return (long)mh$.invokeExact(worldSeed);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class voronoiAccess3D {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            Cubiomes.C_LONG,
            Cubiomes.C_INT,
            Cubiomes.C_INT,
            Cubiomes.C_INT,
            Cubiomes.C_POINTER,
            Cubiomes.C_POINTER,
            Cubiomes.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("voronoiAccess3D");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void voronoiAccess3D(uint64_t sha, int x, int y, int z, int *x4, int *y4, int *z4)
     * }
     */
    public static FunctionDescriptor voronoiAccess3D$descriptor() {
        return voronoiAccess3D.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void voronoiAccess3D(uint64_t sha, int x, int y, int z, int *x4, int *y4, int *z4)
     * }
     */
    public static MethodHandle voronoiAccess3D$handle() {
        return voronoiAccess3D.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void voronoiAccess3D(uint64_t sha, int x, int y, int z, int *x4, int *y4, int *z4)
     * }
     */
    public static MemorySegment voronoiAccess3D$address() {
        return voronoiAccess3D.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void voronoiAccess3D(uint64_t sha, int x, int y, int z, int *x4, int *y4, int *z4)
     * }
     */
    public static void voronoiAccess3D(long sha, int x, int y, int z, MemorySegment x4, MemorySegment y4, MemorySegment z4) {
        var mh$ = voronoiAccess3D.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("voronoiAccess3D", sha, x, y, z, x4, y4, z4);
            }
            mh$.invokeExact(sha, x, y, z, x4, y4, z4);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class mapVoronoiPlane {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            Cubiomes.C_LONG,
            Cubiomes.C_POINTER,
            Cubiomes.C_POINTER,
            Cubiomes.C_INT,
            Cubiomes.C_INT,
            Cubiomes.C_INT,
            Cubiomes.C_INT,
            Cubiomes.C_INT,
            Cubiomes.C_INT,
            Cubiomes.C_INT,
            Cubiomes.C_INT,
            Cubiomes.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("mapVoronoiPlane");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void mapVoronoiPlane(uint64_t sha, int *out, int *src, int x, int z, int w, int h, int y, int px, int pz, int pw, int ph)
     * }
     */
    public static FunctionDescriptor mapVoronoiPlane$descriptor() {
        return mapVoronoiPlane.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void mapVoronoiPlane(uint64_t sha, int *out, int *src, int x, int z, int w, int h, int y, int px, int pz, int pw, int ph)
     * }
     */
    public static MethodHandle mapVoronoiPlane$handle() {
        return mapVoronoiPlane.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void mapVoronoiPlane(uint64_t sha, int *out, int *src, int x, int z, int w, int h, int y, int px, int pz, int pw, int ph)
     * }
     */
    public static MemorySegment mapVoronoiPlane$address() {
        return mapVoronoiPlane.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void mapVoronoiPlane(uint64_t sha, int *out, int *src, int x, int z, int w, int h, int y, int px, int pz, int pw, int ph)
     * }
     */
    public static void mapVoronoiPlane(long sha, MemorySegment out, MemorySegment src, int x, int z, int w, int h, int y, int px, int pz, int pw, int ph) {
        var mh$ = mapVoronoiPlane.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("mapVoronoiPlane", sha, out, src, x, z, w, h, y, px, pz, pw, ph);
            }
            mh$.invokeExact(sha, out, src, x, z, w, h, y, px, pz, pw, ph);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    private static final int NP_TEMPERATURE = (int)0L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.NP_TEMPERATURE = 0
     * }
     */
    public static int NP_TEMPERATURE() {
        return NP_TEMPERATURE;
    }
    private static final int NP_HUMIDITY = (int)1L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.NP_HUMIDITY = 1
     * }
     */
    public static int NP_HUMIDITY() {
        return NP_HUMIDITY;
    }
    private static final int NP_CONTINENTALNESS = (int)2L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.NP_CONTINENTALNESS = 2
     * }
     */
    public static int NP_CONTINENTALNESS() {
        return NP_CONTINENTALNESS;
    }
    private static final int NP_EROSION = (int)3L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.NP_EROSION = 3
     * }
     */
    public static int NP_EROSION() {
        return NP_EROSION;
    }
    private static final int NP_SHIFT = (int)4L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.NP_SHIFT = 4
     * }
     */
    public static int NP_SHIFT() {
        return NP_SHIFT;
    }
    private static final int NP_DEPTH = (int)4L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.NP_DEPTH = 4
     * }
     */
    public static int NP_DEPTH() {
        return NP_DEPTH;
    }
    private static final int NP_WEIRDNESS = (int)5L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.NP_WEIRDNESS = 5
     * }
     */
    public static int NP_WEIRDNESS() {
        return NP_WEIRDNESS;
    }
    private static final int NP_MAX = (int)6L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.NP_MAX = 6
     * }
     */
    public static int NP_MAX() {
        return NP_MAX;
    }

    private static class initSurfaceNoise {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            Cubiomes.C_POINTER,
            Cubiomes.C_INT,
            Cubiomes.C_LONG
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("initSurfaceNoise");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void initSurfaceNoise(SurfaceNoise *sn, int dim, uint64_t seed)
     * }
     */
    public static FunctionDescriptor initSurfaceNoise$descriptor() {
        return initSurfaceNoise.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void initSurfaceNoise(SurfaceNoise *sn, int dim, uint64_t seed)
     * }
     */
    public static MethodHandle initSurfaceNoise$handle() {
        return initSurfaceNoise.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void initSurfaceNoise(SurfaceNoise *sn, int dim, uint64_t seed)
     * }
     */
    public static MemorySegment initSurfaceNoise$address() {
        return initSurfaceNoise.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void initSurfaceNoise(SurfaceNoise *sn, int dim, uint64_t seed)
     * }
     */
    public static void initSurfaceNoise(MemorySegment sn, int dim, long seed) {
        var mh$ = initSurfaceNoise.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("initSurfaceNoise", sn, dim, seed);
            }
            mh$.invokeExact(sn, dim, seed);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class initSurfaceNoiseBeta {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            Cubiomes.C_POINTER,
            Cubiomes.C_LONG
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("initSurfaceNoiseBeta");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void initSurfaceNoiseBeta(SurfaceNoiseBeta *snb, uint64_t seed)
     * }
     */
    public static FunctionDescriptor initSurfaceNoiseBeta$descriptor() {
        return initSurfaceNoiseBeta.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void initSurfaceNoiseBeta(SurfaceNoiseBeta *snb, uint64_t seed)
     * }
     */
    public static MethodHandle initSurfaceNoiseBeta$handle() {
        return initSurfaceNoiseBeta.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void initSurfaceNoiseBeta(SurfaceNoiseBeta *snb, uint64_t seed)
     * }
     */
    public static MemorySegment initSurfaceNoiseBeta$address() {
        return initSurfaceNoiseBeta.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void initSurfaceNoiseBeta(SurfaceNoiseBeta *snb, uint64_t seed)
     * }
     */
    public static void initSurfaceNoiseBeta(MemorySegment snb, long seed) {
        var mh$ = initSurfaceNoiseBeta.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("initSurfaceNoiseBeta", snb, seed);
            }
            mh$.invokeExact(snb, seed);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class sampleSurfaceNoise {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Cubiomes.C_DOUBLE,
            Cubiomes.C_POINTER,
            Cubiomes.C_INT,
            Cubiomes.C_INT,
            Cubiomes.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("sampleSurfaceNoise");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * double sampleSurfaceNoise(const SurfaceNoise *sn, int x, int y, int z)
     * }
     */
    public static FunctionDescriptor sampleSurfaceNoise$descriptor() {
        return sampleSurfaceNoise.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * double sampleSurfaceNoise(const SurfaceNoise *sn, int x, int y, int z)
     * }
     */
    public static MethodHandle sampleSurfaceNoise$handle() {
        return sampleSurfaceNoise.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * double sampleSurfaceNoise(const SurfaceNoise *sn, int x, int y, int z)
     * }
     */
    public static MemorySegment sampleSurfaceNoise$address() {
        return sampleSurfaceNoise.ADDR;
    }

    /**
     * {@snippet lang=c :
     * double sampleSurfaceNoise(const SurfaceNoise *sn, int x, int y, int z)
     * }
     */
    public static double sampleSurfaceNoise(MemorySegment sn, int x, int y, int z) {
        var mh$ = sampleSurfaceNoise.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("sampleSurfaceNoise", sn, x, y, z);
            }
            return (double)mh$.invokeExact(sn, x, y, z);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class sampleSurfaceNoiseBetween {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Cubiomes.C_DOUBLE,
            Cubiomes.C_POINTER,
            Cubiomes.C_INT,
            Cubiomes.C_INT,
            Cubiomes.C_INT,
            Cubiomes.C_DOUBLE,
            Cubiomes.C_DOUBLE
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("sampleSurfaceNoiseBetween");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * double sampleSurfaceNoiseBetween(const SurfaceNoise *sn, int x, int y, int z, double noiseMin, double noiseMax)
     * }
     */
    public static FunctionDescriptor sampleSurfaceNoiseBetween$descriptor() {
        return sampleSurfaceNoiseBetween.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * double sampleSurfaceNoiseBetween(const SurfaceNoise *sn, int x, int y, int z, double noiseMin, double noiseMax)
     * }
     */
    public static MethodHandle sampleSurfaceNoiseBetween$handle() {
        return sampleSurfaceNoiseBetween.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * double sampleSurfaceNoiseBetween(const SurfaceNoise *sn, int x, int y, int z, double noiseMin, double noiseMax)
     * }
     */
    public static MemorySegment sampleSurfaceNoiseBetween$address() {
        return sampleSurfaceNoiseBetween.ADDR;
    }

    /**
     * {@snippet lang=c :
     * double sampleSurfaceNoiseBetween(const SurfaceNoise *sn, int x, int y, int z, double noiseMin, double noiseMax)
     * }
     */
    public static double sampleSurfaceNoiseBetween(MemorySegment sn, int x, int y, int z, double noiseMin, double noiseMax) {
        var mh$ = sampleSurfaceNoiseBetween.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("sampleSurfaceNoiseBetween", sn, x, y, z, noiseMin, noiseMax);
            }
            return (double)mh$.invokeExact(sn, x, y, z, noiseMin, noiseMax);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class setNetherSeed {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            Cubiomes.C_POINTER,
            Cubiomes.C_LONG
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("setNetherSeed");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void setNetherSeed(NetherNoise *nn, uint64_t seed)
     * }
     */
    public static FunctionDescriptor setNetherSeed$descriptor() {
        return setNetherSeed.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void setNetherSeed(NetherNoise *nn, uint64_t seed)
     * }
     */
    public static MethodHandle setNetherSeed$handle() {
        return setNetherSeed.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void setNetherSeed(NetherNoise *nn, uint64_t seed)
     * }
     */
    public static MemorySegment setNetherSeed$address() {
        return setNetherSeed.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void setNetherSeed(NetherNoise *nn, uint64_t seed)
     * }
     */
    public static void setNetherSeed(MemorySegment nn, long seed) {
        var mh$ = setNetherSeed.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("setNetherSeed", nn, seed);
            }
            mh$.invokeExact(nn, seed);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class getNetherBiome {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Cubiomes.C_INT,
            Cubiomes.C_POINTER,
            Cubiomes.C_INT,
            Cubiomes.C_INT,
            Cubiomes.C_INT,
            Cubiomes.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("getNetherBiome");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int getNetherBiome(const NetherNoise *nn, int x, int y, int z, float *ndel)
     * }
     */
    public static FunctionDescriptor getNetherBiome$descriptor() {
        return getNetherBiome.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int getNetherBiome(const NetherNoise *nn, int x, int y, int z, float *ndel)
     * }
     */
    public static MethodHandle getNetherBiome$handle() {
        return getNetherBiome.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int getNetherBiome(const NetherNoise *nn, int x, int y, int z, float *ndel)
     * }
     */
    public static MemorySegment getNetherBiome$address() {
        return getNetherBiome.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int getNetherBiome(const NetherNoise *nn, int x, int y, int z, float *ndel)
     * }
     */
    public static int getNetherBiome(MemorySegment nn, int x, int y, int z, MemorySegment ndel) {
        var mh$ = getNetherBiome.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("getNetherBiome", nn, x, y, z, ndel);
            }
            return (int)mh$.invokeExact(nn, x, y, z, ndel);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class mapNether2D {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Cubiomes.C_INT,
            Cubiomes.C_POINTER,
            Cubiomes.C_POINTER,
            Cubiomes.C_INT,
            Cubiomes.C_INT,
            Cubiomes.C_INT,
            Cubiomes.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("mapNether2D");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int mapNether2D(const NetherNoise *nn, int *out, int x, int z, int w, int h)
     * }
     */
    public static FunctionDescriptor mapNether2D$descriptor() {
        return mapNether2D.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int mapNether2D(const NetherNoise *nn, int *out, int x, int z, int w, int h)
     * }
     */
    public static MethodHandle mapNether2D$handle() {
        return mapNether2D.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int mapNether2D(const NetherNoise *nn, int *out, int x, int z, int w, int h)
     * }
     */
    public static MemorySegment mapNether2D$address() {
        return mapNether2D.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int mapNether2D(const NetherNoise *nn, int *out, int x, int z, int w, int h)
     * }
     */
    public static int mapNether2D(MemorySegment nn, MemorySegment out, int x, int z, int w, int h) {
        var mh$ = mapNether2D.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("mapNether2D", nn, out, x, z, w, h);
            }
            return (int)mh$.invokeExact(nn, out, x, z, w, h);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class mapNether3D {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Cubiomes.C_INT,
            Cubiomes.C_POINTER,
            Cubiomes.C_POINTER,
            Range.layout(),
            Cubiomes.C_FLOAT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("mapNether3D");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int mapNether3D(const NetherNoise *nn, int *out, Range r, float confidence)
     * }
     */
    public static FunctionDescriptor mapNether3D$descriptor() {
        return mapNether3D.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int mapNether3D(const NetherNoise *nn, int *out, Range r, float confidence)
     * }
     */
    public static MethodHandle mapNether3D$handle() {
        return mapNether3D.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int mapNether3D(const NetherNoise *nn, int *out, Range r, float confidence)
     * }
     */
    public static MemorySegment mapNether3D$address() {
        return mapNether3D.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int mapNether3D(const NetherNoise *nn, int *out, Range r, float confidence)
     * }
     */
    public static int mapNether3D(MemorySegment nn, MemorySegment out, MemorySegment r, float confidence) {
        var mh$ = mapNether3D.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("mapNether3D", nn, out, r, confidence);
            }
            return (int)mh$.invokeExact(nn, out, r, confidence);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class genNetherScaled {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Cubiomes.C_INT,
            Cubiomes.C_POINTER,
            Cubiomes.C_POINTER,
            Range.layout(),
            Cubiomes.C_INT,
            Cubiomes.C_LONG
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("genNetherScaled");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int genNetherScaled(const NetherNoise *nn, int *out, Range r, int mc, uint64_t sha)
     * }
     */
    public static FunctionDescriptor genNetherScaled$descriptor() {
        return genNetherScaled.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int genNetherScaled(const NetherNoise *nn, int *out, Range r, int mc, uint64_t sha)
     * }
     */
    public static MethodHandle genNetherScaled$handle() {
        return genNetherScaled.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int genNetherScaled(const NetherNoise *nn, int *out, Range r, int mc, uint64_t sha)
     * }
     */
    public static MemorySegment genNetherScaled$address() {
        return genNetherScaled.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int genNetherScaled(const NetherNoise *nn, int *out, Range r, int mc, uint64_t sha)
     * }
     */
    public static int genNetherScaled(MemorySegment nn, MemorySegment out, MemorySegment r, int mc, long sha) {
        var mh$ = genNetherScaled.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("genNetherScaled", nn, out, r, mc, sha);
            }
            return (int)mh$.invokeExact(nn, out, r, mc, sha);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class setEndSeed {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            Cubiomes.C_POINTER,
            Cubiomes.C_INT,
            Cubiomes.C_LONG
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("setEndSeed");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void setEndSeed(EndNoise *en, int mc, uint64_t seed)
     * }
     */
    public static FunctionDescriptor setEndSeed$descriptor() {
        return setEndSeed.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void setEndSeed(EndNoise *en, int mc, uint64_t seed)
     * }
     */
    public static MethodHandle setEndSeed$handle() {
        return setEndSeed.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void setEndSeed(EndNoise *en, int mc, uint64_t seed)
     * }
     */
    public static MemorySegment setEndSeed$address() {
        return setEndSeed.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void setEndSeed(EndNoise *en, int mc, uint64_t seed)
     * }
     */
    public static void setEndSeed(MemorySegment en, int mc, long seed) {
        var mh$ = setEndSeed.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("setEndSeed", en, mc, seed);
            }
            mh$.invokeExact(en, mc, seed);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class mapEndBiome {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Cubiomes.C_INT,
            Cubiomes.C_POINTER,
            Cubiomes.C_POINTER,
            Cubiomes.C_INT,
            Cubiomes.C_INT,
            Cubiomes.C_INT,
            Cubiomes.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("mapEndBiome");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int mapEndBiome(const EndNoise *en, int *out, int x, int z, int w, int h)
     * }
     */
    public static FunctionDescriptor mapEndBiome$descriptor() {
        return mapEndBiome.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int mapEndBiome(const EndNoise *en, int *out, int x, int z, int w, int h)
     * }
     */
    public static MethodHandle mapEndBiome$handle() {
        return mapEndBiome.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int mapEndBiome(const EndNoise *en, int *out, int x, int z, int w, int h)
     * }
     */
    public static MemorySegment mapEndBiome$address() {
        return mapEndBiome.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int mapEndBiome(const EndNoise *en, int *out, int x, int z, int w, int h)
     * }
     */
    public static int mapEndBiome(MemorySegment en, MemorySegment out, int x, int z, int w, int h) {
        var mh$ = mapEndBiome.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("mapEndBiome", en, out, x, z, w, h);
            }
            return (int)mh$.invokeExact(en, out, x, z, w, h);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class mapEnd {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Cubiomes.C_INT,
            Cubiomes.C_POINTER,
            Cubiomes.C_POINTER,
            Cubiomes.C_INT,
            Cubiomes.C_INT,
            Cubiomes.C_INT,
            Cubiomes.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("mapEnd");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int mapEnd(const EndNoise *en, int *out, int x, int z, int w, int h)
     * }
     */
    public static FunctionDescriptor mapEnd$descriptor() {
        return mapEnd.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int mapEnd(const EndNoise *en, int *out, int x, int z, int w, int h)
     * }
     */
    public static MethodHandle mapEnd$handle() {
        return mapEnd.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int mapEnd(const EndNoise *en, int *out, int x, int z, int w, int h)
     * }
     */
    public static MemorySegment mapEnd$address() {
        return mapEnd.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int mapEnd(const EndNoise *en, int *out, int x, int z, int w, int h)
     * }
     */
    public static int mapEnd(MemorySegment en, MemorySegment out, int x, int z, int w, int h) {
        var mh$ = mapEnd.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("mapEnd", en, out, x, z, w, h);
            }
            return (int)mh$.invokeExact(en, out, x, z, w, h);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class getEndSurfaceHeight {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Cubiomes.C_INT,
            Cubiomes.C_INT,
            Cubiomes.C_LONG,
            Cubiomes.C_INT,
            Cubiomes.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("getEndSurfaceHeight");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int getEndSurfaceHeight(int mc, uint64_t seed, int x, int z)
     * }
     */
    public static FunctionDescriptor getEndSurfaceHeight$descriptor() {
        return getEndSurfaceHeight.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int getEndSurfaceHeight(int mc, uint64_t seed, int x, int z)
     * }
     */
    public static MethodHandle getEndSurfaceHeight$handle() {
        return getEndSurfaceHeight.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int getEndSurfaceHeight(int mc, uint64_t seed, int x, int z)
     * }
     */
    public static MemorySegment getEndSurfaceHeight$address() {
        return getEndSurfaceHeight.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int getEndSurfaceHeight(int mc, uint64_t seed, int x, int z)
     * }
     */
    public static int getEndSurfaceHeight(int mc, long seed, int x, int z) {
        var mh$ = getEndSurfaceHeight.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("getEndSurfaceHeight", mc, seed, x, z);
            }
            return (int)mh$.invokeExact(mc, seed, x, z);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class mapEndSurfaceHeight {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Cubiomes.C_INT,
            Cubiomes.C_POINTER,
            Cubiomes.C_POINTER,
            Cubiomes.C_POINTER,
            Cubiomes.C_INT,
            Cubiomes.C_INT,
            Cubiomes.C_INT,
            Cubiomes.C_INT,
            Cubiomes.C_INT,
            Cubiomes.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("mapEndSurfaceHeight");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int mapEndSurfaceHeight(float *y, const EndNoise *en, const SurfaceNoise *sn, int x, int z, int w, int h, int scale, int ymin)
     * }
     */
    public static FunctionDescriptor mapEndSurfaceHeight$descriptor() {
        return mapEndSurfaceHeight.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int mapEndSurfaceHeight(float *y, const EndNoise *en, const SurfaceNoise *sn, int x, int z, int w, int h, int scale, int ymin)
     * }
     */
    public static MethodHandle mapEndSurfaceHeight$handle() {
        return mapEndSurfaceHeight.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int mapEndSurfaceHeight(float *y, const EndNoise *en, const SurfaceNoise *sn, int x, int z, int w, int h, int scale, int ymin)
     * }
     */
    public static MemorySegment mapEndSurfaceHeight$address() {
        return mapEndSurfaceHeight.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int mapEndSurfaceHeight(float *y, const EndNoise *en, const SurfaceNoise *sn, int x, int z, int w, int h, int scale, int ymin)
     * }
     */
    public static int mapEndSurfaceHeight(MemorySegment y, MemorySegment en, MemorySegment sn, int x, int z, int w, int h, int scale, int ymin) {
        var mh$ = mapEndSurfaceHeight.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("mapEndSurfaceHeight", y, en, sn, x, z, w, h, scale, ymin);
            }
            return (int)mh$.invokeExact(y, en, sn, x, z, w, h, scale, ymin);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class genEndScaled {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Cubiomes.C_INT,
            Cubiomes.C_POINTER,
            Cubiomes.C_POINTER,
            Range.layout(),
            Cubiomes.C_INT,
            Cubiomes.C_LONG
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("genEndScaled");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int genEndScaled(const EndNoise *en, int *out, Range r, int mc, uint64_t sha)
     * }
     */
    public static FunctionDescriptor genEndScaled$descriptor() {
        return genEndScaled.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int genEndScaled(const EndNoise *en, int *out, Range r, int mc, uint64_t sha)
     * }
     */
    public static MethodHandle genEndScaled$handle() {
        return genEndScaled.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int genEndScaled(const EndNoise *en, int *out, Range r, int mc, uint64_t sha)
     * }
     */
    public static MemorySegment genEndScaled$address() {
        return genEndScaled.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int genEndScaled(const EndNoise *en, int *out, Range r, int mc, uint64_t sha)
     * }
     */
    public static int genEndScaled(MemorySegment en, MemorySegment out, MemorySegment r, int mc, long sha) {
        var mh$ = genEndScaled.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("genEndScaled", en, out, r, mc, sha);
            }
            return (int)mh$.invokeExact(en, out, r, mc, sha);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    private static final int SAMPLE_NO_SHIFT = (int)1L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.SAMPLE_NO_SHIFT = 1
     * }
     */
    public static int SAMPLE_NO_SHIFT() {
        return SAMPLE_NO_SHIFT;
    }
    private static final int SAMPLE_NO_DEPTH = (int)2L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.SAMPLE_NO_DEPTH = 2
     * }
     */
    public static int SAMPLE_NO_DEPTH() {
        return SAMPLE_NO_DEPTH;
    }
    private static final int SAMPLE_NO_BIOME = (int)4L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.SAMPLE_NO_BIOME = 4
     * }
     */
    public static int SAMPLE_NO_BIOME() {
        return SAMPLE_NO_BIOME;
    }
    private static final int SP_CONTINENTALNESS = (int)0L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.SP_CONTINENTALNESS = 0
     * }
     */
    public static int SP_CONTINENTALNESS() {
        return SP_CONTINENTALNESS;
    }
    private static final int SP_EROSION = (int)1L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.SP_EROSION = 1
     * }
     */
    public static int SP_EROSION() {
        return SP_EROSION;
    }
    private static final int SP_RIDGES = (int)2L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.SP_RIDGES = 2
     * }
     */
    public static int SP_RIDGES() {
        return SP_RIDGES;
    }
    private static final int SP_WEIRDNESS = (int)3L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.SP_WEIRDNESS = 3
     * }
     */
    public static int SP_WEIRDNESS() {
        return SP_WEIRDNESS;
    }

    private static class addSplineVal {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            Cubiomes.C_POINTER,
            Cubiomes.C_FLOAT,
            Cubiomes.C_POINTER,
            Cubiomes.C_FLOAT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("addSplineVal");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void addSplineVal(Spline *rsp, float loc, Spline *val, float der)
     * }
     */
    public static FunctionDescriptor addSplineVal$descriptor() {
        return addSplineVal.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void addSplineVal(Spline *rsp, float loc, Spline *val, float der)
     * }
     */
    public static MethodHandle addSplineVal$handle() {
        return addSplineVal.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void addSplineVal(Spline *rsp, float loc, Spline *val, float der)
     * }
     */
    public static MemorySegment addSplineVal$address() {
        return addSplineVal.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void addSplineVal(Spline *rsp, float loc, Spline *val, float der)
     * }
     */
    public static void addSplineVal(MemorySegment rsp, float loc, MemorySegment val, float der) {
        var mh$ = addSplineVal.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("addSplineVal", rsp, loc, val, der);
            }
            mh$.invokeExact(rsp, loc, val, der);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class createFixSpline {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Cubiomes.C_POINTER,
            Cubiomes.C_POINTER,
            Cubiomes.C_FLOAT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("createFixSpline");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * Spline *createFixSpline(SplineStack *ss, float val)
     * }
     */
    public static FunctionDescriptor createFixSpline$descriptor() {
        return createFixSpline.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * Spline *createFixSpline(SplineStack *ss, float val)
     * }
     */
    public static MethodHandle createFixSpline$handle() {
        return createFixSpline.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * Spline *createFixSpline(SplineStack *ss, float val)
     * }
     */
    public static MemorySegment createFixSpline$address() {
        return createFixSpline.ADDR;
    }

    /**
     * {@snippet lang=c :
     * Spline *createFixSpline(SplineStack *ss, float val)
     * }
     */
    public static MemorySegment createFixSpline(MemorySegment ss, float val) {
        var mh$ = createFixSpline.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("createFixSpline", ss, val);
            }
            return (MemorySegment)mh$.invokeExact(ss, val);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class getSpline {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Cubiomes.C_FLOAT,
            Cubiomes.C_POINTER,
            Cubiomes.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("getSpline");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * float getSpline(const Spline *sp, const float *vals)
     * }
     */
    public static FunctionDescriptor getSpline$descriptor() {
        return getSpline.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * float getSpline(const Spline *sp, const float *vals)
     * }
     */
    public static MethodHandle getSpline$handle() {
        return getSpline.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * float getSpline(const Spline *sp, const float *vals)
     * }
     */
    public static MemorySegment getSpline$address() {
        return getSpline.ADDR;
    }

    /**
     * {@snippet lang=c :
     * float getSpline(const Spline *sp, const float *vals)
     * }
     */
    public static float getSpline(MemorySegment sp, MemorySegment vals) {
        var mh$ = getSpline.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("getSpline", sp, vals);
            }
            return (float)mh$.invokeExact(sp, vals);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class initBiomeNoise {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            Cubiomes.C_POINTER,
            Cubiomes.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("initBiomeNoise");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void initBiomeNoise(BiomeNoise *bn, int mc)
     * }
     */
    public static FunctionDescriptor initBiomeNoise$descriptor() {
        return initBiomeNoise.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void initBiomeNoise(BiomeNoise *bn, int mc)
     * }
     */
    public static MethodHandle initBiomeNoise$handle() {
        return initBiomeNoise.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void initBiomeNoise(BiomeNoise *bn, int mc)
     * }
     */
    public static MemorySegment initBiomeNoise$address() {
        return initBiomeNoise.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void initBiomeNoise(BiomeNoise *bn, int mc)
     * }
     */
    public static void initBiomeNoise(MemorySegment bn, int mc) {
        var mh$ = initBiomeNoise.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("initBiomeNoise", bn, mc);
            }
            mh$.invokeExact(bn, mc);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class setBiomeSeed {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            Cubiomes.C_POINTER,
            Cubiomes.C_LONG,
            Cubiomes.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("setBiomeSeed");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void setBiomeSeed(BiomeNoise *bn, uint64_t seed, int large)
     * }
     */
    public static FunctionDescriptor setBiomeSeed$descriptor() {
        return setBiomeSeed.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void setBiomeSeed(BiomeNoise *bn, uint64_t seed, int large)
     * }
     */
    public static MethodHandle setBiomeSeed$handle() {
        return setBiomeSeed.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void setBiomeSeed(BiomeNoise *bn, uint64_t seed, int large)
     * }
     */
    public static MemorySegment setBiomeSeed$address() {
        return setBiomeSeed.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void setBiomeSeed(BiomeNoise *bn, uint64_t seed, int large)
     * }
     */
    public static void setBiomeSeed(MemorySegment bn, long seed, int large) {
        var mh$ = setBiomeSeed.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("setBiomeSeed", bn, seed, large);
            }
            mh$.invokeExact(bn, seed, large);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class setBetaBiomeSeed {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            Cubiomes.C_POINTER,
            Cubiomes.C_LONG
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("setBetaBiomeSeed");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void setBetaBiomeSeed(BiomeNoiseBeta *bnb, uint64_t seed)
     * }
     */
    public static FunctionDescriptor setBetaBiomeSeed$descriptor() {
        return setBetaBiomeSeed.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void setBetaBiomeSeed(BiomeNoiseBeta *bnb, uint64_t seed)
     * }
     */
    public static MethodHandle setBetaBiomeSeed$handle() {
        return setBetaBiomeSeed.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void setBetaBiomeSeed(BiomeNoiseBeta *bnb, uint64_t seed)
     * }
     */
    public static MemorySegment setBetaBiomeSeed$address() {
        return setBetaBiomeSeed.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void setBetaBiomeSeed(BiomeNoiseBeta *bnb, uint64_t seed)
     * }
     */
    public static void setBetaBiomeSeed(MemorySegment bnb, long seed) {
        var mh$ = setBetaBiomeSeed.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("setBetaBiomeSeed", bnb, seed);
            }
            mh$.invokeExact(bnb, seed);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class sampleBiomeNoise {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Cubiomes.C_INT,
            Cubiomes.C_POINTER,
            Cubiomes.C_POINTER,
            Cubiomes.C_INT,
            Cubiomes.C_INT,
            Cubiomes.C_INT,
            Cubiomes.C_POINTER,
            Cubiomes.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("sampleBiomeNoise");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int sampleBiomeNoise(const BiomeNoise *bn, int64_t *np, int x, int y, int z, uint64_t *dat, uint32_t sample_flags)
     * }
     */
    public static FunctionDescriptor sampleBiomeNoise$descriptor() {
        return sampleBiomeNoise.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int sampleBiomeNoise(const BiomeNoise *bn, int64_t *np, int x, int y, int z, uint64_t *dat, uint32_t sample_flags)
     * }
     */
    public static MethodHandle sampleBiomeNoise$handle() {
        return sampleBiomeNoise.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int sampleBiomeNoise(const BiomeNoise *bn, int64_t *np, int x, int y, int z, uint64_t *dat, uint32_t sample_flags)
     * }
     */
    public static MemorySegment sampleBiomeNoise$address() {
        return sampleBiomeNoise.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int sampleBiomeNoise(const BiomeNoise *bn, int64_t *np, int x, int y, int z, uint64_t *dat, uint32_t sample_flags)
     * }
     */
    public static int sampleBiomeNoise(MemorySegment bn, MemorySegment np, int x, int y, int z, MemorySegment dat, int sample_flags) {
        var mh$ = sampleBiomeNoise.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("sampleBiomeNoise", bn, np, x, y, z, dat, sample_flags);
            }
            return (int)mh$.invokeExact(bn, np, x, y, z, dat, sample_flags);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class sampleNoiseParameters {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            Cubiomes.C_POINTER,
            Cubiomes.C_INT,
            Cubiomes.C_INT,
            Cubiomes.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("sampleNoiseParameters");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void sampleNoiseParameters(BiomeNoise *bn, int x, int z, float np_param[4])
     * }
     */
    public static FunctionDescriptor sampleNoiseParameters$descriptor() {
        return sampleNoiseParameters.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void sampleNoiseParameters(BiomeNoise *bn, int x, int z, float np_param[4])
     * }
     */
    public static MethodHandle sampleNoiseParameters$handle() {
        return sampleNoiseParameters.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void sampleNoiseParameters(BiomeNoise *bn, int x, int z, float np_param[4])
     * }
     */
    public static MemorySegment sampleNoiseParameters$address() {
        return sampleNoiseParameters.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void sampleNoiseParameters(BiomeNoise *bn, int x, int z, float np_param[4])
     * }
     */
    public static void sampleNoiseParameters(MemorySegment bn, int x, int z, MemorySegment np_param) {
        var mh$ = sampleNoiseParameters.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("sampleNoiseParameters", bn, x, z, np_param);
            }
            mh$.invokeExact(bn, x, z, np_param);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class sampleBiomeNoiseBeta {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Cubiomes.C_INT,
            Cubiomes.C_POINTER,
            Cubiomes.C_POINTER,
            Cubiomes.C_POINTER,
            Cubiomes.C_INT,
            Cubiomes.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("sampleBiomeNoiseBeta");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int sampleBiomeNoiseBeta(const BiomeNoiseBeta *bnb, int64_t *np, double *nv, int x, int z)
     * }
     */
    public static FunctionDescriptor sampleBiomeNoiseBeta$descriptor() {
        return sampleBiomeNoiseBeta.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int sampleBiomeNoiseBeta(const BiomeNoiseBeta *bnb, int64_t *np, double *nv, int x, int z)
     * }
     */
    public static MethodHandle sampleBiomeNoiseBeta$handle() {
        return sampleBiomeNoiseBeta.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int sampleBiomeNoiseBeta(const BiomeNoiseBeta *bnb, int64_t *np, double *nv, int x, int z)
     * }
     */
    public static MemorySegment sampleBiomeNoiseBeta$address() {
        return sampleBiomeNoiseBeta.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int sampleBiomeNoiseBeta(const BiomeNoiseBeta *bnb, int64_t *np, double *nv, int x, int z)
     * }
     */
    public static int sampleBiomeNoiseBeta(MemorySegment bnb, MemorySegment np, MemorySegment nv, int x, int z) {
        var mh$ = sampleBiomeNoiseBeta.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("sampleBiomeNoiseBeta", bnb, np, nv, x, z);
            }
            return (int)mh$.invokeExact(bnb, np, nv, x, z);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class approxSurfaceBeta {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Cubiomes.C_DOUBLE,
            Cubiomes.C_POINTER,
            Cubiomes.C_POINTER,
            Cubiomes.C_INT,
            Cubiomes.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("approxSurfaceBeta");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * double approxSurfaceBeta(const BiomeNoiseBeta *bnb, const SurfaceNoiseBeta *snb, int x, int z)
     * }
     */
    public static FunctionDescriptor approxSurfaceBeta$descriptor() {
        return approxSurfaceBeta.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * double approxSurfaceBeta(const BiomeNoiseBeta *bnb, const SurfaceNoiseBeta *snb, int x, int z)
     * }
     */
    public static MethodHandle approxSurfaceBeta$handle() {
        return approxSurfaceBeta.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * double approxSurfaceBeta(const BiomeNoiseBeta *bnb, const SurfaceNoiseBeta *snb, int x, int z)
     * }
     */
    public static MemorySegment approxSurfaceBeta$address() {
        return approxSurfaceBeta.ADDR;
    }

    /**
     * {@snippet lang=c :
     * double approxSurfaceBeta(const BiomeNoiseBeta *bnb, const SurfaceNoiseBeta *snb, int x, int z)
     * }
     */
    public static double approxSurfaceBeta(MemorySegment bnb, MemorySegment snb, int x, int z) {
        var mh$ = approxSurfaceBeta.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("approxSurfaceBeta", bnb, snb, x, z);
            }
            return (double)mh$.invokeExact(bnb, snb, x, z);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class getOldBetaBiome {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Cubiomes.C_INT,
            Cubiomes.C_FLOAT,
            Cubiomes.C_FLOAT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("getOldBetaBiome");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int getOldBetaBiome(float t, float h)
     * }
     */
    public static FunctionDescriptor getOldBetaBiome$descriptor() {
        return getOldBetaBiome.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int getOldBetaBiome(float t, float h)
     * }
     */
    public static MethodHandle getOldBetaBiome$handle() {
        return getOldBetaBiome.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int getOldBetaBiome(float t, float h)
     * }
     */
    public static MemorySegment getOldBetaBiome$address() {
        return getOldBetaBiome.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int getOldBetaBiome(float t, float h)
     * }
     */
    public static int getOldBetaBiome(float t, float h) {
        var mh$ = getOldBetaBiome.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("getOldBetaBiome", t, h);
            }
            return (int)mh$.invokeExact(t, h);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class climateToBiome {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Cubiomes.C_INT,
            Cubiomes.C_INT,
            Cubiomes.C_POINTER,
            Cubiomes.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("climateToBiome");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int climateToBiome(int mc, const uint64_t np[6], uint64_t *dat)
     * }
     */
    public static FunctionDescriptor climateToBiome$descriptor() {
        return climateToBiome.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int climateToBiome(int mc, const uint64_t np[6], uint64_t *dat)
     * }
     */
    public static MethodHandle climateToBiome$handle() {
        return climateToBiome.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int climateToBiome(int mc, const uint64_t np[6], uint64_t *dat)
     * }
     */
    public static MemorySegment climateToBiome$address() {
        return climateToBiome.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int climateToBiome(int mc, const uint64_t np[6], uint64_t *dat)
     * }
     */
    public static int climateToBiome(int mc, MemorySegment np, MemorySegment dat) {
        var mh$ = climateToBiome.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("climateToBiome", mc, np, dat);
            }
            return (int)mh$.invokeExact(mc, np, dat);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class setClimateParaSeed {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            Cubiomes.C_POINTER,
            Cubiomes.C_LONG,
            Cubiomes.C_INT,
            Cubiomes.C_INT,
            Cubiomes.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("setClimateParaSeed");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void setClimateParaSeed(BiomeNoise *bn, uint64_t seed, int large, int nptype, int nmax)
     * }
     */
    public static FunctionDescriptor setClimateParaSeed$descriptor() {
        return setClimateParaSeed.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void setClimateParaSeed(BiomeNoise *bn, uint64_t seed, int large, int nptype, int nmax)
     * }
     */
    public static MethodHandle setClimateParaSeed$handle() {
        return setClimateParaSeed.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void setClimateParaSeed(BiomeNoise *bn, uint64_t seed, int large, int nptype, int nmax)
     * }
     */
    public static MemorySegment setClimateParaSeed$address() {
        return setClimateParaSeed.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void setClimateParaSeed(BiomeNoise *bn, uint64_t seed, int large, int nptype, int nmax)
     * }
     */
    public static void setClimateParaSeed(MemorySegment bn, long seed, int large, int nptype, int nmax) {
        var mh$ = setClimateParaSeed.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("setClimateParaSeed", bn, seed, large, nptype, nmax);
            }
            mh$.invokeExact(bn, seed, large, nptype, nmax);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class sampleClimatePara {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Cubiomes.C_DOUBLE,
            Cubiomes.C_POINTER,
            Cubiomes.C_POINTER,
            Cubiomes.C_DOUBLE,
            Cubiomes.C_DOUBLE
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("sampleClimatePara");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * double sampleClimatePara(const BiomeNoise *bn, int64_t *np, double x, double z)
     * }
     */
    public static FunctionDescriptor sampleClimatePara$descriptor() {
        return sampleClimatePara.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * double sampleClimatePara(const BiomeNoise *bn, int64_t *np, double x, double z)
     * }
     */
    public static MethodHandle sampleClimatePara$handle() {
        return sampleClimatePara.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * double sampleClimatePara(const BiomeNoise *bn, int64_t *np, double x, double z)
     * }
     */
    public static MemorySegment sampleClimatePara$address() {
        return sampleClimatePara.ADDR;
    }

    /**
     * {@snippet lang=c :
     * double sampleClimatePara(const BiomeNoise *bn, int64_t *np, double x, double z)
     * }
     */
    public static double sampleClimatePara(MemorySegment bn, MemorySegment np, double x, double z) {
        var mh$ = sampleClimatePara.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("sampleClimatePara", bn, np, x, z);
            }
            return (double)mh$.invokeExact(bn, np, x, z);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class genBiomeNoiseChunkSection {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            Cubiomes.C_POINTER,
            Cubiomes.C_POINTER,
            Cubiomes.C_INT,
            Cubiomes.C_INT,
            Cubiomes.C_INT,
            Cubiomes.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("genBiomeNoiseChunkSection");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void genBiomeNoiseChunkSection(const BiomeNoise *bn, int out[4][4][4], int cx, int cy, int cz, uint64_t *dat)
     * }
     */
    public static FunctionDescriptor genBiomeNoiseChunkSection$descriptor() {
        return genBiomeNoiseChunkSection.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void genBiomeNoiseChunkSection(const BiomeNoise *bn, int out[4][4][4], int cx, int cy, int cz, uint64_t *dat)
     * }
     */
    public static MethodHandle genBiomeNoiseChunkSection$handle() {
        return genBiomeNoiseChunkSection.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void genBiomeNoiseChunkSection(const BiomeNoise *bn, int out[4][4][4], int cx, int cy, int cz, uint64_t *dat)
     * }
     */
    public static MemorySegment genBiomeNoiseChunkSection$address() {
        return genBiomeNoiseChunkSection.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void genBiomeNoiseChunkSection(const BiomeNoise *bn, int out[4][4][4], int cx, int cy, int cz, uint64_t *dat)
     * }
     */
    public static void genBiomeNoiseChunkSection(MemorySegment bn, MemorySegment out, int cx, int cy, int cz, MemorySegment dat) {
        var mh$ = genBiomeNoiseChunkSection.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("genBiomeNoiseChunkSection", bn, out, cx, cy, cz, dat);
            }
            mh$.invokeExact(bn, out, cx, cy, cz, dat);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class genBiomeNoiseScaled {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Cubiomes.C_INT,
            Cubiomes.C_POINTER,
            Cubiomes.C_POINTER,
            Range.layout(),
            Cubiomes.C_LONG
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("genBiomeNoiseScaled");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int genBiomeNoiseScaled(const BiomeNoise *bn, int *out, Range r, uint64_t sha)
     * }
     */
    public static FunctionDescriptor genBiomeNoiseScaled$descriptor() {
        return genBiomeNoiseScaled.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int genBiomeNoiseScaled(const BiomeNoise *bn, int *out, Range r, uint64_t sha)
     * }
     */
    public static MethodHandle genBiomeNoiseScaled$handle() {
        return genBiomeNoiseScaled.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int genBiomeNoiseScaled(const BiomeNoise *bn, int *out, Range r, uint64_t sha)
     * }
     */
    public static MemorySegment genBiomeNoiseScaled$address() {
        return genBiomeNoiseScaled.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int genBiomeNoiseScaled(const BiomeNoise *bn, int *out, Range r, uint64_t sha)
     * }
     */
    public static int genBiomeNoiseScaled(MemorySegment bn, MemorySegment out, MemorySegment r, long sha) {
        var mh$ = genBiomeNoiseScaled.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("genBiomeNoiseScaled", bn, out, r, sha);
            }
            return (int)mh$.invokeExact(bn, out, r, sha);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class genBiomeNoiseBetaScaled {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Cubiomes.C_INT,
            Cubiomes.C_POINTER,
            Cubiomes.C_POINTER,
            Cubiomes.C_POINTER,
            Range.layout()
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("genBiomeNoiseBetaScaled");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int genBiomeNoiseBetaScaled(const BiomeNoiseBeta *bnb, const SurfaceNoiseBeta *snb, int *out, Range r)
     * }
     */
    public static FunctionDescriptor genBiomeNoiseBetaScaled$descriptor() {
        return genBiomeNoiseBetaScaled.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int genBiomeNoiseBetaScaled(const BiomeNoiseBeta *bnb, const SurfaceNoiseBeta *snb, int *out, Range r)
     * }
     */
    public static MethodHandle genBiomeNoiseBetaScaled$handle() {
        return genBiomeNoiseBetaScaled.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int genBiomeNoiseBetaScaled(const BiomeNoiseBeta *bnb, const SurfaceNoiseBeta *snb, int *out, Range r)
     * }
     */
    public static MemorySegment genBiomeNoiseBetaScaled$address() {
        return genBiomeNoiseBetaScaled.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int genBiomeNoiseBetaScaled(const BiomeNoiseBeta *bnb, const SurfaceNoiseBeta *snb, int *out, Range r)
     * }
     */
    public static int genBiomeNoiseBetaScaled(MemorySegment bnb, MemorySegment snb, MemorySegment out, MemorySegment r) {
        var mh$ = genBiomeNoiseBetaScaled.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("genBiomeNoiseBetaScaled", bnb, snb, out, r);
            }
            return (int)mh$.invokeExact(bnb, snb, out, r);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class getBiomeDepthAndScale {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Cubiomes.C_INT,
            Cubiomes.C_INT,
            Cubiomes.C_POINTER,
            Cubiomes.C_POINTER,
            Cubiomes.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("getBiomeDepthAndScale");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int getBiomeDepthAndScale(int id, double *depth, double *scale, int *grass)
     * }
     */
    public static FunctionDescriptor getBiomeDepthAndScale$descriptor() {
        return getBiomeDepthAndScale.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int getBiomeDepthAndScale(int id, double *depth, double *scale, int *grass)
     * }
     */
    public static MethodHandle getBiomeDepthAndScale$handle() {
        return getBiomeDepthAndScale.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int getBiomeDepthAndScale(int id, double *depth, double *scale, int *grass)
     * }
     */
    public static MemorySegment getBiomeDepthAndScale$address() {
        return getBiomeDepthAndScale.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int getBiomeDepthAndScale(int id, double *depth, double *scale, int *grass)
     * }
     */
    public static int getBiomeDepthAndScale(int id, MemorySegment depth, MemorySegment scale, MemorySegment grass) {
        var mh$ = getBiomeDepthAndScale.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("getBiomeDepthAndScale", id, depth, scale, grass);
            }
            return (int)mh$.invokeExact(id, depth, scale, grass);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class getVoronoiSrcRange {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Range.layout(),
            Range.layout()
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("getVoronoiSrcRange");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * Range getVoronoiSrcRange(Range r)
     * }
     */
    public static FunctionDescriptor getVoronoiSrcRange$descriptor() {
        return getVoronoiSrcRange.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * Range getVoronoiSrcRange(Range r)
     * }
     */
    public static MethodHandle getVoronoiSrcRange$handle() {
        return getVoronoiSrcRange.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * Range getVoronoiSrcRange(Range r)
     * }
     */
    public static MemorySegment getVoronoiSrcRange$address() {
        return getVoronoiSrcRange.ADDR;
    }

    /**
     * {@snippet lang=c :
     * Range getVoronoiSrcRange(Range r)
     * }
     */
    public static MemorySegment getVoronoiSrcRange(SegmentAllocator allocator, MemorySegment r) {
        var mh$ = getVoronoiSrcRange.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("getVoronoiSrcRange", allocator, r);
            }
            return (MemorySegment)mh$.invokeExact(allocator, r);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class initBlendedNoise {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Cubiomes.C_INT,
            Cubiomes.C_POINTER,
            Cubiomes.C_LONG,
            Cubiomes.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("initBlendedNoise");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int initBlendedNoise(BlendedNoise *bn, uint64_t ws, int dim)
     * }
     */
    public static FunctionDescriptor initBlendedNoise$descriptor() {
        return initBlendedNoise.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int initBlendedNoise(BlendedNoise *bn, uint64_t ws, int dim)
     * }
     */
    public static MethodHandle initBlendedNoise$handle() {
        return initBlendedNoise.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int initBlendedNoise(BlendedNoise *bn, uint64_t ws, int dim)
     * }
     */
    public static MemorySegment initBlendedNoise$address() {
        return initBlendedNoise.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int initBlendedNoise(BlendedNoise *bn, uint64_t ws, int dim)
     * }
     */
    public static int initBlendedNoise(MemorySegment bn, long ws, int dim) {
        var mh$ = initBlendedNoise.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("initBlendedNoise", bn, ws, dim);
            }
            return (int)mh$.invokeExact(bn, ws, dim);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class sampleBase3dNoise {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Cubiomes.C_DOUBLE,
            Cubiomes.C_POINTER,
            Cubiomes.C_INT,
            Cubiomes.C_INT,
            Cubiomes.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("sampleBase3dNoise");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * double sampleBase3dNoise(BlendedNoise *bn, int x, int y, int z)
     * }
     */
    public static FunctionDescriptor sampleBase3dNoise$descriptor() {
        return sampleBase3dNoise.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * double sampleBase3dNoise(BlendedNoise *bn, int x, int y, int z)
     * }
     */
    public static MethodHandle sampleBase3dNoise$handle() {
        return sampleBase3dNoise.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * double sampleBase3dNoise(BlendedNoise *bn, int x, int y, int z)
     * }
     */
    public static MemorySegment sampleBase3dNoise$address() {
        return sampleBase3dNoise.ADDR;
    }

    /**
     * {@snippet lang=c :
     * double sampleBase3dNoise(BlendedNoise *bn, int x, int y, int z)
     * }
     */
    public static double sampleBase3dNoise(MemorySegment bn, int x, int y, int z) {
        var mh$ = sampleBase3dNoise.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("sampleBase3dNoise", bn, x, y, z);
            }
            return (double)mh$.invokeExact(bn, x, y, z);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    private static final int LARGE_BIOMES = (int)1L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.LARGE_BIOMES = 1
     * }
     */
    public static int LARGE_BIOMES() {
        return LARGE_BIOMES;
    }
    private static final int NO_BETA_OCEAN = (int)2L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.NO_BETA_OCEAN = 2
     * }
     */
    public static int NO_BETA_OCEAN() {
        return NO_BETA_OCEAN;
    }
    private static final int FORCE_OCEAN_VARIANTS = (int)4L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.FORCE_OCEAN_VARIANTS = 4
     * }
     */
    public static int FORCE_OCEAN_VARIANTS() {
        return FORCE_OCEAN_VARIANTS;
    }

    private static class setupGenerator {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            Cubiomes.C_POINTER,
            Cubiomes.C_INT,
            Cubiomes.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("setupGenerator");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void setupGenerator(Generator *g, int mc, uint32_t flags)
     * }
     */
    public static FunctionDescriptor setupGenerator$descriptor() {
        return setupGenerator.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void setupGenerator(Generator *g, int mc, uint32_t flags)
     * }
     */
    public static MethodHandle setupGenerator$handle() {
        return setupGenerator.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void setupGenerator(Generator *g, int mc, uint32_t flags)
     * }
     */
    public static MemorySegment setupGenerator$address() {
        return setupGenerator.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void setupGenerator(Generator *g, int mc, uint32_t flags)
     * }
     */
    public static void setupGenerator(MemorySegment g, int mc, int flags) {
        var mh$ = setupGenerator.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("setupGenerator", g, mc, flags);
            }
            mh$.invokeExact(g, mc, flags);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class applySeed {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            Cubiomes.C_POINTER,
            Cubiomes.C_INT,
            Cubiomes.C_LONG
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("applySeed");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void applySeed(Generator *g, int dim, uint64_t seed)
     * }
     */
    public static FunctionDescriptor applySeed$descriptor() {
        return applySeed.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void applySeed(Generator *g, int dim, uint64_t seed)
     * }
     */
    public static MethodHandle applySeed$handle() {
        return applySeed.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void applySeed(Generator *g, int dim, uint64_t seed)
     * }
     */
    public static MemorySegment applySeed$address() {
        return applySeed.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void applySeed(Generator *g, int dim, uint64_t seed)
     * }
     */
    public static void applySeed(MemorySegment g, int dim, long seed) {
        var mh$ = applySeed.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("applySeed", g, dim, seed);
            }
            mh$.invokeExact(g, dim, seed);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class getMinCacheSize {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Cubiomes.C_LONG,
            Cubiomes.C_POINTER,
            Cubiomes.C_INT,
            Cubiomes.C_INT,
            Cubiomes.C_INT,
            Cubiomes.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("getMinCacheSize");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * size_t getMinCacheSize(const Generator *g, int scale, int sx, int sy, int sz)
     * }
     */
    public static FunctionDescriptor getMinCacheSize$descriptor() {
        return getMinCacheSize.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * size_t getMinCacheSize(const Generator *g, int scale, int sx, int sy, int sz)
     * }
     */
    public static MethodHandle getMinCacheSize$handle() {
        return getMinCacheSize.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * size_t getMinCacheSize(const Generator *g, int scale, int sx, int sy, int sz)
     * }
     */
    public static MemorySegment getMinCacheSize$address() {
        return getMinCacheSize.ADDR;
    }

    /**
     * {@snippet lang=c :
     * size_t getMinCacheSize(const Generator *g, int scale, int sx, int sy, int sz)
     * }
     */
    public static long getMinCacheSize(MemorySegment g, int scale, int sx, int sy, int sz) {
        var mh$ = getMinCacheSize.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("getMinCacheSize", g, scale, sx, sy, sz);
            }
            return (long)mh$.invokeExact(g, scale, sx, sy, sz);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class allocCache {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Cubiomes.C_POINTER,
            Cubiomes.C_POINTER,
            Range.layout()
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("allocCache");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int *allocCache(const Generator *g, Range r)
     * }
     */
    public static FunctionDescriptor allocCache$descriptor() {
        return allocCache.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int *allocCache(const Generator *g, Range r)
     * }
     */
    public static MethodHandle allocCache$handle() {
        return allocCache.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int *allocCache(const Generator *g, Range r)
     * }
     */
    public static MemorySegment allocCache$address() {
        return allocCache.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int *allocCache(const Generator *g, Range r)
     * }
     */
    public static MemorySegment allocCache(MemorySegment g, MemorySegment r) {
        var mh$ = allocCache.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("allocCache", g, r);
            }
            return (MemorySegment)mh$.invokeExact(g, r);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class genBiomes {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Cubiomes.C_INT,
            Cubiomes.C_POINTER,
            Cubiomes.C_POINTER,
            Range.layout()
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("genBiomes");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int genBiomes(const Generator *g, int *cache, Range r)
     * }
     */
    public static FunctionDescriptor genBiomes$descriptor() {
        return genBiomes.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int genBiomes(const Generator *g, int *cache, Range r)
     * }
     */
    public static MethodHandle genBiomes$handle() {
        return genBiomes.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int genBiomes(const Generator *g, int *cache, Range r)
     * }
     */
    public static MemorySegment genBiomes$address() {
        return genBiomes.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int genBiomes(const Generator *g, int *cache, Range r)
     * }
     */
    public static int genBiomes(MemorySegment g, MemorySegment cache, MemorySegment r) {
        var mh$ = genBiomes.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("genBiomes", g, cache, r);
            }
            return (int)mh$.invokeExact(g, cache, r);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class getBiomeAt {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Cubiomes.C_INT,
            Cubiomes.C_POINTER,
            Cubiomes.C_INT,
            Cubiomes.C_INT,
            Cubiomes.C_INT,
            Cubiomes.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("getBiomeAt");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int getBiomeAt(const Generator *g, int scale, int x, int y, int z)
     * }
     */
    public static FunctionDescriptor getBiomeAt$descriptor() {
        return getBiomeAt.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int getBiomeAt(const Generator *g, int scale, int x, int y, int z)
     * }
     */
    public static MethodHandle getBiomeAt$handle() {
        return getBiomeAt.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int getBiomeAt(const Generator *g, int scale, int x, int y, int z)
     * }
     */
    public static MemorySegment getBiomeAt$address() {
        return getBiomeAt.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int getBiomeAt(const Generator *g, int scale, int x, int y, int z)
     * }
     */
    public static int getBiomeAt(MemorySegment g, int scale, int x, int y, int z) {
        var mh$ = getBiomeAt.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("getBiomeAt", g, scale, x, y, z);
            }
            return (int)mh$.invokeExact(g, scale, x, y, z);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class getLayerForScale {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Cubiomes.C_POINTER,
            Cubiomes.C_POINTER,
            Cubiomes.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("getLayerForScale");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * const Layer *getLayerForScale(const Generator *g, int scale)
     * }
     */
    public static FunctionDescriptor getLayerForScale$descriptor() {
        return getLayerForScale.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * const Layer *getLayerForScale(const Generator *g, int scale)
     * }
     */
    public static MethodHandle getLayerForScale$handle() {
        return getLayerForScale.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * const Layer *getLayerForScale(const Generator *g, int scale)
     * }
     */
    public static MemorySegment getLayerForScale$address() {
        return getLayerForScale.ADDR;
    }

    /**
     * {@snippet lang=c :
     * const Layer *getLayerForScale(const Generator *g, int scale)
     * }
     */
    public static MemorySegment getLayerForScale(MemorySegment g, int scale) {
        var mh$ = getLayerForScale.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("getLayerForScale", g, scale);
            }
            return (MemorySegment)mh$.invokeExact(g, scale);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class setupLayerStack {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            Cubiomes.C_POINTER,
            Cubiomes.C_INT,
            Cubiomes.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("setupLayerStack");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void setupLayerStack(LayerStack *g, int mc, int largeBiomes)
     * }
     */
    public static FunctionDescriptor setupLayerStack$descriptor() {
        return setupLayerStack.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void setupLayerStack(LayerStack *g, int mc, int largeBiomes)
     * }
     */
    public static MethodHandle setupLayerStack$handle() {
        return setupLayerStack.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void setupLayerStack(LayerStack *g, int mc, int largeBiomes)
     * }
     */
    public static MemorySegment setupLayerStack$address() {
        return setupLayerStack.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void setupLayerStack(LayerStack *g, int mc, int largeBiomes)
     * }
     */
    public static void setupLayerStack(MemorySegment g, int mc, int largeBiomes) {
        var mh$ = setupLayerStack.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("setupLayerStack", g, mc, largeBiomes);
            }
            mh$.invokeExact(g, mc, largeBiomes);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class getMinLayerCacheSize {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Cubiomes.C_LONG,
            Cubiomes.C_POINTER,
            Cubiomes.C_INT,
            Cubiomes.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("getMinLayerCacheSize");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * size_t getMinLayerCacheSize(const Layer *layer, int sizeX, int sizeZ)
     * }
     */
    public static FunctionDescriptor getMinLayerCacheSize$descriptor() {
        return getMinLayerCacheSize.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * size_t getMinLayerCacheSize(const Layer *layer, int sizeX, int sizeZ)
     * }
     */
    public static MethodHandle getMinLayerCacheSize$handle() {
        return getMinLayerCacheSize.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * size_t getMinLayerCacheSize(const Layer *layer, int sizeX, int sizeZ)
     * }
     */
    public static MemorySegment getMinLayerCacheSize$address() {
        return getMinLayerCacheSize.ADDR;
    }

    /**
     * {@snippet lang=c :
     * size_t getMinLayerCacheSize(const Layer *layer, int sizeX, int sizeZ)
     * }
     */
    public static long getMinLayerCacheSize(MemorySegment layer, int sizeX, int sizeZ) {
        var mh$ = getMinLayerCacheSize.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("getMinLayerCacheSize", layer, sizeX, sizeZ);
            }
            return (long)mh$.invokeExact(layer, sizeX, sizeZ);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class setupLayer {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Cubiomes.C_POINTER,
            Cubiomes.C_POINTER,
            Cubiomes.C_POINTER,
            Cubiomes.C_INT,
            Cubiomes.C_CHAR,
            Cubiomes.C_CHAR,
            Cubiomes.C_LONG,
            Cubiomes.C_POINTER,
            Cubiomes.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("setupLayer");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * Layer *setupLayer(Layer *l, mapfunc_t *map, int mc, int8_t zoom, int8_t edge, uint64_t saltbase, Layer *p, Layer *p2)
     * }
     */
    public static FunctionDescriptor setupLayer$descriptor() {
        return setupLayer.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * Layer *setupLayer(Layer *l, mapfunc_t *map, int mc, int8_t zoom, int8_t edge, uint64_t saltbase, Layer *p, Layer *p2)
     * }
     */
    public static MethodHandle setupLayer$handle() {
        return setupLayer.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * Layer *setupLayer(Layer *l, mapfunc_t *map, int mc, int8_t zoom, int8_t edge, uint64_t saltbase, Layer *p, Layer *p2)
     * }
     */
    public static MemorySegment setupLayer$address() {
        return setupLayer.ADDR;
    }

    /**
     * {@snippet lang=c :
     * Layer *setupLayer(Layer *l, mapfunc_t *map, int mc, int8_t zoom, int8_t edge, uint64_t saltbase, Layer *p, Layer *p2)
     * }
     */
    public static MemorySegment setupLayer(MemorySegment l, MemorySegment map, int mc, byte zoom, byte edge, long saltbase, MemorySegment p, MemorySegment p2) {
        var mh$ = setupLayer.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("setupLayer", l, map, mc, zoom, edge, saltbase, p, p2);
            }
            return (MemorySegment)mh$.invokeExact(l, map, mc, zoom, edge, saltbase, p, p2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class genArea {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Cubiomes.C_INT,
            Cubiomes.C_POINTER,
            Cubiomes.C_POINTER,
            Cubiomes.C_INT,
            Cubiomes.C_INT,
            Cubiomes.C_INT,
            Cubiomes.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("genArea");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int genArea(const Layer *layer, int *out, int areaX, int areaZ, int areaWidth, int areaHeight)
     * }
     */
    public static FunctionDescriptor genArea$descriptor() {
        return genArea.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int genArea(const Layer *layer, int *out, int areaX, int areaZ, int areaWidth, int areaHeight)
     * }
     */
    public static MethodHandle genArea$handle() {
        return genArea.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int genArea(const Layer *layer, int *out, int areaX, int areaZ, int areaWidth, int areaHeight)
     * }
     */
    public static MemorySegment genArea$address() {
        return genArea.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int genArea(const Layer *layer, int *out, int areaX, int areaZ, int areaWidth, int areaHeight)
     * }
     */
    public static int genArea(MemorySegment layer, MemorySegment out, int areaX, int areaZ, int areaWidth, int areaHeight) {
        var mh$ = genArea.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("genArea", layer, out, areaX, areaZ, areaWidth, areaHeight);
            }
            return (int)mh$.invokeExact(layer, out, areaX, areaZ, areaWidth, areaHeight);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class mapApproxHeight {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Cubiomes.C_INT,
            Cubiomes.C_POINTER,
            Cubiomes.C_POINTER,
            Cubiomes.C_POINTER,
            Cubiomes.C_POINTER,
            Cubiomes.C_INT,
            Cubiomes.C_INT,
            Cubiomes.C_INT,
            Cubiomes.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("mapApproxHeight");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int mapApproxHeight(float *y, int *ids, const Generator *g, const SurfaceNoise *sn, int x, int z, int w, int h)
     * }
     */
    public static FunctionDescriptor mapApproxHeight$descriptor() {
        return mapApproxHeight.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int mapApproxHeight(float *y, int *ids, const Generator *g, const SurfaceNoise *sn, int x, int z, int w, int h)
     * }
     */
    public static MethodHandle mapApproxHeight$handle() {
        return mapApproxHeight.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int mapApproxHeight(float *y, int *ids, const Generator *g, const SurfaceNoise *sn, int x, int z, int w, int h)
     * }
     */
    public static MemorySegment mapApproxHeight$address() {
        return mapApproxHeight.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int mapApproxHeight(float *y, int *ids, const Generator *g, const SurfaceNoise *sn, int x, int z, int w, int h)
     * }
     */
    public static int mapApproxHeight(MemorySegment y, MemorySegment ids, MemorySegment g, MemorySegment sn, int x, int z, int w, int h) {
        var mh$ = mapApproxHeight.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("mapApproxHeight", y, ids, g, sn, x, z, w, h);
            }
            return (int)mh$.invokeExact(y, ids, g, sn, x, z, w, h);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    private static final int Feature = (int)0L;
    /**
     * {@snippet lang=c :
     * enum StructureType.Feature = 0
     * }
     */
    public static int Feature() {
        return Feature;
    }
    private static final int Desert_Pyramid = (int)1L;
    /**
     * {@snippet lang=c :
     * enum StructureType.Desert_Pyramid = 1
     * }
     */
    public static int Desert_Pyramid() {
        return Desert_Pyramid;
    }
    private static final int Jungle_Temple = (int)2L;
    /**
     * {@snippet lang=c :
     * enum StructureType.Jungle_Temple = 2
     * }
     */
    public static int Jungle_Temple() {
        return Jungle_Temple;
    }
    private static final int Jungle_Pyramid = (int)2L;
    /**
     * {@snippet lang=c :
     * enum StructureType.Jungle_Pyramid = 2
     * }
     */
    public static int Jungle_Pyramid() {
        return Jungle_Pyramid;
    }
    private static final int Swamp_Hut = (int)3L;
    /**
     * {@snippet lang=c :
     * enum StructureType.Swamp_Hut = 3
     * }
     */
    public static int Swamp_Hut() {
        return Swamp_Hut;
    }
    private static final int Igloo = (int)4L;
    /**
     * {@snippet lang=c :
     * enum StructureType.Igloo = 4
     * }
     */
    public static int Igloo() {
        return Igloo;
    }
    private static final int Village = (int)5L;
    /**
     * {@snippet lang=c :
     * enum StructureType.Village = 5
     * }
     */
    public static int Village() {
        return Village;
    }
    private static final int Ocean_Ruin = (int)6L;
    /**
     * {@snippet lang=c :
     * enum StructureType.Ocean_Ruin = 6
     * }
     */
    public static int Ocean_Ruin() {
        return Ocean_Ruin;
    }
    private static final int Shipwreck = (int)7L;
    /**
     * {@snippet lang=c :
     * enum StructureType.Shipwreck = 7
     * }
     */
    public static int Shipwreck() {
        return Shipwreck;
    }
    private static final int Monument = (int)8L;
    /**
     * {@snippet lang=c :
     * enum StructureType.Monument = 8
     * }
     */
    public static int Monument() {
        return Monument;
    }
    private static final int Mansion = (int)9L;
    /**
     * {@snippet lang=c :
     * enum StructureType.Mansion = 9
     * }
     */
    public static int Mansion() {
        return Mansion;
    }
    private static final int Outpost = (int)10L;
    /**
     * {@snippet lang=c :
     * enum StructureType.Outpost = 10
     * }
     */
    public static int Outpost() {
        return Outpost;
    }
    private static final int Ruined_Portal = (int)11L;
    /**
     * {@snippet lang=c :
     * enum StructureType.Ruined_Portal = 11
     * }
     */
    public static int Ruined_Portal() {
        return Ruined_Portal;
    }
    private static final int Ruined_Portal_N = (int)12L;
    /**
     * {@snippet lang=c :
     * enum StructureType.Ruined_Portal_N = 12
     * }
     */
    public static int Ruined_Portal_N() {
        return Ruined_Portal_N;
    }
    private static final int Ancient_City = (int)13L;
    /**
     * {@snippet lang=c :
     * enum StructureType.Ancient_City = 13
     * }
     */
    public static int Ancient_City() {
        return Ancient_City;
    }
    private static final int Treasure = (int)14L;
    /**
     * {@snippet lang=c :
     * enum StructureType.Treasure = 14
     * }
     */
    public static int Treasure() {
        return Treasure;
    }
    private static final int Mineshaft = (int)15L;
    /**
     * {@snippet lang=c :
     * enum StructureType.Mineshaft = 15
     * }
     */
    public static int Mineshaft() {
        return Mineshaft;
    }
    private static final int Desert_Well = (int)16L;
    /**
     * {@snippet lang=c :
     * enum StructureType.Desert_Well = 16
     * }
     */
    public static int Desert_Well() {
        return Desert_Well;
    }
    private static final int Geode = (int)17L;
    /**
     * {@snippet lang=c :
     * enum StructureType.Geode = 17
     * }
     */
    public static int Geode() {
        return Geode;
    }
    private static final int Fortress = (int)18L;
    /**
     * {@snippet lang=c :
     * enum StructureType.Fortress = 18
     * }
     */
    public static int Fortress() {
        return Fortress;
    }
    private static final int Bastion = (int)19L;
    /**
     * {@snippet lang=c :
     * enum StructureType.Bastion = 19
     * }
     */
    public static int Bastion() {
        return Bastion;
    }
    private static final int End_City = (int)20L;
    /**
     * {@snippet lang=c :
     * enum StructureType.End_City = 20
     * }
     */
    public static int End_City() {
        return End_City;
    }
    private static final int End_Gateway = (int)21L;
    /**
     * {@snippet lang=c :
     * enum StructureType.End_Gateway = 21
     * }
     */
    public static int End_Gateway() {
        return End_Gateway;
    }
    private static final int End_Island = (int)22L;
    /**
     * {@snippet lang=c :
     * enum StructureType.End_Island = 22
     * }
     */
    public static int End_Island() {
        return End_Island;
    }
    private static final int Trail_Ruins = (int)23L;
    /**
     * {@snippet lang=c :
     * enum StructureType.Trail_Ruins = 23
     * }
     */
    public static int Trail_Ruins() {
        return Trail_Ruins;
    }
    private static final int Trial_Chambers = (int)24L;
    /**
     * {@snippet lang=c :
     * enum StructureType.Trial_Chambers = 24
     * }
     */
    public static int Trial_Chambers() {
        return Trial_Chambers;
    }
    private static final int FEATURE_NUM = (int)25L;
    /**
     * {@snippet lang=c :
     * enum StructureType.FEATURE_NUM = 25
     * }
     */
    public static int FEATURE_NUM() {
        return FEATURE_NUM;
    }

    private static class createPos3List {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            Cubiomes.C_POINTER,
            Cubiomes.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("createPos3List");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void createPos3List(Pos3List *list, int initialCapacity)
     * }
     */
    public static FunctionDescriptor createPos3List$descriptor() {
        return createPos3List.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void createPos3List(Pos3List *list, int initialCapacity)
     * }
     */
    public static MethodHandle createPos3List$handle() {
        return createPos3List.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void createPos3List(Pos3List *list, int initialCapacity)
     * }
     */
    public static MemorySegment createPos3List$address() {
        return createPos3List.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void createPos3List(Pos3List *list, int initialCapacity)
     * }
     */
    public static void createPos3List(MemorySegment list, int initialCapacity) {
        var mh$ = createPos3List.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("createPos3List", list, initialCapacity);
            }
            mh$.invokeExact(list, initialCapacity);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class appendPos3List {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            Cubiomes.C_POINTER,
            Pos3.layout()
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("appendPos3List");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void appendPos3List(Pos3List *list, Pos3 pos3)
     * }
     */
    public static FunctionDescriptor appendPos3List$descriptor() {
        return appendPos3List.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void appendPos3List(Pos3List *list, Pos3 pos3)
     * }
     */
    public static MethodHandle appendPos3List$handle() {
        return appendPos3List.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void appendPos3List(Pos3List *list, Pos3 pos3)
     * }
     */
    public static MemorySegment appendPos3List$address() {
        return appendPos3List.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void appendPos3List(Pos3List *list, Pos3 pos3)
     * }
     */
    public static void appendPos3List(MemorySegment list, MemorySegment pos3) {
        var mh$ = appendPos3List.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("appendPos3List", list, pos3);
            }
            mh$.invokeExact(list, pos3);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class freePos3List {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            Cubiomes.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("freePos3List");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void freePos3List(Pos3List *list)
     * }
     */
    public static FunctionDescriptor freePos3List$descriptor() {
        return freePos3List.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void freePos3List(Pos3List *list)
     * }
     */
    public static MethodHandle freePos3List$handle() {
        return freePos3List.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void freePos3List(Pos3List *list)
     * }
     */
    public static MemorySegment freePos3List$address() {
        return freePos3List.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void freePos3List(Pos3List *list)
     * }
     */
    public static void freePos3List(MemorySegment list) {
        var mh$ = freePos3List.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("freePos3List", list);
            }
            mh$.invokeExact(list);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    private static final int BF_APPROX = (int)1L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.BF_APPROX = 1
     * }
     */
    public static int BF_APPROX() {
        return BF_APPROX;
    }
    private static final int BF_FORCED_OCEAN = (int)4L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.BF_FORCED_OCEAN = 4
     * }
     */
    public static int BF_FORCED_OCEAN() {
        return BF_FORCED_OCEAN;
    }

    private static class getStructureConfig {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Cubiomes.C_INT,
            Cubiomes.C_INT,
            Cubiomes.C_INT,
            Cubiomes.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("getStructureConfig");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int getStructureConfig(int structureType, int mc, StructureConfig *sconf)
     * }
     */
    public static FunctionDescriptor getStructureConfig$descriptor() {
        return getStructureConfig.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int getStructureConfig(int structureType, int mc, StructureConfig *sconf)
     * }
     */
    public static MethodHandle getStructureConfig$handle() {
        return getStructureConfig.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int getStructureConfig(int structureType, int mc, StructureConfig *sconf)
     * }
     */
    public static MemorySegment getStructureConfig$address() {
        return getStructureConfig.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int getStructureConfig(int structureType, int mc, StructureConfig *sconf)
     * }
     */
    public static int getStructureConfig(int structureType, int mc, MemorySegment sconf) {
        var mh$ = getStructureConfig.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("getStructureConfig", structureType, mc, sconf);
            }
            return (int)mh$.invokeExact(structureType, mc, sconf);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class getStructureSaltConfig {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Cubiomes.C_INT,
            Cubiomes.C_INT,
            Cubiomes.C_INT,
            Cubiomes.C_INT,
            Cubiomes.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("getStructureSaltConfig");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int getStructureSaltConfig(int structureType, int mc, int biome, StructureSaltConfig *ssconf)
     * }
     */
    public static FunctionDescriptor getStructureSaltConfig$descriptor() {
        return getStructureSaltConfig.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int getStructureSaltConfig(int structureType, int mc, int biome, StructureSaltConfig *ssconf)
     * }
     */
    public static MethodHandle getStructureSaltConfig$handle() {
        return getStructureSaltConfig.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int getStructureSaltConfig(int structureType, int mc, int biome, StructureSaltConfig *ssconf)
     * }
     */
    public static MemorySegment getStructureSaltConfig$address() {
        return getStructureSaltConfig.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int getStructureSaltConfig(int structureType, int mc, int biome, StructureSaltConfig *ssconf)
     * }
     */
    public static int getStructureSaltConfig(int structureType, int mc, int biome, MemorySegment ssconf) {
        var mh$ = getStructureSaltConfig.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("getStructureSaltConfig", structureType, mc, biome, ssconf);
            }
            return (int)mh$.invokeExact(structureType, mc, biome, ssconf);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class getStructurePos {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Cubiomes.C_INT,
            Cubiomes.C_INT,
            Cubiomes.C_INT,
            Cubiomes.C_LONG,
            Cubiomes.C_INT,
            Cubiomes.C_INT,
            Cubiomes.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("getStructurePos");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int getStructurePos(int structureType, int mc, uint64_t seed, int regX, int regZ, Pos *pos)
     * }
     */
    public static FunctionDescriptor getStructurePos$descriptor() {
        return getStructurePos.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int getStructurePos(int structureType, int mc, uint64_t seed, int regX, int regZ, Pos *pos)
     * }
     */
    public static MethodHandle getStructurePos$handle() {
        return getStructurePos.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int getStructurePos(int structureType, int mc, uint64_t seed, int regX, int regZ, Pos *pos)
     * }
     */
    public static MemorySegment getStructurePos$address() {
        return getStructurePos.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int getStructurePos(int structureType, int mc, uint64_t seed, int regX, int regZ, Pos *pos)
     * }
     */
    public static int getStructurePos(int structureType, int mc, long seed, int regX, int regZ, MemorySegment pos) {
        var mh$ = getStructurePos.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("getStructurePos", structureType, mc, seed, regX, regZ, pos);
            }
            return (int)mh$.invokeExact(structureType, mc, seed, regX, regZ, pos);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class getMineshafts {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Cubiomes.C_INT,
            Cubiomes.C_INT,
            Cubiomes.C_LONG,
            Cubiomes.C_INT,
            Cubiomes.C_INT,
            Cubiomes.C_INT,
            Cubiomes.C_INT,
            Cubiomes.C_POINTER,
            Cubiomes.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("getMineshafts");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int getMineshafts(int mc, uint64_t seed, int chunkX, int chunkZ, int chunkW, int chunkH, Pos *out, int nout)
     * }
     */
    public static FunctionDescriptor getMineshafts$descriptor() {
        return getMineshafts.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int getMineshafts(int mc, uint64_t seed, int chunkX, int chunkZ, int chunkW, int chunkH, Pos *out, int nout)
     * }
     */
    public static MethodHandle getMineshafts$handle() {
        return getMineshafts.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int getMineshafts(int mc, uint64_t seed, int chunkX, int chunkZ, int chunkW, int chunkH, Pos *out, int nout)
     * }
     */
    public static MemorySegment getMineshafts$address() {
        return getMineshafts.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int getMineshafts(int mc, uint64_t seed, int chunkX, int chunkZ, int chunkW, int chunkH, Pos *out, int nout)
     * }
     */
    public static int getMineshafts(int mc, long seed, int chunkX, int chunkZ, int chunkW, int chunkH, MemorySegment out, int nout) {
        var mh$ = getMineshafts.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("getMineshafts", mc, seed, chunkX, chunkZ, chunkW, chunkH, out, nout);
            }
            return (int)mh$.invokeExact(mc, seed, chunkX, chunkZ, chunkW, chunkH, out, nout);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class getPopulationSeed {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Cubiomes.C_LONG,
            Cubiomes.C_INT,
            Cubiomes.C_LONG,
            Cubiomes.C_INT,
            Cubiomes.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("getPopulationSeed");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * uint64_t getPopulationSeed(int mc, uint64_t ws, int x, int z)
     * }
     */
    public static FunctionDescriptor getPopulationSeed$descriptor() {
        return getPopulationSeed.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * uint64_t getPopulationSeed(int mc, uint64_t ws, int x, int z)
     * }
     */
    public static MethodHandle getPopulationSeed$handle() {
        return getPopulationSeed.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * uint64_t getPopulationSeed(int mc, uint64_t ws, int x, int z)
     * }
     */
    public static MemorySegment getPopulationSeed$address() {
        return getPopulationSeed.ADDR;
    }

    /**
     * {@snippet lang=c :
     * uint64_t getPopulationSeed(int mc, uint64_t ws, int x, int z)
     * }
     */
    public static long getPopulationSeed(int mc, long ws, int x, int z) {
        var mh$ = getPopulationSeed.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("getPopulationSeed", mc, ws, x, z);
            }
            return (long)mh$.invokeExact(mc, ws, x, z);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class getEndIslands {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Cubiomes.C_INT,
            Cubiomes.C_POINTER,
            Cubiomes.C_INT,
            Cubiomes.C_LONG,
            Cubiomes.C_INT,
            Cubiomes.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("getEndIslands");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int getEndIslands(EndIsland islands[2], int mc, uint64_t seed, int chunkX, int chunkZ)
     * }
     */
    public static FunctionDescriptor getEndIslands$descriptor() {
        return getEndIslands.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int getEndIslands(EndIsland islands[2], int mc, uint64_t seed, int chunkX, int chunkZ)
     * }
     */
    public static MethodHandle getEndIslands$handle() {
        return getEndIslands.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int getEndIslands(EndIsland islands[2], int mc, uint64_t seed, int chunkX, int chunkZ)
     * }
     */
    public static MemorySegment getEndIslands$address() {
        return getEndIslands.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int getEndIslands(EndIsland islands[2], int mc, uint64_t seed, int chunkX, int chunkZ)
     * }
     */
    public static int getEndIslands(MemorySegment islands, int mc, long seed, int chunkX, int chunkZ) {
        var mh$ = getEndIslands.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("getEndIslands", islands, mc, seed, chunkX, chunkZ);
            }
            return (int)mh$.invokeExact(islands, mc, seed, chunkX, chunkZ);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class mapEndIslandHeight {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Cubiomes.C_INT,
            Cubiomes.C_POINTER,
            Cubiomes.C_POINTER,
            Cubiomes.C_LONG,
            Cubiomes.C_INT,
            Cubiomes.C_INT,
            Cubiomes.C_INT,
            Cubiomes.C_INT,
            Cubiomes.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("mapEndIslandHeight");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int mapEndIslandHeight(float *y, const EndNoise *en, uint64_t seed, int x, int z, int w, int h, int scale)
     * }
     */
    public static FunctionDescriptor mapEndIslandHeight$descriptor() {
        return mapEndIslandHeight.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int mapEndIslandHeight(float *y, const EndNoise *en, uint64_t seed, int x, int z, int w, int h, int scale)
     * }
     */
    public static MethodHandle mapEndIslandHeight$handle() {
        return mapEndIslandHeight.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int mapEndIslandHeight(float *y, const EndNoise *en, uint64_t seed, int x, int z, int w, int h, int scale)
     * }
     */
    public static MemorySegment mapEndIslandHeight$address() {
        return mapEndIslandHeight.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int mapEndIslandHeight(float *y, const EndNoise *en, uint64_t seed, int x, int z, int w, int h, int scale)
     * }
     */
    public static int mapEndIslandHeight(MemorySegment y, MemorySegment en, long seed, int x, int z, int w, int h, int scale) {
        var mh$ = mapEndIslandHeight.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("mapEndIslandHeight", y, en, seed, x, z, w, h, scale);
            }
            return (int)mh$.invokeExact(y, en, seed, x, z, w, h, scale);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class isEndChunkEmpty {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Cubiomes.C_INT,
            Cubiomes.C_POINTER,
            Cubiomes.C_POINTER,
            Cubiomes.C_LONG,
            Cubiomes.C_INT,
            Cubiomes.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("isEndChunkEmpty");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int isEndChunkEmpty(const EndNoise *en, const SurfaceNoise *sn, uint64_t seed, int chunkX, int chunkZ)
     * }
     */
    public static FunctionDescriptor isEndChunkEmpty$descriptor() {
        return isEndChunkEmpty.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int isEndChunkEmpty(const EndNoise *en, const SurfaceNoise *sn, uint64_t seed, int chunkX, int chunkZ)
     * }
     */
    public static MethodHandle isEndChunkEmpty$handle() {
        return isEndChunkEmpty.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int isEndChunkEmpty(const EndNoise *en, const SurfaceNoise *sn, uint64_t seed, int chunkX, int chunkZ)
     * }
     */
    public static MemorySegment isEndChunkEmpty$address() {
        return isEndChunkEmpty.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int isEndChunkEmpty(const EndNoise *en, const SurfaceNoise *sn, uint64_t seed, int chunkX, int chunkZ)
     * }
     */
    public static int isEndChunkEmpty(MemorySegment en, MemorySegment sn, long seed, int chunkX, int chunkZ) {
        var mh$ = isEndChunkEmpty.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("isEndChunkEmpty", en, sn, seed, chunkX, chunkZ);
            }
            return (int)mh$.invokeExact(en, sn, seed, chunkX, chunkZ);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class initFirstStronghold {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Pos.layout(),
            Cubiomes.C_POINTER,
            Cubiomes.C_INT,
            Cubiomes.C_LONG
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("initFirstStronghold");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * Pos initFirstStronghold(StrongholdIter *sh, int mc, uint64_t s48)
     * }
     */
    public static FunctionDescriptor initFirstStronghold$descriptor() {
        return initFirstStronghold.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * Pos initFirstStronghold(StrongholdIter *sh, int mc, uint64_t s48)
     * }
     */
    public static MethodHandle initFirstStronghold$handle() {
        return initFirstStronghold.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * Pos initFirstStronghold(StrongholdIter *sh, int mc, uint64_t s48)
     * }
     */
    public static MemorySegment initFirstStronghold$address() {
        return initFirstStronghold.ADDR;
    }

    /**
     * {@snippet lang=c :
     * Pos initFirstStronghold(StrongholdIter *sh, int mc, uint64_t s48)
     * }
     */
    public static MemorySegment initFirstStronghold(SegmentAllocator allocator, MemorySegment sh, int mc, long s48) {
        var mh$ = initFirstStronghold.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("initFirstStronghold", allocator, sh, mc, s48);
            }
            return (MemorySegment)mh$.invokeExact(allocator, sh, mc, s48);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class nextStronghold {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Cubiomes.C_INT,
            Cubiomes.C_POINTER,
            Cubiomes.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("nextStronghold");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int nextStronghold(StrongholdIter *sh, const Generator *g)
     * }
     */
    public static FunctionDescriptor nextStronghold$descriptor() {
        return nextStronghold.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int nextStronghold(StrongholdIter *sh, const Generator *g)
     * }
     */
    public static MethodHandle nextStronghold$handle() {
        return nextStronghold.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int nextStronghold(StrongholdIter *sh, const Generator *g)
     * }
     */
    public static MemorySegment nextStronghold$address() {
        return nextStronghold.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int nextStronghold(StrongholdIter *sh, const Generator *g)
     * }
     */
    public static int nextStronghold(MemorySegment sh, MemorySegment g) {
        var mh$ = nextStronghold.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("nextStronghold", sh, g);
            }
            return (int)mh$.invokeExact(sh, g);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class estimateSpawn {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Pos.layout(),
            Cubiomes.C_POINTER,
            Cubiomes.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("estimateSpawn");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * Pos estimateSpawn(const Generator *g, uint64_t *rng)
     * }
     */
    public static FunctionDescriptor estimateSpawn$descriptor() {
        return estimateSpawn.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * Pos estimateSpawn(const Generator *g, uint64_t *rng)
     * }
     */
    public static MethodHandle estimateSpawn$handle() {
        return estimateSpawn.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * Pos estimateSpawn(const Generator *g, uint64_t *rng)
     * }
     */
    public static MemorySegment estimateSpawn$address() {
        return estimateSpawn.ADDR;
    }

    /**
     * {@snippet lang=c :
     * Pos estimateSpawn(const Generator *g, uint64_t *rng)
     * }
     */
    public static MemorySegment estimateSpawn(SegmentAllocator allocator, MemorySegment g, MemorySegment rng) {
        var mh$ = estimateSpawn.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("estimateSpawn", allocator, g, rng);
            }
            return (MemorySegment)mh$.invokeExact(allocator, g, rng);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class getSpawn {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Pos.layout(),
            Cubiomes.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("getSpawn");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * Pos getSpawn(const Generator *g)
     * }
     */
    public static FunctionDescriptor getSpawn$descriptor() {
        return getSpawn.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * Pos getSpawn(const Generator *g)
     * }
     */
    public static MethodHandle getSpawn$handle() {
        return getSpawn.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * Pos getSpawn(const Generator *g)
     * }
     */
    public static MemorySegment getSpawn$address() {
        return getSpawn.ADDR;
    }

    /**
     * {@snippet lang=c :
     * Pos getSpawn(const Generator *g)
     * }
     */
    public static MemorySegment getSpawn(SegmentAllocator allocator, MemorySegment g) {
        var mh$ = getSpawn.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("getSpawn", allocator, g);
            }
            return (MemorySegment)mh$.invokeExact(allocator, g);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    private static final int ANCIENT_DEBRIS = (int)0L;
    /**
     * {@snippet lang=c :
     * enum Blocks.ANCIENT_DEBRIS = 0
     * }
     */
    public static int ANCIENT_DEBRIS() {
        return ANCIENT_DEBRIS;
    }
    private static final int ANDESITE = (int)1L;
    /**
     * {@snippet lang=c :
     * enum Blocks.ANDESITE = 1
     * }
     */
    public static int ANDESITE() {
        return ANDESITE;
    }
    private static final int BASALT = (int)2L;
    /**
     * {@snippet lang=c :
     * enum Blocks.BASALT = 2
     * }
     */
    public static int BASALT() {
        return BASALT;
    }
    private static final int BLACKSTONE = (int)3L;
    /**
     * {@snippet lang=c :
     * enum Blocks.BLACKSTONE = 3
     * }
     */
    public static int BLACKSTONE() {
        return BLACKSTONE;
    }
    private static final int CLAY = (int)4L;
    /**
     * {@snippet lang=c :
     * enum Blocks.CLAY = 4
     * }
     */
    public static int CLAY() {
        return CLAY;
    }
    private static final int COAL_ORE = (int)5L;
    /**
     * {@snippet lang=c :
     * enum Blocks.COAL_ORE = 5
     * }
     */
    public static int COAL_ORE() {
        return COAL_ORE;
    }
    private static final int COPPER_ORE = (int)6L;
    /**
     * {@snippet lang=c :
     * enum Blocks.COPPER_ORE = 6
     * }
     */
    public static int COPPER_ORE() {
        return COPPER_ORE;
    }
    private static final int DEEPSLATE = (int)7L;
    /**
     * {@snippet lang=c :
     * enum Blocks.DEEPSLATE = 7
     * }
     */
    public static int DEEPSLATE() {
        return DEEPSLATE;
    }
    private static final int DIAMOND_ORE = (int)8L;
    /**
     * {@snippet lang=c :
     * enum Blocks.DIAMOND_ORE = 8
     * }
     */
    public static int DIAMOND_ORE() {
        return DIAMOND_ORE;
    }
    private static final int DIORITE = (int)9L;
    /**
     * {@snippet lang=c :
     * enum Blocks.DIORITE = 9
     * }
     */
    public static int DIORITE() {
        return DIORITE;
    }
    private static final int DIRT = (int)10L;
    /**
     * {@snippet lang=c :
     * enum Blocks.DIRT = 10
     * }
     */
    public static int DIRT() {
        return DIRT;
    }
    private static final int EMERALD_ORE = (int)11L;
    /**
     * {@snippet lang=c :
     * enum Blocks.EMERALD_ORE = 11
     * }
     */
    public static int EMERALD_ORE() {
        return EMERALD_ORE;
    }
    private static final int GOLD_ORE = (int)12L;
    /**
     * {@snippet lang=c :
     * enum Blocks.GOLD_ORE = 12
     * }
     */
    public static int GOLD_ORE() {
        return GOLD_ORE;
    }
    private static final int GRANITE = (int)13L;
    /**
     * {@snippet lang=c :
     * enum Blocks.GRANITE = 13
     * }
     */
    public static int GRANITE() {
        return GRANITE;
    }
    private static final int GRAVEL = (int)14L;
    /**
     * {@snippet lang=c :
     * enum Blocks.GRAVEL = 14
     * }
     */
    public static int GRAVEL() {
        return GRAVEL;
    }
    private static final int IRON_ORE = (int)15L;
    /**
     * {@snippet lang=c :
     * enum Blocks.IRON_ORE = 15
     * }
     */
    public static int IRON_ORE() {
        return IRON_ORE;
    }
    private static final int LAPIS_ORE = (int)16L;
    /**
     * {@snippet lang=c :
     * enum Blocks.LAPIS_ORE = 16
     * }
     */
    public static int LAPIS_ORE() {
        return LAPIS_ORE;
    }
    private static final int MAGMA_BLOCK = (int)17L;
    /**
     * {@snippet lang=c :
     * enum Blocks.MAGMA_BLOCK = 17
     * }
     */
    public static int MAGMA_BLOCK() {
        return MAGMA_BLOCK;
    }
    private static final int NETHERRACK = (int)18L;
    /**
     * {@snippet lang=c :
     * enum Blocks.NETHERRACK = 18
     * }
     */
    public static int NETHERRACK() {
        return NETHERRACK;
    }
    private static final int NETHER_GOLD_ORE = (int)19L;
    /**
     * {@snippet lang=c :
     * enum Blocks.NETHER_GOLD_ORE = 19
     * }
     */
    public static int NETHER_GOLD_ORE() {
        return NETHER_GOLD_ORE;
    }
    private static final int NETHER_QUARTZ_ORE = (int)20L;
    /**
     * {@snippet lang=c :
     * enum Blocks.NETHER_QUARTZ_ORE = 20
     * }
     */
    public static int NETHER_QUARTZ_ORE() {
        return NETHER_QUARTZ_ORE;
    }
    private static final int RAW_COPPER_BLOCK = (int)21L;
    /**
     * {@snippet lang=c :
     * enum Blocks.RAW_COPPER_BLOCK = 21
     * }
     */
    public static int RAW_COPPER_BLOCK() {
        return RAW_COPPER_BLOCK;
    }
    private static final int RAW_IRON_BLOCK = (int)22L;
    /**
     * {@snippet lang=c :
     * enum Blocks.RAW_IRON_BLOCK = 22
     * }
     */
    public static int RAW_IRON_BLOCK() {
        return RAW_IRON_BLOCK;
    }
    private static final int REDSTONE_ORE = (int)23L;
    /**
     * {@snippet lang=c :
     * enum Blocks.REDSTONE_ORE = 23
     * }
     */
    public static int REDSTONE_ORE() {
        return REDSTONE_ORE;
    }
    private static final int SOUL_SAND = (int)24L;
    /**
     * {@snippet lang=c :
     * enum Blocks.SOUL_SAND = 24
     * }
     */
    public static int SOUL_SAND() {
        return SOUL_SAND;
    }
    private static final int STONE = (int)25L;
    /**
     * {@snippet lang=c :
     * enum Blocks.STONE = 25
     * }
     */
    public static int STONE() {
        return STONE;
    }
    private static final int TUFF = (int)26L;
    /**
     * {@snippet lang=c :
     * enum Blocks.TUFF = 26
     * }
     */
    public static int TUFF() {
        return TUFF;
    }
    private static final int AndesiteOre = (int)0L;
    /**
     * {@snippet lang=c :
     * enum Ores.AndesiteOre = 0
     * }
     */
    public static int AndesiteOre() {
        return AndesiteOre;
    }
    private static final int BlackstoneOre = (int)1L;
    /**
     * {@snippet lang=c :
     * enum Ores.BlackstoneOre = 1
     * }
     */
    public static int BlackstoneOre() {
        return BlackstoneOre;
    }
    private static final int BuriedDiamondOre = (int)2L;
    /**
     * {@snippet lang=c :
     * enum Ores.BuriedDiamondOre = 2
     * }
     */
    public static int BuriedDiamondOre() {
        return BuriedDiamondOre;
    }
    private static final int BuriedLapisOre = (int)3L;
    /**
     * {@snippet lang=c :
     * enum Ores.BuriedLapisOre = 3
     * }
     */
    public static int BuriedLapisOre() {
        return BuriedLapisOre;
    }
    private static final int ClayOre = (int)4L;
    /**
     * {@snippet lang=c :
     * enum Ores.ClayOre = 4
     * }
     */
    public static int ClayOre() {
        return ClayOre;
    }
    private static final int CoalOre = (int)5L;
    /**
     * {@snippet lang=c :
     * enum Ores.CoalOre = 5
     * }
     */
    public static int CoalOre() {
        return CoalOre;
    }
    private static final int CopperOre = (int)6L;
    /**
     * {@snippet lang=c :
     * enum Ores.CopperOre = 6
     * }
     */
    public static int CopperOre() {
        return CopperOre;
    }
    private static final int DeepslateOre = (int)7L;
    /**
     * {@snippet lang=c :
     * enum Ores.DeepslateOre = 7
     * }
     */
    public static int DeepslateOre() {
        return DeepslateOre;
    }
    private static final int DeltasGoldOre = (int)8L;
    /**
     * {@snippet lang=c :
     * enum Ores.DeltasGoldOre = 8
     * }
     */
    public static int DeltasGoldOre() {
        return DeltasGoldOre;
    }
    private static final int DeltasQuartzOre = (int)9L;
    /**
     * {@snippet lang=c :
     * enum Ores.DeltasQuartzOre = 9
     * }
     */
    public static int DeltasQuartzOre() {
        return DeltasQuartzOre;
    }
    private static final int DiamondOre = (int)10L;
    /**
     * {@snippet lang=c :
     * enum Ores.DiamondOre = 10
     * }
     */
    public static int DiamondOre() {
        return DiamondOre;
    }
    private static final int DioriteOre = (int)11L;
    /**
     * {@snippet lang=c :
     * enum Ores.DioriteOre = 11
     * }
     */
    public static int DioriteOre() {
        return DioriteOre;
    }
    private static final int DirtOre = (int)12L;
    /**
     * {@snippet lang=c :
     * enum Ores.DirtOre = 12
     * }
     */
    public static int DirtOre() {
        return DirtOre;
    }
    private static final int EmeraldOre = (int)13L;
    /**
     * {@snippet lang=c :
     * enum Ores.EmeraldOre = 13
     * }
     */
    public static int EmeraldOre() {
        return EmeraldOre;
    }
    private static final int ExtraGoldOre = (int)14L;
    /**
     * {@snippet lang=c :
     * enum Ores.ExtraGoldOre = 14
     * }
     */
    public static int ExtraGoldOre() {
        return ExtraGoldOre;
    }
    private static final int GoldOre = (int)15L;
    /**
     * {@snippet lang=c :
     * enum Ores.GoldOre = 15
     * }
     */
    public static int GoldOre() {
        return GoldOre;
    }
    private static final int GraniteOre = (int)16L;
    /**
     * {@snippet lang=c :
     * enum Ores.GraniteOre = 16
     * }
     */
    public static int GraniteOre() {
        return GraniteOre;
    }
    private static final int GravelOre = (int)17L;
    /**
     * {@snippet lang=c :
     * enum Ores.GravelOre = 17
     * }
     */
    public static int GravelOre() {
        return GravelOre;
    }
    private static final int IronOre = (int)18L;
    /**
     * {@snippet lang=c :
     * enum Ores.IronOre = 18
     * }
     */
    public static int IronOre() {
        return IronOre;
    }
    private static final int LapisOre = (int)19L;
    /**
     * {@snippet lang=c :
     * enum Ores.LapisOre = 19
     * }
     */
    public static int LapisOre() {
        return LapisOre;
    }
    private static final int LargeCopperOre = (int)20L;
    /**
     * {@snippet lang=c :
     * enum Ores.LargeCopperOre = 20
     * }
     */
    public static int LargeCopperOre() {
        return LargeCopperOre;
    }
    private static final int LargeDebrisOre = (int)21L;
    /**
     * {@snippet lang=c :
     * enum Ores.LargeDebrisOre = 21
     * }
     */
    public static int LargeDebrisOre() {
        return LargeDebrisOre;
    }
    private static final int LargeDiamondOre = (int)22L;
    /**
     * {@snippet lang=c :
     * enum Ores.LargeDiamondOre = 22
     * }
     */
    public static int LargeDiamondOre() {
        return LargeDiamondOre;
    }
    private static final int LowerAndesiteOre = (int)23L;
    /**
     * {@snippet lang=c :
     * enum Ores.LowerAndesiteOre = 23
     * }
     */
    public static int LowerAndesiteOre() {
        return LowerAndesiteOre;
    }
    private static final int LowerCoalOre = (int)24L;
    /**
     * {@snippet lang=c :
     * enum Ores.LowerCoalOre = 24
     * }
     */
    public static int LowerCoalOre() {
        return LowerCoalOre;
    }
    private static final int LowerDioriteOre = (int)25L;
    /**
     * {@snippet lang=c :
     * enum Ores.LowerDioriteOre = 25
     * }
     */
    public static int LowerDioriteOre() {
        return LowerDioriteOre;
    }
    private static final int LowerGoldOre = (int)26L;
    /**
     * {@snippet lang=c :
     * enum Ores.LowerGoldOre = 26
     * }
     */
    public static int LowerGoldOre() {
        return LowerGoldOre;
    }
    private static final int LowerGraniteOre = (int)27L;
    /**
     * {@snippet lang=c :
     * enum Ores.LowerGraniteOre = 27
     * }
     */
    public static int LowerGraniteOre() {
        return LowerGraniteOre;
    }
    private static final int LowerRedstoneOre = (int)28L;
    /**
     * {@snippet lang=c :
     * enum Ores.LowerRedstoneOre = 28
     * }
     */
    public static int LowerRedstoneOre() {
        return LowerRedstoneOre;
    }
    private static final int MagmaOre = (int)29L;
    /**
     * {@snippet lang=c :
     * enum Ores.MagmaOre = 29
     * }
     */
    public static int MagmaOre() {
        return MagmaOre;
    }
    private static final int MediumDiamondOre = (int)30L;
    /**
     * {@snippet lang=c :
     * enum Ores.MediumDiamondOre = 30
     * }
     */
    public static int MediumDiamondOre() {
        return MediumDiamondOre;
    }
    private static final int MiddleIronOre = (int)31L;
    /**
     * {@snippet lang=c :
     * enum Ores.MiddleIronOre = 31
     * }
     */
    public static int MiddleIronOre() {
        return MiddleIronOre;
    }
    private static final int NetherGoldOre = (int)32L;
    /**
     * {@snippet lang=c :
     * enum Ores.NetherGoldOre = 32
     * }
     */
    public static int NetherGoldOre() {
        return NetherGoldOre;
    }
    private static final int NetherGravelOre = (int)33L;
    /**
     * {@snippet lang=c :
     * enum Ores.NetherGravelOre = 33
     * }
     */
    public static int NetherGravelOre() {
        return NetherGravelOre;
    }
    private static final int NetherQuartzOre = (int)34L;
    /**
     * {@snippet lang=c :
     * enum Ores.NetherQuartzOre = 34
     * }
     */
    public static int NetherQuartzOre() {
        return NetherQuartzOre;
    }
    private static final int RedstoneOre = (int)35L;
    /**
     * {@snippet lang=c :
     * enum Ores.RedstoneOre = 35
     * }
     */
    public static int RedstoneOre() {
        return RedstoneOre;
    }
    private static final int SmallDebrisOre = (int)36L;
    /**
     * {@snippet lang=c :
     * enum Ores.SmallDebrisOre = 36
     * }
     */
    public static int SmallDebrisOre() {
        return SmallDebrisOre;
    }
    private static final int SmallIronOre = (int)37L;
    /**
     * {@snippet lang=c :
     * enum Ores.SmallIronOre = 37
     * }
     */
    public static int SmallIronOre() {
        return SmallIronOre;
    }
    private static final int SoulSandOre = (int)38L;
    /**
     * {@snippet lang=c :
     * enum Ores.SoulSandOre = 38
     * }
     */
    public static int SoulSandOre() {
        return SoulSandOre;
    }
    private static final int TuffOre = (int)39L;
    /**
     * {@snippet lang=c :
     * enum Ores.TuffOre = 39
     * }
     */
    public static int TuffOre() {
        return TuffOre;
    }
    private static final int UpperAndesiteOre = (int)40L;
    /**
     * {@snippet lang=c :
     * enum Ores.UpperAndesiteOre = 40
     * }
     */
    public static int UpperAndesiteOre() {
        return UpperAndesiteOre;
    }
    private static final int UpperCoalOre = (int)41L;
    /**
     * {@snippet lang=c :
     * enum Ores.UpperCoalOre = 41
     * }
     */
    public static int UpperCoalOre() {
        return UpperCoalOre;
    }
    private static final int UpperDioriteOre = (int)42L;
    /**
     * {@snippet lang=c :
     * enum Ores.UpperDioriteOre = 42
     * }
     */
    public static int UpperDioriteOre() {
        return UpperDioriteOre;
    }
    private static final int UpperGraniteOre = (int)43L;
    /**
     * {@snippet lang=c :
     * enum Ores.UpperGraniteOre = 43
     * }
     */
    public static int UpperGraniteOre() {
        return UpperGraniteOre;
    }
    private static final int UpperIronOre = (int)44L;
    /**
     * {@snippet lang=c :
     * enum Ores.UpperIronOre = 44
     * }
     */
    public static int UpperIronOre() {
        return UpperIronOre;
    }

    private static class getOreConfig {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Cubiomes.C_INT,
            Cubiomes.C_INT,
            Cubiomes.C_INT,
            Cubiomes.C_INT,
            Cubiomes.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("getOreConfig");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int getOreConfig(int oreType, int mc, int biomeID, OreConfig *oconf)
     * }
     */
    public static FunctionDescriptor getOreConfig$descriptor() {
        return getOreConfig.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int getOreConfig(int oreType, int mc, int biomeID, OreConfig *oconf)
     * }
     */
    public static MethodHandle getOreConfig$handle() {
        return getOreConfig.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int getOreConfig(int oreType, int mc, int biomeID, OreConfig *oconf)
     * }
     */
    public static MemorySegment getOreConfig$address() {
        return getOreConfig.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int getOreConfig(int oreType, int mc, int biomeID, OreConfig *oconf)
     * }
     */
    public static int getOreConfig(int oreType, int mc, int biomeID, MemorySegment oconf) {
        var mh$ = getOreConfig.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("getOreConfig", oreType, mc, biomeID, oconf);
            }
            return (int)mh$.invokeExact(oreType, mc, biomeID, oconf);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class getBiomeForOreGen {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Cubiomes.C_INT,
            Cubiomes.C_POINTER,
            Cubiomes.C_INT,
            Cubiomes.C_INT,
            Cubiomes.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("getBiomeForOreGen");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int getBiomeForOreGen(const Generator *g, int chunkX, int chunkZ, int y)
     * }
     */
    public static FunctionDescriptor getBiomeForOreGen$descriptor() {
        return getBiomeForOreGen.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int getBiomeForOreGen(const Generator *g, int chunkX, int chunkZ, int y)
     * }
     */
    public static MethodHandle getBiomeForOreGen$handle() {
        return getBiomeForOreGen.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int getBiomeForOreGen(const Generator *g, int chunkX, int chunkZ, int y)
     * }
     */
    public static MemorySegment getBiomeForOreGen$address() {
        return getBiomeForOreGen.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int getBiomeForOreGen(const Generator *g, int chunkX, int chunkZ, int y)
     * }
     */
    public static int getBiomeForOreGen(MemorySegment g, int chunkX, int chunkZ, int y) {
        var mh$ = getBiomeForOreGen.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("getBiomeForOreGen", g, chunkX, chunkZ, y);
            }
            return (int)mh$.invokeExact(g, chunkX, chunkZ, y);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class isViableOreBiome {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Cubiomes.C_INT,
            Cubiomes.C_INT,
            Cubiomes.C_INT,
            Cubiomes.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("isViableOreBiome");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int isViableOreBiome(int mc, int oreType, int biomeID)
     * }
     */
    public static FunctionDescriptor isViableOreBiome$descriptor() {
        return isViableOreBiome.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int isViableOreBiome(int mc, int oreType, int biomeID)
     * }
     */
    public static MethodHandle isViableOreBiome$handle() {
        return isViableOreBiome.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int isViableOreBiome(int mc, int oreType, int biomeID)
     * }
     */
    public static MemorySegment isViableOreBiome$address() {
        return isViableOreBiome.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int isViableOreBiome(int mc, int oreType, int biomeID)
     * }
     */
    public static int isViableOreBiome(int mc, int oreType, int biomeID) {
        var mh$ = isViableOreBiome.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("isViableOreBiome", mc, oreType, biomeID);
            }
            return (int)mh$.invokeExact(mc, oreType, biomeID);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class generateOres {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Pos3List.layout(),
            Cubiomes.C_POINTER,
            Cubiomes.C_POINTER,
            OreConfig.layout(),
            Cubiomes.C_INT,
            Cubiomes.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("generateOres");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * Pos3List generateOres(const Generator *g, const SurfaceNoise *sn, OreConfig config, int chunkX, int chunkZ)
     * }
     */
    public static FunctionDescriptor generateOres$descriptor() {
        return generateOres.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * Pos3List generateOres(const Generator *g, const SurfaceNoise *sn, OreConfig config, int chunkX, int chunkZ)
     * }
     */
    public static MethodHandle generateOres$handle() {
        return generateOres.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * Pos3List generateOres(const Generator *g, const SurfaceNoise *sn, OreConfig config, int chunkX, int chunkZ)
     * }
     */
    public static MemorySegment generateOres$address() {
        return generateOres.ADDR;
    }

    /**
     * {@snippet lang=c :
     * Pos3List generateOres(const Generator *g, const SurfaceNoise *sn, OreConfig config, int chunkX, int chunkZ)
     * }
     */
    public static MemorySegment generateOres(SegmentAllocator allocator, MemorySegment g, MemorySegment sn, MemorySegment config, int chunkX, int chunkZ) {
        var mh$ = generateOres.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("generateOres", allocator, g, sn, config, chunkX, chunkZ);
            }
            return (MemorySegment)mh$.invokeExact(allocator, g, sn, config, chunkX, chunkZ);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class generateBaseOrePosition {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Pos3.layout(),
            Cubiomes.C_INT,
            OreConfig.layout(),
            Cubiomes.C_INT,
            Cubiomes.C_INT,
            RandomSource.layout()
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("generateBaseOrePosition");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * Pos3 generateBaseOrePosition(int mc, OreConfig config, int chunkX, int chunkZ, RandomSource rnd)
     * }
     */
    public static FunctionDescriptor generateBaseOrePosition$descriptor() {
        return generateBaseOrePosition.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * Pos3 generateBaseOrePosition(int mc, OreConfig config, int chunkX, int chunkZ, RandomSource rnd)
     * }
     */
    public static MethodHandle generateBaseOrePosition$handle() {
        return generateBaseOrePosition.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * Pos3 generateBaseOrePosition(int mc, OreConfig config, int chunkX, int chunkZ, RandomSource rnd)
     * }
     */
    public static MemorySegment generateBaseOrePosition$address() {
        return generateBaseOrePosition.ADDR;
    }

    /**
     * {@snippet lang=c :
     * Pos3 generateBaseOrePosition(int mc, OreConfig config, int chunkX, int chunkZ, RandomSource rnd)
     * }
     */
    public static MemorySegment generateBaseOrePosition(SegmentAllocator allocator, int mc, MemorySegment config, int chunkX, int chunkZ, MemorySegment rnd) {
        var mh$ = generateBaseOrePosition.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("generateBaseOrePosition", allocator, mc, config, chunkX, chunkZ, rnd);
            }
            return (MemorySegment)mh$.invokeExact(allocator, mc, config, chunkX, chunkZ, rnd);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class generateOrePositions {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            Cubiomes.C_POINTER,
            Cubiomes.C_POINTER,
            OreConfig.layout(),
            Pos3.layout(),
            RandomSource.layout(),
            Cubiomes.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("generateOrePositions");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void generateOrePositions(const Generator *g, const SurfaceNoise *sn, OreConfig config, Pos3 pos, RandomSource rnd, Pos3List *pos3s)
     * }
     */
    public static FunctionDescriptor generateOrePositions$descriptor() {
        return generateOrePositions.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void generateOrePositions(const Generator *g, const SurfaceNoise *sn, OreConfig config, Pos3 pos, RandomSource rnd, Pos3List *pos3s)
     * }
     */
    public static MethodHandle generateOrePositions$handle() {
        return generateOrePositions.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void generateOrePositions(const Generator *g, const SurfaceNoise *sn, OreConfig config, Pos3 pos, RandomSource rnd, Pos3List *pos3s)
     * }
     */
    public static MemorySegment generateOrePositions$address() {
        return generateOrePositions.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void generateOrePositions(const Generator *g, const SurfaceNoise *sn, OreConfig config, Pos3 pos, RandomSource rnd, Pos3List *pos3s)
     * }
     */
    public static void generateOrePositions(MemorySegment g, MemorySegment sn, MemorySegment config, MemorySegment pos, MemorySegment rnd, MemorySegment pos3s) {
        var mh$ = generateOrePositions.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("generateOrePositions", g, sn, config, pos, rnd, pos3s);
            }
            mh$.invokeExact(g, sn, config, pos, rnd, pos3s);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class generateVeinPart {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            Cubiomes.C_INT,
            OreConfig.layout(),
            RandomSource.layout(),
            Cubiomes.C_DOUBLE,
            Cubiomes.C_DOUBLE,
            Cubiomes.C_DOUBLE,
            Cubiomes.C_DOUBLE,
            Cubiomes.C_DOUBLE,
            Cubiomes.C_DOUBLE,
            Cubiomes.C_INT,
            Cubiomes.C_INT,
            Cubiomes.C_INT,
            Cubiomes.C_INT,
            Cubiomes.C_INT,
            Cubiomes.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("generateVeinPart");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void generateVeinPart(int mc, OreConfig config, RandomSource rnd, double offsetXPos, double offsetXNeg, double offsetZPos, double offsetZNeg, double offsetYPos, double offsetYNeg, int startX, int startY, int startZ, int oreSize, int radius, Pos3List *pos3s)
     * }
     */
    public static FunctionDescriptor generateVeinPart$descriptor() {
        return generateVeinPart.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void generateVeinPart(int mc, OreConfig config, RandomSource rnd, double offsetXPos, double offsetXNeg, double offsetZPos, double offsetZNeg, double offsetYPos, double offsetYNeg, int startX, int startY, int startZ, int oreSize, int radius, Pos3List *pos3s)
     * }
     */
    public static MethodHandle generateVeinPart$handle() {
        return generateVeinPart.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void generateVeinPart(int mc, OreConfig config, RandomSource rnd, double offsetXPos, double offsetXNeg, double offsetZPos, double offsetZNeg, double offsetYPos, double offsetYNeg, int startX, int startY, int startZ, int oreSize, int radius, Pos3List *pos3s)
     * }
     */
    public static MemorySegment generateVeinPart$address() {
        return generateVeinPart.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void generateVeinPart(int mc, OreConfig config, RandomSource rnd, double offsetXPos, double offsetXNeg, double offsetZPos, double offsetZNeg, double offsetYPos, double offsetYNeg, int startX, int startY, int startZ, int oreSize, int radius, Pos3List *pos3s)
     * }
     */
    public static void generateVeinPart(int mc, MemorySegment config, MemorySegment rnd, double offsetXPos, double offsetXNeg, double offsetZPos, double offsetZNeg, double offsetYPos, double offsetYNeg, int startX, int startY, int startZ, int oreSize, int radius, MemorySegment pos3s) {
        var mh$ = generateVeinPart.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("generateVeinPart", mc, config, rnd, offsetXPos, offsetXNeg, offsetZPos, offsetZNeg, offsetYPos, offsetYNeg, startX, startY, startZ, oreSize, radius, pos3s);
            }
            mh$.invokeExact(mc, config, rnd, offsetXPos, offsetXNeg, offsetZPos, offsetZNeg, offsetYPos, offsetYNeg, startX, startY, startZ, oreSize, radius, pos3s);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    private static final int CopperVein = (int)0L;
    /**
     * {@snippet lang=c :
     * enum OreVeins.CopperVein = 0
     * }
     */
    public static int CopperVein() {
        return CopperVein;
    }
    private static final int IronVein = (int)1L;
    /**
     * {@snippet lang=c :
     * enum OreVeins.IronVein = 1
     * }
     */
    public static int IronVein() {
        return IronVein;
    }

    private static class initOreVeinNoise {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Cubiomes.C_INT,
            Cubiomes.C_POINTER,
            Cubiomes.C_LONG,
            Cubiomes.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("initOreVeinNoise");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int initOreVeinNoise(OreVeinParameters *params, uint64_t ws, int mc)
     * }
     */
    public static FunctionDescriptor initOreVeinNoise$descriptor() {
        return initOreVeinNoise.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int initOreVeinNoise(OreVeinParameters *params, uint64_t ws, int mc)
     * }
     */
    public static MethodHandle initOreVeinNoise$handle() {
        return initOreVeinNoise.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int initOreVeinNoise(OreVeinParameters *params, uint64_t ws, int mc)
     * }
     */
    public static MemorySegment initOreVeinNoise$address() {
        return initOreVeinNoise.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int initOreVeinNoise(OreVeinParameters *params, uint64_t ws, int mc)
     * }
     */
    public static int initOreVeinNoise(MemorySegment params, long ws, int mc) {
        var mh$ = initOreVeinNoise.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("initOreVeinNoise", params, ws, mc);
            }
            return (int)mh$.invokeExact(params, ws, mc);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class getOreVeinBlockAt {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Cubiomes.C_INT,
            Cubiomes.C_INT,
            Cubiomes.C_INT,
            Cubiomes.C_INT,
            Cubiomes.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("getOreVeinBlockAt");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int32_t getOreVeinBlockAt(int x, int y, int z, OreVeinParameters *params)
     * }
     */
    public static FunctionDescriptor getOreVeinBlockAt$descriptor() {
        return getOreVeinBlockAt.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int32_t getOreVeinBlockAt(int x, int y, int z, OreVeinParameters *params)
     * }
     */
    public static MethodHandle getOreVeinBlockAt$handle() {
        return getOreVeinBlockAt.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int32_t getOreVeinBlockAt(int x, int y, int z, OreVeinParameters *params)
     * }
     */
    public static MemorySegment getOreVeinBlockAt$address() {
        return getOreVeinBlockAt.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int32_t getOreVeinBlockAt(int x, int y, int z, OreVeinParameters *params)
     * }
     */
    public static int getOreVeinBlockAt(int x, int y, int z, MemorySegment params) {
        var mh$ = getOreVeinBlockAt.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("getOreVeinBlockAt", x, y, z, params);
            }
            return (int)mh$.invokeExact(x, y, z, params);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    private static final int CANYON_CARVER = (int)0L;
    /**
     * {@snippet lang=c :
     * enum CanyonCarvers.CANYON_CARVER = 0
     * }
     */
    public static int CANYON_CARVER() {
        return CANYON_CARVER;
    }
    private static final int UNDERWATER_CANYON_CARVER = (int)1L;
    /**
     * {@snippet lang=c :
     * enum CanyonCarvers.UNDERWATER_CANYON_CARVER = 1
     * }
     */
    public static int UNDERWATER_CANYON_CARVER() {
        return UNDERWATER_CANYON_CARVER;
    }
    private static final int CAVE_CARVER = (int)0L;
    /**
     * {@snippet lang=c :
     * enum CaveCarvers.CAVE_CARVER = 0
     * }
     */
    public static int CAVE_CARVER() {
        return CAVE_CARVER;
    }
    private static final int CAVE_EXTRA_UNDERGROUND_CARVER = (int)1L;
    /**
     * {@snippet lang=c :
     * enum CaveCarvers.CAVE_EXTRA_UNDERGROUND_CARVER = 1
     * }
     */
    public static int CAVE_EXTRA_UNDERGROUND_CARVER() {
        return CAVE_EXTRA_UNDERGROUND_CARVER;
    }
    private static final int OCEAN_CAVE_CARVER = (int)2L;
    /**
     * {@snippet lang=c :
     * enum CaveCarvers.OCEAN_CAVE_CARVER = 2
     * }
     */
    public static int OCEAN_CAVE_CARVER() {
        return OCEAN_CAVE_CARVER;
    }
    private static final int UNDERWATER_CAVE_CARVER = (int)3L;
    /**
     * {@snippet lang=c :
     * enum CaveCarvers.UNDERWATER_CAVE_CARVER = 3
     * }
     */
    public static int UNDERWATER_CAVE_CARVER() {
        return UNDERWATER_CAVE_CARVER;
    }
    private static final int NETHER_CAVE_CARVER = (int)4L;
    /**
     * {@snippet lang=c :
     * enum CaveCarvers.NETHER_CAVE_CARVER = 4
     * }
     */
    public static int NETHER_CAVE_CARVER() {
        return NETHER_CAVE_CARVER;
    }

    private static class getCanyonCarverConfig {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Cubiomes.C_INT,
            Cubiomes.C_INT,
            Cubiomes.C_INT,
            Cubiomes.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("getCanyonCarverConfig");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int getCanyonCarverConfig(int canyonCarverType, int mc, CanyonCarverConfig *cconf)
     * }
     */
    public static FunctionDescriptor getCanyonCarverConfig$descriptor() {
        return getCanyonCarverConfig.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int getCanyonCarverConfig(int canyonCarverType, int mc, CanyonCarverConfig *cconf)
     * }
     */
    public static MethodHandle getCanyonCarverConfig$handle() {
        return getCanyonCarverConfig.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int getCanyonCarverConfig(int canyonCarverType, int mc, CanyonCarverConfig *cconf)
     * }
     */
    public static MemorySegment getCanyonCarverConfig$address() {
        return getCanyonCarverConfig.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int getCanyonCarverConfig(int canyonCarverType, int mc, CanyonCarverConfig *cconf)
     * }
     */
    public static int getCanyonCarverConfig(int canyonCarverType, int mc, MemorySegment cconf) {
        var mh$ = getCanyonCarverConfig.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("getCanyonCarverConfig", canyonCarverType, mc, cconf);
            }
            return (int)mh$.invokeExact(canyonCarverType, mc, cconf);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class isViableCanyonBiome {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Cubiomes.C_INT,
            Cubiomes.C_INT,
            Cubiomes.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("isViableCanyonBiome");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int isViableCanyonBiome(int canyonCarverType, int biome)
     * }
     */
    public static FunctionDescriptor isViableCanyonBiome$descriptor() {
        return isViableCanyonBiome.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int isViableCanyonBiome(int canyonCarverType, int biome)
     * }
     */
    public static MethodHandle isViableCanyonBiome$handle() {
        return isViableCanyonBiome.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int isViableCanyonBiome(int canyonCarverType, int biome)
     * }
     */
    public static MemorySegment isViableCanyonBiome$address() {
        return isViableCanyonBiome.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int isViableCanyonBiome(int canyonCarverType, int biome)
     * }
     */
    public static int isViableCanyonBiome(int canyonCarverType, int biome) {
        var mh$ = isViableCanyonBiome.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("isViableCanyonBiome", canyonCarverType, biome);
            }
            return (int)mh$.invokeExact(canyonCarverType, biome);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class getCaveCarverConfig {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Cubiomes.C_INT,
            Cubiomes.C_INT,
            Cubiomes.C_INT,
            Cubiomes.C_INT,
            Cubiomes.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("getCaveCarverConfig");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int getCaveCarverConfig(int caveCarverType, int mc, int biome, CaveCarverConfig *cconf)
     * }
     */
    public static FunctionDescriptor getCaveCarverConfig$descriptor() {
        return getCaveCarverConfig.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int getCaveCarverConfig(int caveCarverType, int mc, int biome, CaveCarverConfig *cconf)
     * }
     */
    public static MethodHandle getCaveCarverConfig$handle() {
        return getCaveCarverConfig.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int getCaveCarverConfig(int caveCarverType, int mc, int biome, CaveCarverConfig *cconf)
     * }
     */
    public static MemorySegment getCaveCarverConfig$address() {
        return getCaveCarverConfig.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int getCaveCarverConfig(int caveCarverType, int mc, int biome, CaveCarverConfig *cconf)
     * }
     */
    public static int getCaveCarverConfig(int caveCarverType, int mc, int biome, MemorySegment cconf) {
        var mh$ = getCaveCarverConfig.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("getCaveCarverConfig", caveCarverType, mc, biome, cconf);
            }
            return (int)mh$.invokeExact(caveCarverType, mc, biome, cconf);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class isViableCaveBiome {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Cubiomes.C_INT,
            Cubiomes.C_INT,
            Cubiomes.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("isViableCaveBiome");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int isViableCaveBiome(int caveCarverType, int biome)
     * }
     */
    public static FunctionDescriptor isViableCaveBiome$descriptor() {
        return isViableCaveBiome.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int isViableCaveBiome(int caveCarverType, int biome)
     * }
     */
    public static MethodHandle isViableCaveBiome$handle() {
        return isViableCaveBiome.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int isViableCaveBiome(int caveCarverType, int biome)
     * }
     */
    public static MemorySegment isViableCaveBiome$address() {
        return isViableCaveBiome.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int isViableCaveBiome(int caveCarverType, int biome)
     * }
     */
    public static int isViableCaveBiome(int caveCarverType, int biome) {
        var mh$ = isViableCaveBiome.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("isViableCaveBiome", caveCarverType, biome);
            }
            return (int)mh$.invokeExact(caveCarverType, biome);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class checkCanyonStart {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Cubiomes.C_INT,
            Cubiomes.C_LONG,
            Cubiomes.C_INT,
            Cubiomes.C_INT,
            CanyonCarverConfig.layout(),
            Cubiomes.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("checkCanyonStart");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int checkCanyonStart(uint64_t seed, int chunkX, int chunkZ, CanyonCarverConfig ccc, uint64_t *rnd)
     * }
     */
    public static FunctionDescriptor checkCanyonStart$descriptor() {
        return checkCanyonStart.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int checkCanyonStart(uint64_t seed, int chunkX, int chunkZ, CanyonCarverConfig ccc, uint64_t *rnd)
     * }
     */
    public static MethodHandle checkCanyonStart$handle() {
        return checkCanyonStart.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int checkCanyonStart(uint64_t seed, int chunkX, int chunkZ, CanyonCarverConfig ccc, uint64_t *rnd)
     * }
     */
    public static MemorySegment checkCanyonStart$address() {
        return checkCanyonStart.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int checkCanyonStart(uint64_t seed, int chunkX, int chunkZ, CanyonCarverConfig ccc, uint64_t *rnd)
     * }
     */
    public static int checkCanyonStart(long seed, int chunkX, int chunkZ, MemorySegment ccc, MemorySegment rnd) {
        var mh$ = checkCanyonStart.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("checkCanyonStart", seed, chunkX, chunkZ, ccc, rnd);
            }
            return (int)mh$.invokeExact(seed, chunkX, chunkZ, ccc, rnd);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class checkCaveStart {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Cubiomes.C_INT,
            Cubiomes.C_LONG,
            Cubiomes.C_INT,
            Cubiomes.C_INT,
            CaveCarverConfig.layout(),
            Cubiomes.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("checkCaveStart");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int checkCaveStart(uint64_t seed, int chunkX, int chunkZ, CaveCarverConfig ccc, uint64_t *rnd)
     * }
     */
    public static FunctionDescriptor checkCaveStart$descriptor() {
        return checkCaveStart.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int checkCaveStart(uint64_t seed, int chunkX, int chunkZ, CaveCarverConfig ccc, uint64_t *rnd)
     * }
     */
    public static MethodHandle checkCaveStart$handle() {
        return checkCaveStart.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int checkCaveStart(uint64_t seed, int chunkX, int chunkZ, CaveCarverConfig ccc, uint64_t *rnd)
     * }
     */
    public static MemorySegment checkCaveStart$address() {
        return checkCaveStart.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int checkCaveStart(uint64_t seed, int chunkX, int chunkZ, CaveCarverConfig ccc, uint64_t *rnd)
     * }
     */
    public static int checkCaveStart(long seed, int chunkX, int chunkZ, MemorySegment ccc, MemorySegment rnd) {
        var mh$ = checkCaveStart.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("checkCaveStart", seed, chunkX, chunkZ, ccc, rnd);
            }
            return (int)mh$.invokeExact(seed, chunkX, chunkZ, ccc, rnd);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class carveCanyon {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Pos3List.layout(),
            Cubiomes.C_LONG,
            Cubiomes.C_INT,
            Cubiomes.C_INT,
            CanyonCarverConfig.layout()
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("carveCanyon");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * Pos3List carveCanyon(uint64_t seed, int chunkX, int chunkZ, CanyonCarverConfig ccc)
     * }
     */
    public static FunctionDescriptor carveCanyon$descriptor() {
        return carveCanyon.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * Pos3List carveCanyon(uint64_t seed, int chunkX, int chunkZ, CanyonCarverConfig ccc)
     * }
     */
    public static MethodHandle carveCanyon$handle() {
        return carveCanyon.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * Pos3List carveCanyon(uint64_t seed, int chunkX, int chunkZ, CanyonCarverConfig ccc)
     * }
     */
    public static MemorySegment carveCanyon$address() {
        return carveCanyon.ADDR;
    }

    /**
     * {@snippet lang=c :
     * Pos3List carveCanyon(uint64_t seed, int chunkX, int chunkZ, CanyonCarverConfig ccc)
     * }
     */
    public static MemorySegment carveCanyon(SegmentAllocator allocator, long seed, int chunkX, int chunkZ, MemorySegment ccc) {
        var mh$ = carveCanyon.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("carveCanyon", allocator, seed, chunkX, chunkZ, ccc);
            }
            return (MemorySegment)mh$.invokeExact(allocator, seed, chunkX, chunkZ, ccc);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class carveCave {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Pos3List.layout(),
            Cubiomes.C_LONG,
            Cubiomes.C_INT,
            Cubiomes.C_INT,
            CaveCarverConfig.layout()
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("carveCave");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * Pos3List carveCave(uint64_t seed, int chunkX, int chunkZ, CaveCarverConfig ccc)
     * }
     */
    public static FunctionDescriptor carveCave$descriptor() {
        return carveCave.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * Pos3List carveCave(uint64_t seed, int chunkX, int chunkZ, CaveCarverConfig ccc)
     * }
     */
    public static MethodHandle carveCave$handle() {
        return carveCave.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * Pos3List carveCave(uint64_t seed, int chunkX, int chunkZ, CaveCarverConfig ccc)
     * }
     */
    public static MemorySegment carveCave$address() {
        return carveCave.ADDR;
    }

    /**
     * {@snippet lang=c :
     * Pos3List carveCave(uint64_t seed, int chunkX, int chunkZ, CaveCarverConfig ccc)
     * }
     */
    public static MemorySegment carveCave(SegmentAllocator allocator, long seed, int chunkX, int chunkZ, MemorySegment ccc) {
        var mh$ = carveCave.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("carveCave", allocator, seed, chunkX, chunkZ, ccc);
            }
            return (MemorySegment)mh$.invokeExact(allocator, seed, chunkX, chunkZ, ccc);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class locateBiome {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Pos.layout(),
            Cubiomes.C_POINTER,
            Cubiomes.C_INT,
            Cubiomes.C_INT,
            Cubiomes.C_INT,
            Cubiomes.C_INT,
            Cubiomes.C_LONG,
            Cubiomes.C_LONG,
            Cubiomes.C_POINTER,
            Cubiomes.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("locateBiome");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * Pos locateBiome(const Generator *g, int x, int y, int z, int radius, uint64_t validB, uint64_t validM, uint64_t *rng, int *passes)
     * }
     */
    public static FunctionDescriptor locateBiome$descriptor() {
        return locateBiome.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * Pos locateBiome(const Generator *g, int x, int y, int z, int radius, uint64_t validB, uint64_t validM, uint64_t *rng, int *passes)
     * }
     */
    public static MethodHandle locateBiome$handle() {
        return locateBiome.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * Pos locateBiome(const Generator *g, int x, int y, int z, int radius, uint64_t validB, uint64_t validM, uint64_t *rng, int *passes)
     * }
     */
    public static MemorySegment locateBiome$address() {
        return locateBiome.ADDR;
    }

    /**
     * {@snippet lang=c :
     * Pos locateBiome(const Generator *g, int x, int y, int z, int radius, uint64_t validB, uint64_t validM, uint64_t *rng, int *passes)
     * }
     */
    public static MemorySegment locateBiome(SegmentAllocator allocator, MemorySegment g, int x, int y, int z, int radius, long validB, long validM, MemorySegment rng, MemorySegment passes) {
        var mh$ = locateBiome.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("locateBiome", allocator, g, x, y, z, radius, validB, validM, rng, passes);
            }
            return (MemorySegment)mh$.invokeExact(allocator, g, x, y, z, radius, validB, validM, rng, passes);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class isViableStructurePos {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Cubiomes.C_INT,
            Cubiomes.C_INT,
            Cubiomes.C_POINTER,
            Cubiomes.C_INT,
            Cubiomes.C_INT,
            Cubiomes.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("isViableStructurePos");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int isViableStructurePos(int structType, Generator *g, int blockX, int blockZ, uint32_t flags)
     * }
     */
    public static FunctionDescriptor isViableStructurePos$descriptor() {
        return isViableStructurePos.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int isViableStructurePos(int structType, Generator *g, int blockX, int blockZ, uint32_t flags)
     * }
     */
    public static MethodHandle isViableStructurePos$handle() {
        return isViableStructurePos.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int isViableStructurePos(int structType, Generator *g, int blockX, int blockZ, uint32_t flags)
     * }
     */
    public static MemorySegment isViableStructurePos$address() {
        return isViableStructurePos.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int isViableStructurePos(int structType, Generator *g, int blockX, int blockZ, uint32_t flags)
     * }
     */
    public static int isViableStructurePos(int structType, MemorySegment g, int blockX, int blockZ, int flags) {
        var mh$ = isViableStructurePos.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("isViableStructurePos", structType, g, blockX, blockZ, flags);
            }
            return (int)mh$.invokeExact(structType, g, blockX, blockZ, flags);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class isViableFeatureBiome {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Cubiomes.C_INT,
            Cubiomes.C_INT,
            Cubiomes.C_INT,
            Cubiomes.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("isViableFeatureBiome");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int isViableFeatureBiome(int mc, int structureType, int biomeID)
     * }
     */
    public static FunctionDescriptor isViableFeatureBiome$descriptor() {
        return isViableFeatureBiome.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int isViableFeatureBiome(int mc, int structureType, int biomeID)
     * }
     */
    public static MethodHandle isViableFeatureBiome$handle() {
        return isViableFeatureBiome.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int isViableFeatureBiome(int mc, int structureType, int biomeID)
     * }
     */
    public static MemorySegment isViableFeatureBiome$address() {
        return isViableFeatureBiome.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int isViableFeatureBiome(int mc, int structureType, int biomeID)
     * }
     */
    public static int isViableFeatureBiome(int mc, int structureType, int biomeID) {
        var mh$ = isViableFeatureBiome.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("isViableFeatureBiome", mc, structureType, biomeID);
            }
            return (int)mh$.invokeExact(mc, structureType, biomeID);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class isViableStructureTerrain {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Cubiomes.C_INT,
            Cubiomes.C_INT,
            Cubiomes.C_POINTER,
            Cubiomes.C_INT,
            Cubiomes.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("isViableStructureTerrain");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int isViableStructureTerrain(int structType, Generator *g, int blockX, int blockZ)
     * }
     */
    public static FunctionDescriptor isViableStructureTerrain$descriptor() {
        return isViableStructureTerrain.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int isViableStructureTerrain(int structType, Generator *g, int blockX, int blockZ)
     * }
     */
    public static MethodHandle isViableStructureTerrain$handle() {
        return isViableStructureTerrain.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int isViableStructureTerrain(int structType, Generator *g, int blockX, int blockZ)
     * }
     */
    public static MemorySegment isViableStructureTerrain$address() {
        return isViableStructureTerrain.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int isViableStructureTerrain(int structType, Generator *g, int blockX, int blockZ)
     * }
     */
    public static int isViableStructureTerrain(int structType, MemorySegment g, int blockX, int blockZ) {
        var mh$ = isViableStructureTerrain.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("isViableStructureTerrain", structType, g, blockX, blockZ);
            }
            return (int)mh$.invokeExact(structType, g, blockX, blockZ);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class isViableEndCityTerrain {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Cubiomes.C_INT,
            Cubiomes.C_POINTER,
            Cubiomes.C_POINTER,
            Cubiomes.C_INT,
            Cubiomes.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("isViableEndCityTerrain");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int isViableEndCityTerrain(const Generator *g, const SurfaceNoise *sn, int blockX, int blockZ)
     * }
     */
    public static FunctionDescriptor isViableEndCityTerrain$descriptor() {
        return isViableEndCityTerrain.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int isViableEndCityTerrain(const Generator *g, const SurfaceNoise *sn, int blockX, int blockZ)
     * }
     */
    public static MethodHandle isViableEndCityTerrain$handle() {
        return isViableEndCityTerrain.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int isViableEndCityTerrain(const Generator *g, const SurfaceNoise *sn, int blockX, int blockZ)
     * }
     */
    public static MemorySegment isViableEndCityTerrain$address() {
        return isViableEndCityTerrain.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int isViableEndCityTerrain(const Generator *g, const SurfaceNoise *sn, int blockX, int blockZ)
     * }
     */
    public static int isViableEndCityTerrain(MemorySegment g, MemorySegment sn, int blockX, int blockZ) {
        var mh$ = isViableEndCityTerrain.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("isViableEndCityTerrain", g, sn, blockX, blockZ);
            }
            return (int)mh$.invokeExact(g, sn, blockX, blockZ);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class getVariant {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Cubiomes.C_INT,
            Cubiomes.C_POINTER,
            Cubiomes.C_INT,
            Cubiomes.C_INT,
            Cubiomes.C_LONG,
            Cubiomes.C_INT,
            Cubiomes.C_INT,
            Cubiomes.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("getVariant");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int getVariant(StructureVariant *sv, int structType, int mc, uint64_t seed, int blockX, int blockZ, int biomeID)
     * }
     */
    public static FunctionDescriptor getVariant$descriptor() {
        return getVariant.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int getVariant(StructureVariant *sv, int structType, int mc, uint64_t seed, int blockX, int blockZ, int biomeID)
     * }
     */
    public static MethodHandle getVariant$handle() {
        return getVariant.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int getVariant(StructureVariant *sv, int structType, int mc, uint64_t seed, int blockX, int blockZ, int biomeID)
     * }
     */
    public static MemorySegment getVariant$address() {
        return getVariant.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int getVariant(StructureVariant *sv, int structType, int mc, uint64_t seed, int blockX, int blockZ, int biomeID)
     * }
     */
    public static int getVariant(MemorySegment sv, int structType, int mc, long seed, int blockX, int blockZ, int biomeID) {
        var mh$ = getVariant.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("getVariant", sv, structType, mc, seed, blockX, blockZ, biomeID);
            }
            return (int)mh$.invokeExact(sv, structType, mc, seed, blockX, blockZ, biomeID);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class getLootTableCountForStructure {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Cubiomes.C_INT,
            Cubiomes.C_INT,
            Cubiomes.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("getLootTableCountForStructure");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int getLootTableCountForStructure(int structure, int mc)
     * }
     */
    public static FunctionDescriptor getLootTableCountForStructure$descriptor() {
        return getLootTableCountForStructure.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int getLootTableCountForStructure(int structure, int mc)
     * }
     */
    public static MethodHandle getLootTableCountForStructure$handle() {
        return getLootTableCountForStructure.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int getLootTableCountForStructure(int structure, int mc)
     * }
     */
    public static MemorySegment getLootTableCountForStructure$address() {
        return getLootTableCountForStructure.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int getLootTableCountForStructure(int structure, int mc)
     * }
     */
    public static int getLootTableCountForStructure(int structure, int mc) {
        var mh$ = getLootTableCountForStructure.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("getLootTableCountForStructure", structure, mc);
            }
            return (int)mh$.invokeExact(structure, mc);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class getStructurePieces {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Cubiomes.C_INT,
            Cubiomes.C_POINTER,
            Cubiomes.C_INT,
            Cubiomes.C_INT,
            StructureSaltConfig.layout(),
            Cubiomes.C_POINTER,
            Cubiomes.C_INT,
            Cubiomes.C_LONG,
            Cubiomes.C_INT,
            Cubiomes.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("getStructurePieces");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int getStructurePieces(Piece *list, int n, int stype, StructureSaltConfig ssconf, StructureVariant *sv, int mc, uint64_t seed, int posX, int posZ)
     * }
     */
    public static FunctionDescriptor getStructurePieces$descriptor() {
        return getStructurePieces.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int getStructurePieces(Piece *list, int n, int stype, StructureSaltConfig ssconf, StructureVariant *sv, int mc, uint64_t seed, int posX, int posZ)
     * }
     */
    public static MethodHandle getStructurePieces$handle() {
        return getStructurePieces.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int getStructurePieces(Piece *list, int n, int stype, StructureSaltConfig ssconf, StructureVariant *sv, int mc, uint64_t seed, int posX, int posZ)
     * }
     */
    public static MemorySegment getStructurePieces$address() {
        return getStructurePieces.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int getStructurePieces(Piece *list, int n, int stype, StructureSaltConfig ssconf, StructureVariant *sv, int mc, uint64_t seed, int posX, int posZ)
     * }
     */
    public static int getStructurePieces(MemorySegment list, int n, int stype, MemorySegment ssconf, MemorySegment sv, int mc, long seed, int posX, int posZ) {
        var mh$ = getStructurePieces.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("getStructurePieces", list, n, stype, ssconf, sv, mc, seed, posX, posZ);
            }
            return (int)mh$.invokeExact(list, n, stype, ssconf, sv, mc, seed, posX, posZ);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class getEndCityPieces {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Cubiomes.C_INT,
            Cubiomes.C_POINTER,
            Cubiomes.C_LONG,
            Cubiomes.C_INT,
            Cubiomes.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("getEndCityPieces");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int getEndCityPieces(Piece *pieces, uint64_t seed, int chunkX, int chunkZ)
     * }
     */
    public static FunctionDescriptor getEndCityPieces$descriptor() {
        return getEndCityPieces.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int getEndCityPieces(Piece *pieces, uint64_t seed, int chunkX, int chunkZ)
     * }
     */
    public static MethodHandle getEndCityPieces$handle() {
        return getEndCityPieces.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int getEndCityPieces(Piece *pieces, uint64_t seed, int chunkX, int chunkZ)
     * }
     */
    public static MemorySegment getEndCityPieces$address() {
        return getEndCityPieces.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int getEndCityPieces(Piece *pieces, uint64_t seed, int chunkX, int chunkZ)
     * }
     */
    public static int getEndCityPieces(MemorySegment pieces, long seed, int chunkX, int chunkZ) {
        var mh$ = getEndCityPieces.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("getEndCityPieces", pieces, seed, chunkX, chunkZ);
            }
            return (int)mh$.invokeExact(pieces, seed, chunkX, chunkZ);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    private static final int BASE_FLOOR = (int)0L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.BASE_FLOOR = 0
     * }
     */
    public static int BASE_FLOOR() {
        return BASE_FLOOR;
    }
    private static final int BASE_ROOF = (int)1L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.BASE_ROOF = 1
     * }
     */
    public static int BASE_ROOF() {
        return BASE_ROOF;
    }
    private static final int BRIDGE_END = (int)2L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.BRIDGE_END = 2
     * }
     */
    public static int BRIDGE_END() {
        return BRIDGE_END;
    }
    private static final int BRIDGE_GENTLE_STAIRS = (int)3L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.BRIDGE_GENTLE_STAIRS = 3
     * }
     */
    public static int BRIDGE_GENTLE_STAIRS() {
        return BRIDGE_GENTLE_STAIRS;
    }
    private static final int BRIDGE_PIECE = (int)4L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.BRIDGE_PIECE = 4
     * }
     */
    public static int BRIDGE_PIECE() {
        return BRIDGE_PIECE;
    }
    private static final int BRIDGE_STEEP_STAIRS = (int)5L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.BRIDGE_STEEP_STAIRS = 5
     * }
     */
    public static int BRIDGE_STEEP_STAIRS() {
        return BRIDGE_STEEP_STAIRS;
    }
    private static final int FAT_TOWER_BASE = (int)6L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.FAT_TOWER_BASE = 6
     * }
     */
    public static int FAT_TOWER_BASE() {
        return FAT_TOWER_BASE;
    }
    private static final int FAT_TOWER_MIDDLE = (int)7L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.FAT_TOWER_MIDDLE = 7
     * }
     */
    public static int FAT_TOWER_MIDDLE() {
        return FAT_TOWER_MIDDLE;
    }
    private static final int FAT_TOWER_TOP = (int)8L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.FAT_TOWER_TOP = 8
     * }
     */
    public static int FAT_TOWER_TOP() {
        return FAT_TOWER_TOP;
    }
    private static final int SECOND_FLOOR_1 = (int)9L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.SECOND_FLOOR_1 = 9
     * }
     */
    public static int SECOND_FLOOR_1() {
        return SECOND_FLOOR_1;
    }
    private static final int SECOND_FLOOR_2 = (int)10L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.SECOND_FLOOR_2 = 10
     * }
     */
    public static int SECOND_FLOOR_2() {
        return SECOND_FLOOR_2;
    }
    private static final int SECOND_ROOF = (int)11L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.SECOND_ROOF = 11
     * }
     */
    public static int SECOND_ROOF() {
        return SECOND_ROOF;
    }
    private static final int END_SHIP = (int)12L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.END_SHIP = 12
     * }
     */
    public static int END_SHIP() {
        return END_SHIP;
    }
    private static final int THIRD_FLOOR_1 = (int)13L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.THIRD_FLOOR_1 = 13
     * }
     */
    public static int THIRD_FLOOR_1() {
        return THIRD_FLOOR_1;
    }
    private static final int THIRD_FLOOR_2 = (int)14L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.THIRD_FLOOR_2 = 14
     * }
     */
    public static int THIRD_FLOOR_2() {
        return THIRD_FLOOR_2;
    }
    private static final int THIRD_ROOF = (int)15L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.THIRD_ROOF = 15
     * }
     */
    public static int THIRD_ROOF() {
        return THIRD_ROOF;
    }
    private static final int TOWER_BASE = (int)16L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.TOWER_BASE = 16
     * }
     */
    public static int TOWER_BASE() {
        return TOWER_BASE;
    }
    private static final int TOWER_FLOOR = (int)17L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.TOWER_FLOOR = 17
     * }
     */
    public static int TOWER_FLOOR() {
        return TOWER_FLOOR;
    }
    private static final int TOWER_PIECE = (int)18L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.TOWER_PIECE = 18
     * }
     */
    public static int TOWER_PIECE() {
        return TOWER_PIECE;
    }
    private static final int TOWER_TOP = (int)19L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.TOWER_TOP = 19
     * }
     */
    public static int TOWER_TOP() {
        return TOWER_TOP;
    }
    private static final int END_CITY_PIECES_MAX = (int)421L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.END_CITY_PIECES_MAX = 421
     * }
     */
    public static int END_CITY_PIECES_MAX() {
        return END_CITY_PIECES_MAX;
    }

    private static class getFortressPieces {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Cubiomes.C_INT,
            Cubiomes.C_POINTER,
            Cubiomes.C_INT,
            Cubiomes.C_INT,
            Cubiomes.C_LONG,
            Cubiomes.C_INT,
            Cubiomes.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("getFortressPieces");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int getFortressPieces(Piece *list, int n, int mc, uint64_t seed, int chunkX, int chunkZ)
     * }
     */
    public static FunctionDescriptor getFortressPieces$descriptor() {
        return getFortressPieces.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int getFortressPieces(Piece *list, int n, int mc, uint64_t seed, int chunkX, int chunkZ)
     * }
     */
    public static MethodHandle getFortressPieces$handle() {
        return getFortressPieces.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int getFortressPieces(Piece *list, int n, int mc, uint64_t seed, int chunkX, int chunkZ)
     * }
     */
    public static MemorySegment getFortressPieces$address() {
        return getFortressPieces.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int getFortressPieces(Piece *list, int n, int mc, uint64_t seed, int chunkX, int chunkZ)
     * }
     */
    public static int getFortressPieces(MemorySegment list, int n, int mc, long seed, int chunkX, int chunkZ) {
        var mh$ = getFortressPieces.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("getFortressPieces", list, n, mc, seed, chunkX, chunkZ);
            }
            return (int)mh$.invokeExact(list, n, mc, seed, chunkX, chunkZ);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    private static final int FORTRESS_START = (int)0L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.FORTRESS_START = 0
     * }
     */
    public static int FORTRESS_START() {
        return FORTRESS_START;
    }
    private static final int BRIDGE_STRAIGHT = (int)1L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.BRIDGE_STRAIGHT = 1
     * }
     */
    public static int BRIDGE_STRAIGHT() {
        return BRIDGE_STRAIGHT;
    }
    private static final int BRIDGE_CROSSING = (int)2L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.BRIDGE_CROSSING = 2
     * }
     */
    public static int BRIDGE_CROSSING() {
        return BRIDGE_CROSSING;
    }
    private static final int BRIDGE_FORTIFIED_CROSSING = (int)3L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.BRIDGE_FORTIFIED_CROSSING = 3
     * }
     */
    public static int BRIDGE_FORTIFIED_CROSSING() {
        return BRIDGE_FORTIFIED_CROSSING;
    }
    private static final int BRIDGE_STAIRS = (int)4L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.BRIDGE_STAIRS = 4
     * }
     */
    public static int BRIDGE_STAIRS() {
        return BRIDGE_STAIRS;
    }
    private static final int BRIDGE_SPAWNER = (int)5L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.BRIDGE_SPAWNER = 5
     * }
     */
    public static int BRIDGE_SPAWNER() {
        return BRIDGE_SPAWNER;
    }
    private static final int BRIDGE_CORRIDOR_ENTRANCE = (int)6L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.BRIDGE_CORRIDOR_ENTRANCE = 6
     * }
     */
    public static int BRIDGE_CORRIDOR_ENTRANCE() {
        return BRIDGE_CORRIDOR_ENTRANCE;
    }
    private static final int CORRIDOR_STRAIGHT = (int)7L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.CORRIDOR_STRAIGHT = 7
     * }
     */
    public static int CORRIDOR_STRAIGHT() {
        return CORRIDOR_STRAIGHT;
    }
    private static final int CORRIDOR_CROSSING = (int)8L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.CORRIDOR_CROSSING = 8
     * }
     */
    public static int CORRIDOR_CROSSING() {
        return CORRIDOR_CROSSING;
    }
    private static final int CORRIDOR_TURN_RIGHT = (int)9L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.CORRIDOR_TURN_RIGHT = 9
     * }
     */
    public static int CORRIDOR_TURN_RIGHT() {
        return CORRIDOR_TURN_RIGHT;
    }
    private static final int CORRIDOR_TURN_LEFT = (int)10L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.CORRIDOR_TURN_LEFT = 10
     * }
     */
    public static int CORRIDOR_TURN_LEFT() {
        return CORRIDOR_TURN_LEFT;
    }
    private static final int CORRIDOR_STAIRS = (int)11L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.CORRIDOR_STAIRS = 11
     * }
     */
    public static int CORRIDOR_STAIRS() {
        return CORRIDOR_STAIRS;
    }
    private static final int CORRIDOR_T_CROSSING = (int)12L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.CORRIDOR_T_CROSSING = 12
     * }
     */
    public static int CORRIDOR_T_CROSSING() {
        return CORRIDOR_T_CROSSING;
    }
    private static final int CORRIDOR_NETHER_WART = (int)13L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.CORRIDOR_NETHER_WART = 13
     * }
     */
    public static int CORRIDOR_NETHER_WART() {
        return CORRIDOR_NETHER_WART;
    }
    private static final int FORTRESS_END = (int)14L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.FORTRESS_END = 14
     * }
     */
    public static int FORTRESS_END() {
        return FORTRESS_END;
    }
    private static final int PIECE_COUNT = (int)15L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.PIECE_COUNT = 15
     * }
     */
    public static int PIECE_COUNT() {
        return PIECE_COUNT;
    }

    private static class getFixedEndGateways {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            Cubiomes.C_INT,
            Cubiomes.C_LONG,
            Cubiomes.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("getFixedEndGateways");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void getFixedEndGateways(int mc, uint64_t seed, Pos src[20])
     * }
     */
    public static FunctionDescriptor getFixedEndGateways$descriptor() {
        return getFixedEndGateways.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void getFixedEndGateways(int mc, uint64_t seed, Pos src[20])
     * }
     */
    public static MethodHandle getFixedEndGateways$handle() {
        return getFixedEndGateways.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void getFixedEndGateways(int mc, uint64_t seed, Pos src[20])
     * }
     */
    public static MemorySegment getFixedEndGateways$address() {
        return getFixedEndGateways.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void getFixedEndGateways(int mc, uint64_t seed, Pos src[20])
     * }
     */
    public static void getFixedEndGateways(int mc, long seed, MemorySegment src) {
        var mh$ = getFixedEndGateways.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("getFixedEndGateways", mc, seed, src);
            }
            mh$.invokeExact(mc, seed, src);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class getLinkedGatewayChunk {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Pos.layout(),
            Cubiomes.C_POINTER,
            Cubiomes.C_POINTER,
            Cubiomes.C_LONG,
            Pos.layout(),
            Cubiomes.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("getLinkedGatewayChunk");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * Pos getLinkedGatewayChunk(const EndNoise *en, const SurfaceNoise *sn, uint64_t seed, Pos src, Pos *dst)
     * }
     */
    public static FunctionDescriptor getLinkedGatewayChunk$descriptor() {
        return getLinkedGatewayChunk.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * Pos getLinkedGatewayChunk(const EndNoise *en, const SurfaceNoise *sn, uint64_t seed, Pos src, Pos *dst)
     * }
     */
    public static MethodHandle getLinkedGatewayChunk$handle() {
        return getLinkedGatewayChunk.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * Pos getLinkedGatewayChunk(const EndNoise *en, const SurfaceNoise *sn, uint64_t seed, Pos src, Pos *dst)
     * }
     */
    public static MemorySegment getLinkedGatewayChunk$address() {
        return getLinkedGatewayChunk.ADDR;
    }

    /**
     * {@snippet lang=c :
     * Pos getLinkedGatewayChunk(const EndNoise *en, const SurfaceNoise *sn, uint64_t seed, Pos src, Pos *dst)
     * }
     */
    public static MemorySegment getLinkedGatewayChunk(SegmentAllocator allocator, MemorySegment en, MemorySegment sn, long seed, MemorySegment src, MemorySegment dst) {
        var mh$ = getLinkedGatewayChunk.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("getLinkedGatewayChunk", allocator, en, sn, seed, src, dst);
            }
            return (MemorySegment)mh$.invokeExact(allocator, en, sn, seed, src, dst);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class getLinkedGatewayPos {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Pos.layout(),
            Cubiomes.C_POINTER,
            Cubiomes.C_POINTER,
            Cubiomes.C_LONG,
            Pos.layout()
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("getLinkedGatewayPos");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * Pos getLinkedGatewayPos(const EndNoise *en, const SurfaceNoise *sn, uint64_t seed, Pos src)
     * }
     */
    public static FunctionDescriptor getLinkedGatewayPos$descriptor() {
        return getLinkedGatewayPos.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * Pos getLinkedGatewayPos(const EndNoise *en, const SurfaceNoise *sn, uint64_t seed, Pos src)
     * }
     */
    public static MethodHandle getLinkedGatewayPos$handle() {
        return getLinkedGatewayPos.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * Pos getLinkedGatewayPos(const EndNoise *en, const SurfaceNoise *sn, uint64_t seed, Pos src)
     * }
     */
    public static MemorySegment getLinkedGatewayPos$address() {
        return getLinkedGatewayPos.ADDR;
    }

    /**
     * {@snippet lang=c :
     * Pos getLinkedGatewayPos(const EndNoise *en, const SurfaceNoise *sn, uint64_t seed, Pos src)
     * }
     */
    public static MemorySegment getLinkedGatewayPos(SegmentAllocator allocator, MemorySegment en, MemorySegment sn, long seed, MemorySegment src) {
        var mh$ = getLinkedGatewayPos.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("getLinkedGatewayPos", allocator, en, sn, seed, src);
            }
            return (MemorySegment)mh$.invokeExact(allocator, en, sn, seed, src);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    private static final int HouseSmall = (int)0L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.HouseSmall = 0
     * }
     */
    public static int HouseSmall() {
        return HouseSmall;
    }
    private static final int Church = (int)1L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.Church = 1
     * }
     */
    public static int Church() {
        return Church;
    }
    private static final int Library = (int)2L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.Library = 2
     * }
     */
    public static int Library() {
        return Library;
    }
    private static final int WoodHut = (int)3L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.WoodHut = 3
     * }
     */
    public static int WoodHut() {
        return WoodHut;
    }
    private static final int Butcher = (int)4L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.Butcher = 4
     * }
     */
    public static int Butcher() {
        return Butcher;
    }
    private static final int FarmLarge = (int)5L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.FarmLarge = 5
     * }
     */
    public static int FarmLarge() {
        return FarmLarge;
    }
    private static final int FarmSmall = (int)6L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.FarmSmall = 6
     * }
     */
    public static int FarmSmall() {
        return FarmSmall;
    }
    private static final int Blacksmith = (int)7L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.Blacksmith = 7
     * }
     */
    public static int Blacksmith() {
        return Blacksmith;
    }
    private static final int HouseLarge = (int)8L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.HouseLarge = 8
     * }
     */
    public static int HouseLarge() {
        return HouseLarge;
    }
    private static final int HOUSE_NUM = (int)9L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.HOUSE_NUM = 9
     * }
     */
    public static int HOUSE_NUM() {
        return HOUSE_NUM;
    }

    private static class getHouseList {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Cubiomes.C_LONG,
            Cubiomes.C_POINTER,
            Cubiomes.C_LONG,
            Cubiomes.C_INT,
            Cubiomes.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("getHouseList");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * uint64_t getHouseList(int *houses, uint64_t seed, int chunkX, int chunkZ)
     * }
     */
    public static FunctionDescriptor getHouseList$descriptor() {
        return getHouseList.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * uint64_t getHouseList(int *houses, uint64_t seed, int chunkX, int chunkZ)
     * }
     */
    public static MethodHandle getHouseList$handle() {
        return getHouseList.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * uint64_t getHouseList(int *houses, uint64_t seed, int chunkX, int chunkZ)
     * }
     */
    public static MemorySegment getHouseList$address() {
        return getHouseList.ADDR;
    }

    /**
     * {@snippet lang=c :
     * uint64_t getHouseList(int *houses, uint64_t seed, int chunkX, int chunkZ)
     * }
     */
    public static long getHouseList(MemorySegment houses, long seed, int chunkX, int chunkZ) {
        var mh$ = getHouseList.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("getHouseList", houses, seed, chunkX, chunkZ);
            }
            return (long)mh$.invokeExact(houses, seed, chunkX, chunkZ);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class monteCarloBiomes {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Cubiomes.C_INT,
            Cubiomes.C_POINTER,
            Range.layout(),
            Cubiomes.C_POINTER,
            Cubiomes.C_DOUBLE,
            Cubiomes.C_DOUBLE,
            Cubiomes.C_POINTER,
            Cubiomes.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("monteCarloBiomes");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int monteCarloBiomes(Generator *g, Range r, uint64_t *rng, double coverage, double confidence, int (*eval)(Generator *, int, int, int, int, void *), void *data)
     * }
     */
    public static FunctionDescriptor monteCarloBiomes$descriptor() {
        return monteCarloBiomes.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int monteCarloBiomes(Generator *g, Range r, uint64_t *rng, double coverage, double confidence, int (*eval)(Generator *, int, int, int, int, void *), void *data)
     * }
     */
    public static MethodHandle monteCarloBiomes$handle() {
        return monteCarloBiomes.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int monteCarloBiomes(Generator *g, Range r, uint64_t *rng, double coverage, double confidence, int (*eval)(Generator *, int, int, int, int, void *), void *data)
     * }
     */
    public static MemorySegment monteCarloBiomes$address() {
        return monteCarloBiomes.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int monteCarloBiomes(Generator *g, Range r, uint64_t *rng, double coverage, double confidence, int (*eval)(Generator *, int, int, int, int, void *), void *data)
     * }
     */
    public static int monteCarloBiomes(MemorySegment g, MemorySegment r, MemorySegment rng, double coverage, double confidence, MemorySegment eval, MemorySegment data) {
        var mh$ = monteCarloBiomes.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("monteCarloBiomes", g, r, rng, coverage, confidence, eval, data);
            }
            return (int)mh$.invokeExact(g, r, rng, coverage, confidence, eval, data);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class setupBiomeFilter {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            Cubiomes.C_POINTER,
            Cubiomes.C_INT,
            Cubiomes.C_INT,
            Cubiomes.C_POINTER,
            Cubiomes.C_INT,
            Cubiomes.C_POINTER,
            Cubiomes.C_INT,
            Cubiomes.C_POINTER,
            Cubiomes.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("setupBiomeFilter");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void setupBiomeFilter(BiomeFilter *bf, int mc, uint32_t flags, const int *required, int requiredLen, const int *excluded, int excludedLen, const int *matchany, int matchanyLen)
     * }
     */
    public static FunctionDescriptor setupBiomeFilter$descriptor() {
        return setupBiomeFilter.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void setupBiomeFilter(BiomeFilter *bf, int mc, uint32_t flags, const int *required, int requiredLen, const int *excluded, int excludedLen, const int *matchany, int matchanyLen)
     * }
     */
    public static MethodHandle setupBiomeFilter$handle() {
        return setupBiomeFilter.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void setupBiomeFilter(BiomeFilter *bf, int mc, uint32_t flags, const int *required, int requiredLen, const int *excluded, int excludedLen, const int *matchany, int matchanyLen)
     * }
     */
    public static MemorySegment setupBiomeFilter$address() {
        return setupBiomeFilter.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void setupBiomeFilter(BiomeFilter *bf, int mc, uint32_t flags, const int *required, int requiredLen, const int *excluded, int excludedLen, const int *matchany, int matchanyLen)
     * }
     */
    public static void setupBiomeFilter(MemorySegment bf, int mc, int flags, MemorySegment required, int requiredLen, MemorySegment excluded, int excludedLen, MemorySegment matchany, int matchanyLen) {
        var mh$ = setupBiomeFilter.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("setupBiomeFilter", bf, mc, flags, required, requiredLen, excluded, excludedLen, matchany, matchanyLen);
            }
            mh$.invokeExact(bf, mc, flags, required, requiredLen, excluded, excludedLen, matchany, matchanyLen);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class checkForBiomes {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Cubiomes.C_INT,
            Cubiomes.C_POINTER,
            Cubiomes.C_POINTER,
            Range.layout(),
            Cubiomes.C_INT,
            Cubiomes.C_LONG,
            Cubiomes.C_POINTER,
            Cubiomes.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("checkForBiomes");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int checkForBiomes(Generator *g, int *cache, Range r, int dim, uint64_t seed, const BiomeFilter *filter, volatile char *stop)
     * }
     */
    public static FunctionDescriptor checkForBiomes$descriptor() {
        return checkForBiomes.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int checkForBiomes(Generator *g, int *cache, Range r, int dim, uint64_t seed, const BiomeFilter *filter, volatile char *stop)
     * }
     */
    public static MethodHandle checkForBiomes$handle() {
        return checkForBiomes.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int checkForBiomes(Generator *g, int *cache, Range r, int dim, uint64_t seed, const BiomeFilter *filter, volatile char *stop)
     * }
     */
    public static MemorySegment checkForBiomes$address() {
        return checkForBiomes.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int checkForBiomes(Generator *g, int *cache, Range r, int dim, uint64_t seed, const BiomeFilter *filter, volatile char *stop)
     * }
     */
    public static int checkForBiomes(MemorySegment g, MemorySegment cache, MemorySegment r, int dim, long seed, MemorySegment filter, MemorySegment stop) {
        var mh$ = checkForBiomes.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("checkForBiomes", g, cache, r, dim, seed, filter, stop);
            }
            return (int)mh$.invokeExact(g, cache, r, dim, seed, filter, stop);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class checkForBiomesAtLayer {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Cubiomes.C_INT,
            Cubiomes.C_POINTER,
            Cubiomes.C_POINTER,
            Cubiomes.C_POINTER,
            Cubiomes.C_LONG,
            Cubiomes.C_INT,
            Cubiomes.C_INT,
            Cubiomes.C_INT,
            Cubiomes.C_INT,
            Cubiomes.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("checkForBiomesAtLayer");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int checkForBiomesAtLayer(LayerStack *ls, Layer *entry, int *cache, uint64_t seed, int x, int z, unsigned int w, unsigned int h, const BiomeFilter *filter)
     * }
     */
    public static FunctionDescriptor checkForBiomesAtLayer$descriptor() {
        return checkForBiomesAtLayer.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int checkForBiomesAtLayer(LayerStack *ls, Layer *entry, int *cache, uint64_t seed, int x, int z, unsigned int w, unsigned int h, const BiomeFilter *filter)
     * }
     */
    public static MethodHandle checkForBiomesAtLayer$handle() {
        return checkForBiomesAtLayer.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int checkForBiomesAtLayer(LayerStack *ls, Layer *entry, int *cache, uint64_t seed, int x, int z, unsigned int w, unsigned int h, const BiomeFilter *filter)
     * }
     */
    public static MemorySegment checkForBiomesAtLayer$address() {
        return checkForBiomesAtLayer.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int checkForBiomesAtLayer(LayerStack *ls, Layer *entry, int *cache, uint64_t seed, int x, int z, unsigned int w, unsigned int h, const BiomeFilter *filter)
     * }
     */
    public static int checkForBiomesAtLayer(MemorySegment ls, MemorySegment entry, MemorySegment cache, long seed, int x, int z, int w, int h, MemorySegment filter) {
        var mh$ = checkForBiomesAtLayer.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("checkForBiomesAtLayer", ls, entry, cache, seed, x, z, w, h, filter);
            }
            return (int)mh$.invokeExact(ls, entry, cache, seed, x, z, w, h, filter);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class checkForTemps {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Cubiomes.C_INT,
            Cubiomes.C_POINTER,
            Cubiomes.C_LONG,
            Cubiomes.C_INT,
            Cubiomes.C_INT,
            Cubiomes.C_INT,
            Cubiomes.C_INT,
            Cubiomes.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("checkForTemps");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int checkForTemps(LayerStack *g, uint64_t seed, int x, int z, int w, int h, const int tc[9])
     * }
     */
    public static FunctionDescriptor checkForTemps$descriptor() {
        return checkForTemps.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int checkForTemps(LayerStack *g, uint64_t seed, int x, int z, int w, int h, const int tc[9])
     * }
     */
    public static MethodHandle checkForTemps$handle() {
        return checkForTemps.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int checkForTemps(LayerStack *g, uint64_t seed, int x, int z, int w, int h, const int tc[9])
     * }
     */
    public static MemorySegment checkForTemps$address() {
        return checkForTemps.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int checkForTemps(LayerStack *g, uint64_t seed, int x, int z, int w, int h, const int tc[9])
     * }
     */
    public static int checkForTemps(MemorySegment g, long seed, int x, int z, int w, int h, MemorySegment tc) {
        var mh$ = checkForTemps.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("checkForTemps", g, seed, x, z, w, h, tc);
            }
            return (int)mh$.invokeExact(g, seed, x, z, w, h, tc);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class getBiomeCenters {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Cubiomes.C_INT,
            Cubiomes.C_POINTER,
            Cubiomes.C_POINTER,
            Cubiomes.C_INT,
            Cubiomes.C_POINTER,
            Range.layout(),
            Cubiomes.C_INT,
            Cubiomes.C_INT,
            Cubiomes.C_INT,
            Cubiomes.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("getBiomeCenters");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int getBiomeCenters(Pos *pos, int *siz, int nmax, Generator *g, Range r, int match, int minsiz, int tol, volatile char *stop)
     * }
     */
    public static FunctionDescriptor getBiomeCenters$descriptor() {
        return getBiomeCenters.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int getBiomeCenters(Pos *pos, int *siz, int nmax, Generator *g, Range r, int match, int minsiz, int tol, volatile char *stop)
     * }
     */
    public static MethodHandle getBiomeCenters$handle() {
        return getBiomeCenters.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int getBiomeCenters(Pos *pos, int *siz, int nmax, Generator *g, Range r, int match, int minsiz, int tol, volatile char *stop)
     * }
     */
    public static MemorySegment getBiomeCenters$address() {
        return getBiomeCenters.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int getBiomeCenters(Pos *pos, int *siz, int nmax, Generator *g, Range r, int match, int minsiz, int tol, volatile char *stop)
     * }
     */
    public static int getBiomeCenters(MemorySegment pos, MemorySegment siz, int nmax, MemorySegment g, MemorySegment r, int match, int minsiz, int tol, MemorySegment stop) {
        var mh$ = getBiomeCenters.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("getBiomeCenters", pos, siz, nmax, g, r, match, minsiz, tol, stop);
            }
            return (int)mh$.invokeExact(pos, siz, nmax, g, r, match, minsiz, tol, stop);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class canBiomeGenerate {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Cubiomes.C_INT,
            Cubiomes.C_INT,
            Cubiomes.C_INT,
            Cubiomes.C_INT,
            Cubiomes.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("canBiomeGenerate");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int canBiomeGenerate(int layerId, int mc, uint32_t flags, int biomeID)
     * }
     */
    public static FunctionDescriptor canBiomeGenerate$descriptor() {
        return canBiomeGenerate.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int canBiomeGenerate(int layerId, int mc, uint32_t flags, int biomeID)
     * }
     */
    public static MethodHandle canBiomeGenerate$handle() {
        return canBiomeGenerate.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int canBiomeGenerate(int layerId, int mc, uint32_t flags, int biomeID)
     * }
     */
    public static MemorySegment canBiomeGenerate$address() {
        return canBiomeGenerate.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int canBiomeGenerate(int layerId, int mc, uint32_t flags, int biomeID)
     * }
     */
    public static int canBiomeGenerate(int layerId, int mc, int flags, int biomeID) {
        var mh$ = canBiomeGenerate.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("canBiomeGenerate", layerId, mc, flags, biomeID);
            }
            return (int)mh$.invokeExact(layerId, mc, flags, biomeID);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class genPotential {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            Cubiomes.C_POINTER,
            Cubiomes.C_POINTER,
            Cubiomes.C_INT,
            Cubiomes.C_INT,
            Cubiomes.C_INT,
            Cubiomes.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("genPotential");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void genPotential(uint64_t *mL, uint64_t *mM, int layerId, int mc, uint32_t flags, int biomeID)
     * }
     */
    public static FunctionDescriptor genPotential$descriptor() {
        return genPotential.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void genPotential(uint64_t *mL, uint64_t *mM, int layerId, int mc, uint32_t flags, int biomeID)
     * }
     */
    public static MethodHandle genPotential$handle() {
        return genPotential.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void genPotential(uint64_t *mL, uint64_t *mM, int layerId, int mc, uint32_t flags, int biomeID)
     * }
     */
    public static MemorySegment genPotential$address() {
        return genPotential.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void genPotential(uint64_t *mL, uint64_t *mM, int layerId, int mc, uint32_t flags, int biomeID)
     * }
     */
    public static void genPotential(MemorySegment mL, MemorySegment mM, int layerId, int mc, int flags, int biomeID) {
        var mh$ = genPotential.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("genPotential", mL, mM, layerId, mc, flags, biomeID);
            }
            mh$.invokeExact(mL, mM, layerId, mc, flags, biomeID);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class getAvailableBiomes {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            Cubiomes.C_POINTER,
            Cubiomes.C_POINTER,
            Cubiomes.C_INT,
            Cubiomes.C_INT,
            Cubiomes.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("getAvailableBiomes");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void getAvailableBiomes(uint64_t *mL, uint64_t *mM, int layerId, int mc, uint32_t flags)
     * }
     */
    public static FunctionDescriptor getAvailableBiomes$descriptor() {
        return getAvailableBiomes.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void getAvailableBiomes(uint64_t *mL, uint64_t *mM, int layerId, int mc, uint32_t flags)
     * }
     */
    public static MethodHandle getAvailableBiomes$handle() {
        return getAvailableBiomes.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void getAvailableBiomes(uint64_t *mL, uint64_t *mM, int layerId, int mc, uint32_t flags)
     * }
     */
    public static MemorySegment getAvailableBiomes$address() {
        return getAvailableBiomes.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void getAvailableBiomes(uint64_t *mL, uint64_t *mM, int layerId, int mc, uint32_t flags)
     * }
     */
    public static void getAvailableBiomes(MemorySegment mL, MemorySegment mM, int layerId, int mc, int flags) {
        var mh$ = getAvailableBiomes.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("getAvailableBiomes", mL, mM, layerId, mc, flags);
            }
            mh$.invokeExact(mL, mM, layerId, mc, flags);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class getParaDescent {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Cubiomes.C_DOUBLE,
            Cubiomes.C_POINTER,
            Cubiomes.C_DOUBLE,
            Cubiomes.C_INT,
            Cubiomes.C_INT,
            Cubiomes.C_INT,
            Cubiomes.C_INT,
            Cubiomes.C_INT,
            Cubiomes.C_INT,
            Cubiomes.C_INT,
            Cubiomes.C_INT,
            Cubiomes.C_DOUBLE,
            Cubiomes.C_POINTER,
            Cubiomes.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("getParaDescent");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * double getParaDescent(const DoublePerlinNoise *para, double factor, int x, int z, int w, int h, int i0, int j0, int maxrad, int maxiter, double alpha, void *data, int (*func)(void *, int, int, double))
     * }
     */
    public static FunctionDescriptor getParaDescent$descriptor() {
        return getParaDescent.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * double getParaDescent(const DoublePerlinNoise *para, double factor, int x, int z, int w, int h, int i0, int j0, int maxrad, int maxiter, double alpha, void *data, int (*func)(void *, int, int, double))
     * }
     */
    public static MethodHandle getParaDescent$handle() {
        return getParaDescent.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * double getParaDescent(const DoublePerlinNoise *para, double factor, int x, int z, int w, int h, int i0, int j0, int maxrad, int maxiter, double alpha, void *data, int (*func)(void *, int, int, double))
     * }
     */
    public static MemorySegment getParaDescent$address() {
        return getParaDescent.ADDR;
    }

    /**
     * {@snippet lang=c :
     * double getParaDescent(const DoublePerlinNoise *para, double factor, int x, int z, int w, int h, int i0, int j0, int maxrad, int maxiter, double alpha, void *data, int (*func)(void *, int, int, double))
     * }
     */
    public static double getParaDescent(MemorySegment para, double factor, int x, int z, int w, int h, int i0, int j0, int maxrad, int maxiter, double alpha, MemorySegment data, MemorySegment func) {
        var mh$ = getParaDescent.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("getParaDescent", para, factor, x, z, w, h, i0, j0, maxrad, maxiter, alpha, data, func);
            }
            return (double)mh$.invokeExact(para, factor, x, z, w, h, i0, j0, maxrad, maxiter, alpha, data, func);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class getParaRange {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Cubiomes.C_INT,
            Cubiomes.C_POINTER,
            Cubiomes.C_POINTER,
            Cubiomes.C_POINTER,
            Cubiomes.C_INT,
            Cubiomes.C_INT,
            Cubiomes.C_INT,
            Cubiomes.C_INT,
            Cubiomes.C_POINTER,
            Cubiomes.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("getParaRange");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int getParaRange(const DoublePerlinNoise *para, double *pmin, double *pmax, int x, int z, int w, int h, void *data, int (*func)(void *, int, int, double))
     * }
     */
    public static FunctionDescriptor getParaRange$descriptor() {
        return getParaRange.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int getParaRange(const DoublePerlinNoise *para, double *pmin, double *pmax, int x, int z, int w, int h, void *data, int (*func)(void *, int, int, double))
     * }
     */
    public static MethodHandle getParaRange$handle() {
        return getParaRange.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int getParaRange(const DoublePerlinNoise *para, double *pmin, double *pmax, int x, int z, int w, int h, void *data, int (*func)(void *, int, int, double))
     * }
     */
    public static MemorySegment getParaRange$address() {
        return getParaRange.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int getParaRange(const DoublePerlinNoise *para, double *pmin, double *pmax, int x, int z, int w, int h, void *data, int (*func)(void *, int, int, double))
     * }
     */
    public static int getParaRange(MemorySegment para, MemorySegment pmin, MemorySegment pmax, int x, int z, int w, int h, MemorySegment data, MemorySegment func) {
        var mh$ = getParaRange.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("getParaRange", para, pmin, pmax, x, z, w, h, data, func);
            }
            return (int)mh$.invokeExact(para, pmin, pmax, x, z, w, h, data, func);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class getBiomeParaExtremes {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Cubiomes.C_POINTER,
            Cubiomes.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("getBiomeParaExtremes");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * const int *getBiomeParaExtremes(int mc)
     * }
     */
    public static FunctionDescriptor getBiomeParaExtremes$descriptor() {
        return getBiomeParaExtremes.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * const int *getBiomeParaExtremes(int mc)
     * }
     */
    public static MethodHandle getBiomeParaExtremes$handle() {
        return getBiomeParaExtremes.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * const int *getBiomeParaExtremes(int mc)
     * }
     */
    public static MemorySegment getBiomeParaExtremes$address() {
        return getBiomeParaExtremes.ADDR;
    }

    /**
     * {@snippet lang=c :
     * const int *getBiomeParaExtremes(int mc)
     * }
     */
    public static MemorySegment getBiomeParaExtremes(int mc) {
        var mh$ = getBiomeParaExtremes.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("getBiomeParaExtremes", mc);
            }
            return (MemorySegment)mh$.invokeExact(mc);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class getBiomeParaLimits {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Cubiomes.C_POINTER,
            Cubiomes.C_INT,
            Cubiomes.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("getBiomeParaLimits");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * const int *getBiomeParaLimits(int mc, int id)
     * }
     */
    public static FunctionDescriptor getBiomeParaLimits$descriptor() {
        return getBiomeParaLimits.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * const int *getBiomeParaLimits(int mc, int id)
     * }
     */
    public static MethodHandle getBiomeParaLimits$handle() {
        return getBiomeParaLimits.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * const int *getBiomeParaLimits(int mc, int id)
     * }
     */
    public static MemorySegment getBiomeParaLimits$address() {
        return getBiomeParaLimits.ADDR;
    }

    /**
     * {@snippet lang=c :
     * const int *getBiomeParaLimits(int mc, int id)
     * }
     */
    public static MemorySegment getBiomeParaLimits(int mc, int id) {
        var mh$ = getBiomeParaLimits.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("getBiomeParaLimits", mc, id);
            }
            return (MemorySegment)mh$.invokeExact(mc, id);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class getPossibleBiomesForLimits {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            Cubiomes.C_POINTER,
            Cubiomes.C_INT,
            Cubiomes.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("getPossibleBiomesForLimits");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void getPossibleBiomesForLimits(char ids[256], int mc, int limits[6][2])
     * }
     */
    public static FunctionDescriptor getPossibleBiomesForLimits$descriptor() {
        return getPossibleBiomesForLimits.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void getPossibleBiomesForLimits(char ids[256], int mc, int limits[6][2])
     * }
     */
    public static MethodHandle getPossibleBiomesForLimits$handle() {
        return getPossibleBiomesForLimits.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void getPossibleBiomesForLimits(char ids[256], int mc, int limits[6][2])
     * }
     */
    public static MemorySegment getPossibleBiomesForLimits$address() {
        return getPossibleBiomesForLimits.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void getPossibleBiomesForLimits(char ids[256], int mc, int limits[6][2])
     * }
     */
    public static void getPossibleBiomesForLimits(MemorySegment ids, int mc, MemorySegment limits) {
        var mh$ = getPossibleBiomesForLimits.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("getPossibleBiomesForLimits", ids, mc, limits);
            }
            mh$.invokeExact(ids, mc, limits);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class getLargestRec {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Cubiomes.C_INT,
            Cubiomes.C_INT,
            Cubiomes.C_POINTER,
            Cubiomes.C_INT,
            Cubiomes.C_INT,
            Cubiomes.C_POINTER,
            Cubiomes.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("getLargestRec");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int getLargestRec(int match, const int *ids, int sx, int sz, Pos *p0, Pos *p1)
     * }
     */
    public static FunctionDescriptor getLargestRec$descriptor() {
        return getLargestRec.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int getLargestRec(int match, const int *ids, int sx, int sz, Pos *p0, Pos *p1)
     * }
     */
    public static MethodHandle getLargestRec$handle() {
        return getLargestRec.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int getLargestRec(int match, const int *ids, int sx, int sz, Pos *p0, Pos *p1)
     * }
     */
    public static MemorySegment getLargestRec$address() {
        return getLargestRec.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int getLargestRec(int match, const int *ids, int sx, int sz, Pos *p0, Pos *p1)
     * }
     */
    public static int getLargestRec(int match, MemorySegment ids, int sx, int sz, MemorySegment p0, MemorySegment p1) {
        var mh$ = getLargestRec.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("getLargestRec", match, ids, sx, sz, p0, p1);
            }
            return (int)mh$.invokeExact(match, ids, sx, sz, p0, p1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    private static final int OTP_PILLAR = (int)0L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.OTP_PILLAR = 0
     * }
     */
    public static int OTP_PILLAR() {
        return OTP_PILLAR;
    }
    private static final int OTP_PILLAR_RARENESS = (int)1L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.OTP_PILLAR_RARENESS = 1
     * }
     */
    public static int OTP_PILLAR_RARENESS() {
        return OTP_PILLAR_RARENESS;
    }
    private static final int OTP_PILLAR_THICKNESS = (int)2L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.OTP_PILLAR_THICKNESS = 2
     * }
     */
    public static int OTP_PILLAR_THICKNESS() {
        return OTP_PILLAR_THICKNESS;
    }
    private static final int OTP_SPAGHETTI_2D = (int)3L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.OTP_SPAGHETTI_2D = 3
     * }
     */
    public static int OTP_SPAGHETTI_2D() {
        return OTP_SPAGHETTI_2D;
    }
    private static final int OTP_SPAGHETTI_2D_ELEVATION = (int)4L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.OTP_SPAGHETTI_2D_ELEVATION = 4
     * }
     */
    public static int OTP_SPAGHETTI_2D_ELEVATION() {
        return OTP_SPAGHETTI_2D_ELEVATION;
    }
    private static final int OTP_SPAGHETTI_2D_MODULATOR = (int)5L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.OTP_SPAGHETTI_2D_MODULATOR = 5
     * }
     */
    public static int OTP_SPAGHETTI_2D_MODULATOR() {
        return OTP_SPAGHETTI_2D_MODULATOR;
    }
    private static final int OTP_SPAGHETTI_2D_THICKNESS = (int)6L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.OTP_SPAGHETTI_2D_THICKNESS = 6
     * }
     */
    public static int OTP_SPAGHETTI_2D_THICKNESS() {
        return OTP_SPAGHETTI_2D_THICKNESS;
    }
    private static final int OTP_SPAGHETTI_3D_1 = (int)7L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.OTP_SPAGHETTI_3D_1 = 7
     * }
     */
    public static int OTP_SPAGHETTI_3D_1() {
        return OTP_SPAGHETTI_3D_1;
    }
    private static final int OTP_SPAGHETTI_3D_2 = (int)8L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.OTP_SPAGHETTI_3D_2 = 8
     * }
     */
    public static int OTP_SPAGHETTI_3D_2() {
        return OTP_SPAGHETTI_3D_2;
    }
    private static final int OTP_SPAGHETTI_3D_RARITY = (int)9L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.OTP_SPAGHETTI_3D_RARITY = 9
     * }
     */
    public static int OTP_SPAGHETTI_3D_RARITY() {
        return OTP_SPAGHETTI_3D_RARITY;
    }
    private static final int OTP_SPAGHETTI_3D_THICKNESS = (int)10L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.OTP_SPAGHETTI_3D_THICKNESS = 10
     * }
     */
    public static int OTP_SPAGHETTI_3D_THICKNESS() {
        return OTP_SPAGHETTI_3D_THICKNESS;
    }
    private static final int OTP_SPAGHETTI_ROUGHNESS = (int)11L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.OTP_SPAGHETTI_ROUGHNESS = 11
     * }
     */
    public static int OTP_SPAGHETTI_ROUGHNESS() {
        return OTP_SPAGHETTI_ROUGHNESS;
    }
    private static final int OTP_SPAGHETTI_ROUGHNESS_MODULATOR = (int)12L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.OTP_SPAGHETTI_ROUGHNESS_MODULATOR = 12
     * }
     */
    public static int OTP_SPAGHETTI_ROUGHNESS_MODULATOR() {
        return OTP_SPAGHETTI_ROUGHNESS_MODULATOR;
    }
    private static final int OTP_CAVE_ENTRANCE = (int)13L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.OTP_CAVE_ENTRANCE = 13
     * }
     */
    public static int OTP_CAVE_ENTRANCE() {
        return OTP_CAVE_ENTRANCE;
    }
    private static final int OTP_CAVE_LAYER = (int)14L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.OTP_CAVE_LAYER = 14
     * }
     */
    public static int OTP_CAVE_LAYER() {
        return OTP_CAVE_LAYER;
    }
    private static final int OTP_CAVE_CHEESE = (int)15L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.OTP_CAVE_CHEESE = 15
     * }
     */
    public static int OTP_CAVE_CHEESE() {
        return OTP_CAVE_CHEESE;
    }
    private static final int OTP_NOODLE = (int)16L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.OTP_NOODLE = 16
     * }
     */
    public static int OTP_NOODLE() {
        return OTP_NOODLE;
    }
    private static final int OTP_NOODLE_THICKNESS = (int)17L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.OTP_NOODLE_THICKNESS = 17
     * }
     */
    public static int OTP_NOODLE_THICKNESS() {
        return OTP_NOODLE_THICKNESS;
    }
    private static final int OTP_NOODLE_RIDGE_A = (int)18L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.OTP_NOODLE_RIDGE_A = 18
     * }
     */
    public static int OTP_NOODLE_RIDGE_A() {
        return OTP_NOODLE_RIDGE_A;
    }
    private static final int OTP_NOODLE_RIDGE_B = (int)19L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.OTP_NOODLE_RIDGE_B = 19
     * }
     */
    public static int OTP_NOODLE_RIDGE_B() {
        return OTP_NOODLE_RIDGE_B;
    }
    private static final int OTP_JAGGED = (int)20L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.OTP_JAGGED = 20
     * }
     */
    public static int OTP_JAGGED() {
        return OTP_JAGGED;
    }
    private static final int OTP_MAX = (int)21L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.OTP_MAX = 21
     * }
     */
    public static int OTP_MAX() {
        return OTP_MAX;
    }

    private static class setupTerrainNoise {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Cubiomes.C_INT,
            Cubiomes.C_POINTER,
            Cubiomes.C_INT,
            Cubiomes.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("setupTerrainNoise");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int setupTerrainNoise(TerrainNoise *params, int mc, int flags)
     * }
     */
    public static FunctionDescriptor setupTerrainNoise$descriptor() {
        return setupTerrainNoise.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int setupTerrainNoise(TerrainNoise *params, int mc, int flags)
     * }
     */
    public static MethodHandle setupTerrainNoise$handle() {
        return setupTerrainNoise.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int setupTerrainNoise(TerrainNoise *params, int mc, int flags)
     * }
     */
    public static MemorySegment setupTerrainNoise$address() {
        return setupTerrainNoise.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int setupTerrainNoise(TerrainNoise *params, int mc, int flags)
     * }
     */
    public static int setupTerrainNoise(MemorySegment params, int mc, int flags) {
        var mh$ = setupTerrainNoise.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("setupTerrainNoise", params, mc, flags);
            }
            return (int)mh$.invokeExact(params, mc, flags);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class initTerrainNoise {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Cubiomes.C_INT,
            Cubiomes.C_POINTER,
            Cubiomes.C_LONG,
            Cubiomes.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("initTerrainNoise");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int initTerrainNoise(TerrainNoise *params, uint64_t ws, int dim)
     * }
     */
    public static FunctionDescriptor initTerrainNoise$descriptor() {
        return initTerrainNoise.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int initTerrainNoise(TerrainNoise *params, uint64_t ws, int dim)
     * }
     */
    public static MethodHandle initTerrainNoise$handle() {
        return initTerrainNoise.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int initTerrainNoise(TerrainNoise *params, uint64_t ws, int dim)
     * }
     */
    public static MemorySegment initTerrainNoise$address() {
        return initTerrainNoise.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int initTerrainNoise(TerrainNoise *params, uint64_t ws, int dim)
     * }
     */
    public static int initTerrainNoise(MemorySegment params, long ws, int dim) {
        var mh$ = initTerrainNoise.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("initTerrainNoise", params, ws, dim);
            }
            return (int)mh$.invokeExact(params, ws, dim);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class sampleSpaghettiRoughness {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Cubiomes.C_DOUBLE,
            Cubiomes.C_POINTER,
            Cubiomes.C_INT,
            Cubiomes.C_INT,
            Cubiomes.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("sampleSpaghettiRoughness");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * double sampleSpaghettiRoughness(TerrainNoise *params, int x, int y, int z)
     * }
     */
    public static FunctionDescriptor sampleSpaghettiRoughness$descriptor() {
        return sampleSpaghettiRoughness.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * double sampleSpaghettiRoughness(TerrainNoise *params, int x, int y, int z)
     * }
     */
    public static MethodHandle sampleSpaghettiRoughness$handle() {
        return sampleSpaghettiRoughness.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * double sampleSpaghettiRoughness(TerrainNoise *params, int x, int y, int z)
     * }
     */
    public static MemorySegment sampleSpaghettiRoughness$address() {
        return sampleSpaghettiRoughness.ADDR;
    }

    /**
     * {@snippet lang=c :
     * double sampleSpaghettiRoughness(TerrainNoise *params, int x, int y, int z)
     * }
     */
    public static double sampleSpaghettiRoughness(MemorySegment params, int x, int y, int z) {
        var mh$ = sampleSpaghettiRoughness.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("sampleSpaghettiRoughness", params, x, y, z);
            }
            return (double)mh$.invokeExact(params, x, y, z);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class sampleSpaghetti2dThicknessModulator {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Cubiomes.C_DOUBLE,
            Cubiomes.C_POINTER,
            Cubiomes.C_INT,
            Cubiomes.C_INT,
            Cubiomes.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("sampleSpaghetti2dThicknessModulator");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * double sampleSpaghetti2dThicknessModulator(TerrainNoise *params, int x, int y, int z)
     * }
     */
    public static FunctionDescriptor sampleSpaghetti2dThicknessModulator$descriptor() {
        return sampleSpaghetti2dThicknessModulator.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * double sampleSpaghetti2dThicknessModulator(TerrainNoise *params, int x, int y, int z)
     * }
     */
    public static MethodHandle sampleSpaghetti2dThicknessModulator$handle() {
        return sampleSpaghetti2dThicknessModulator.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * double sampleSpaghetti2dThicknessModulator(TerrainNoise *params, int x, int y, int z)
     * }
     */
    public static MemorySegment sampleSpaghetti2dThicknessModulator$address() {
        return sampleSpaghetti2dThicknessModulator.ADDR;
    }

    /**
     * {@snippet lang=c :
     * double sampleSpaghetti2dThicknessModulator(TerrainNoise *params, int x, int y, int z)
     * }
     */
    public static double sampleSpaghetti2dThicknessModulator(MemorySegment params, int x, int y, int z) {
        var mh$ = sampleSpaghetti2dThicknessModulator.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("sampleSpaghetti2dThicknessModulator", params, x, y, z);
            }
            return (double)mh$.invokeExact(params, x, y, z);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class sampleSpaghetti2d {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Cubiomes.C_DOUBLE,
            Cubiomes.C_POINTER,
            Cubiomes.C_INT,
            Cubiomes.C_INT,
            Cubiomes.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("sampleSpaghetti2d");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * double sampleSpaghetti2d(TerrainNoise *params, int x, int y, int z)
     * }
     */
    public static FunctionDescriptor sampleSpaghetti2d$descriptor() {
        return sampleSpaghetti2d.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * double sampleSpaghetti2d(TerrainNoise *params, int x, int y, int z)
     * }
     */
    public static MethodHandle sampleSpaghetti2d$handle() {
        return sampleSpaghetti2d.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * double sampleSpaghetti2d(TerrainNoise *params, int x, int y, int z)
     * }
     */
    public static MemorySegment sampleSpaghetti2d$address() {
        return sampleSpaghetti2d.ADDR;
    }

    /**
     * {@snippet lang=c :
     * double sampleSpaghetti2d(TerrainNoise *params, int x, int y, int z)
     * }
     */
    public static double sampleSpaghetti2d(MemorySegment params, int x, int y, int z) {
        var mh$ = sampleSpaghetti2d.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("sampleSpaghetti2d", params, x, y, z);
            }
            return (double)mh$.invokeExact(params, x, y, z);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class sampleSpaghetti3d {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Cubiomes.C_DOUBLE,
            Cubiomes.C_POINTER,
            Cubiomes.C_INT,
            Cubiomes.C_INT,
            Cubiomes.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("sampleSpaghetti3d");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * double sampleSpaghetti3d(TerrainNoise *params, int x, int y, int z)
     * }
     */
    public static FunctionDescriptor sampleSpaghetti3d$descriptor() {
        return sampleSpaghetti3d.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * double sampleSpaghetti3d(TerrainNoise *params, int x, int y, int z)
     * }
     */
    public static MethodHandle sampleSpaghetti3d$handle() {
        return sampleSpaghetti3d.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * double sampleSpaghetti3d(TerrainNoise *params, int x, int y, int z)
     * }
     */
    public static MemorySegment sampleSpaghetti3d$address() {
        return sampleSpaghetti3d.ADDR;
    }

    /**
     * {@snippet lang=c :
     * double sampleSpaghetti3d(TerrainNoise *params, int x, int y, int z)
     * }
     */
    public static double sampleSpaghetti3d(MemorySegment params, int x, int y, int z) {
        var mh$ = sampleSpaghetti3d.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("sampleSpaghetti3d", params, x, y, z);
            }
            return (double)mh$.invokeExact(params, x, y, z);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class sampleCaveEntrance {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Cubiomes.C_DOUBLE,
            Cubiomes.C_POINTER,
            Cubiomes.C_INT,
            Cubiomes.C_INT,
            Cubiomes.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("sampleCaveEntrance");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * double sampleCaveEntrance(TerrainNoise *params, int x, int y, int z)
     * }
     */
    public static FunctionDescriptor sampleCaveEntrance$descriptor() {
        return sampleCaveEntrance.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * double sampleCaveEntrance(TerrainNoise *params, int x, int y, int z)
     * }
     */
    public static MethodHandle sampleCaveEntrance$handle() {
        return sampleCaveEntrance.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * double sampleCaveEntrance(TerrainNoise *params, int x, int y, int z)
     * }
     */
    public static MemorySegment sampleCaveEntrance$address() {
        return sampleCaveEntrance.ADDR;
    }

    /**
     * {@snippet lang=c :
     * double sampleCaveEntrance(TerrainNoise *params, int x, int y, int z)
     * }
     */
    public static double sampleCaveEntrance(MemorySegment params, int x, int y, int z) {
        var mh$ = sampleCaveEntrance.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("sampleCaveEntrance", params, x, y, z);
            }
            return (double)mh$.invokeExact(params, x, y, z);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class sampleEntrances {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Cubiomes.C_DOUBLE,
            Cubiomes.C_POINTER,
            Cubiomes.C_INT,
            Cubiomes.C_INT,
            Cubiomes.C_INT,
            Cubiomes.C_DOUBLE
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("sampleEntrances");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * double sampleEntrances(TerrainNoise *params, int x, int y, int z, double spaghettiRoughness)
     * }
     */
    public static FunctionDescriptor sampleEntrances$descriptor() {
        return sampleEntrances.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * double sampleEntrances(TerrainNoise *params, int x, int y, int z, double spaghettiRoughness)
     * }
     */
    public static MethodHandle sampleEntrances$handle() {
        return sampleEntrances.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * double sampleEntrances(TerrainNoise *params, int x, int y, int z, double spaghettiRoughness)
     * }
     */
    public static MemorySegment sampleEntrances$address() {
        return sampleEntrances.ADDR;
    }

    /**
     * {@snippet lang=c :
     * double sampleEntrances(TerrainNoise *params, int x, int y, int z, double spaghettiRoughness)
     * }
     */
    public static double sampleEntrances(MemorySegment params, int x, int y, int z, double spaghettiRoughness) {
        var mh$ = sampleEntrances.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("sampleEntrances", params, x, y, z, spaghettiRoughness);
            }
            return (double)mh$.invokeExact(params, x, y, z, spaghettiRoughness);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class sampleCaveLayer {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Cubiomes.C_DOUBLE,
            Cubiomes.C_POINTER,
            Cubiomes.C_INT,
            Cubiomes.C_INT,
            Cubiomes.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("sampleCaveLayer");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * double sampleCaveLayer(TerrainNoise *params, int x, int y, int z)
     * }
     */
    public static FunctionDescriptor sampleCaveLayer$descriptor() {
        return sampleCaveLayer.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * double sampleCaveLayer(TerrainNoise *params, int x, int y, int z)
     * }
     */
    public static MethodHandle sampleCaveLayer$handle() {
        return sampleCaveLayer.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * double sampleCaveLayer(TerrainNoise *params, int x, int y, int z)
     * }
     */
    public static MemorySegment sampleCaveLayer$address() {
        return sampleCaveLayer.ADDR;
    }

    /**
     * {@snippet lang=c :
     * double sampleCaveLayer(TerrainNoise *params, int x, int y, int z)
     * }
     */
    public static double sampleCaveLayer(MemorySegment params, int x, int y, int z) {
        var mh$ = sampleCaveLayer.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("sampleCaveLayer", params, x, y, z);
            }
            return (double)mh$.invokeExact(params, x, y, z);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class sampleSlopedCheese {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Cubiomes.C_DOUBLE,
            Cubiomes.C_POINTER,
            Cubiomes.C_INT,
            Cubiomes.C_INT,
            Cubiomes.C_INT,
            Cubiomes.C_DOUBLE,
            Cubiomes.C_DOUBLE,
            Cubiomes.C_DOUBLE
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("sampleSlopedCheese");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * double sampleSlopedCheese(TerrainNoise *params, int x, int y, int z, double depth, double factor, double jagged)
     * }
     */
    public static FunctionDescriptor sampleSlopedCheese$descriptor() {
        return sampleSlopedCheese.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * double sampleSlopedCheese(TerrainNoise *params, int x, int y, int z, double depth, double factor, double jagged)
     * }
     */
    public static MethodHandle sampleSlopedCheese$handle() {
        return sampleSlopedCheese.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * double sampleSlopedCheese(TerrainNoise *params, int x, int y, int z, double depth, double factor, double jagged)
     * }
     */
    public static MemorySegment sampleSlopedCheese$address() {
        return sampleSlopedCheese.ADDR;
    }

    /**
     * {@snippet lang=c :
     * double sampleSlopedCheese(TerrainNoise *params, int x, int y, int z, double depth, double factor, double jagged)
     * }
     */
    public static double sampleSlopedCheese(MemorySegment params, int x, int y, int z, double depth, double factor, double jagged) {
        var mh$ = sampleSlopedCheese.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("sampleSlopedCheese", params, x, y, z, depth, factor, jagged);
            }
            return (double)mh$.invokeExact(params, x, y, z, depth, factor, jagged);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class sampleCaveCheese {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Cubiomes.C_DOUBLE,
            Cubiomes.C_POINTER,
            Cubiomes.C_INT,
            Cubiomes.C_INT,
            Cubiomes.C_INT,
            Cubiomes.C_DOUBLE
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("sampleCaveCheese");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * double sampleCaveCheese(TerrainNoise *params, int x, int y, int z, double slopedCheese)
     * }
     */
    public static FunctionDescriptor sampleCaveCheese$descriptor() {
        return sampleCaveCheese.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * double sampleCaveCheese(TerrainNoise *params, int x, int y, int z, double slopedCheese)
     * }
     */
    public static MethodHandle sampleCaveCheese$handle() {
        return sampleCaveCheese.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * double sampleCaveCheese(TerrainNoise *params, int x, int y, int z, double slopedCheese)
     * }
     */
    public static MemorySegment sampleCaveCheese$address() {
        return sampleCaveCheese.ADDR;
    }

    /**
     * {@snippet lang=c :
     * double sampleCaveCheese(TerrainNoise *params, int x, int y, int z, double slopedCheese)
     * }
     */
    public static double sampleCaveCheese(MemorySegment params, int x, int y, int z, double slopedCheese) {
        var mh$ = sampleCaveCheese.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("sampleCaveCheese", params, x, y, z, slopedCheese);
            }
            return (double)mh$.invokeExact(params, x, y, z, slopedCheese);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class samplePillars {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Cubiomes.C_DOUBLE,
            Cubiomes.C_POINTER,
            Cubiomes.C_INT,
            Cubiomes.C_INT,
            Cubiomes.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("samplePillars");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * double samplePillars(TerrainNoise *params, int x, int y, int z)
     * }
     */
    public static FunctionDescriptor samplePillars$descriptor() {
        return samplePillars.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * double samplePillars(TerrainNoise *params, int x, int y, int z)
     * }
     */
    public static MethodHandle samplePillars$handle() {
        return samplePillars.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * double samplePillars(TerrainNoise *params, int x, int y, int z)
     * }
     */
    public static MemorySegment samplePillars$address() {
        return samplePillars.ADDR;
    }

    /**
     * {@snippet lang=c :
     * double samplePillars(TerrainNoise *params, int x, int y, int z)
     * }
     */
    public static double samplePillars(MemorySegment params, int x, int y, int z) {
        var mh$ = samplePillars.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("samplePillars", params, x, y, z);
            }
            return (double)mh$.invokeExact(params, x, y, z);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class sampleNoodle {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Cubiomes.C_DOUBLE,
            Cubiomes.C_POINTER,
            Cubiomes.C_INT,
            Cubiomes.C_INT,
            Cubiomes.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("sampleNoodle");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * double sampleNoodle(TerrainNoise *params, int x, int y, int z)
     * }
     */
    public static FunctionDescriptor sampleNoodle$descriptor() {
        return sampleNoodle.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * double sampleNoodle(TerrainNoise *params, int x, int y, int z)
     * }
     */
    public static MethodHandle sampleNoodle$handle() {
        return sampleNoodle.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * double sampleNoodle(TerrainNoise *params, int x, int y, int z)
     * }
     */
    public static MemorySegment sampleNoodle$address() {
        return sampleNoodle.ADDR;
    }

    /**
     * {@snippet lang=c :
     * double sampleNoodle(TerrainNoise *params, int x, int y, int z)
     * }
     */
    public static double sampleNoodle(MemorySegment params, int x, int y, int z) {
        var mh$ = sampleNoodle.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("sampleNoodle", params, x, y, z);
            }
            return (double)mh$.invokeExact(params, x, y, z);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class sampleUnderground {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Cubiomes.C_DOUBLE,
            Cubiomes.C_POINTER,
            Cubiomes.C_INT,
            Cubiomes.C_INT,
            Cubiomes.C_INT,
            Cubiomes.C_DOUBLE,
            Cubiomes.C_DOUBLE,
            Cubiomes.C_DOUBLE
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("sampleUnderground");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * double sampleUnderground(TerrainNoise *params, int x, int y, int z, double spaghettiRoughness, double entrances, double slopedCheese)
     * }
     */
    public static FunctionDescriptor sampleUnderground$descriptor() {
        return sampleUnderground.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * double sampleUnderground(TerrainNoise *params, int x, int y, int z, double spaghettiRoughness, double entrances, double slopedCheese)
     * }
     */
    public static MethodHandle sampleUnderground$handle() {
        return sampleUnderground.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * double sampleUnderground(TerrainNoise *params, int x, int y, int z, double spaghettiRoughness, double entrances, double slopedCheese)
     * }
     */
    public static MemorySegment sampleUnderground$address() {
        return sampleUnderground.ADDR;
    }

    /**
     * {@snippet lang=c :
     * double sampleUnderground(TerrainNoise *params, int x, int y, int z, double spaghettiRoughness, double entrances, double slopedCheese)
     * }
     */
    public static double sampleUnderground(MemorySegment params, int x, int y, int z, double spaghettiRoughness, double entrances, double slopedCheese) {
        var mh$ = sampleUnderground.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("sampleUnderground", params, x, y, z, spaghettiRoughness, entrances, slopedCheese);
            }
            return (double)mh$.invokeExact(params, x, y, z, spaghettiRoughness, entrances, slopedCheese);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class sampleFinalDensity {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Cubiomes.C_DOUBLE,
            Cubiomes.C_POINTER,
            Cubiomes.C_INT,
            Cubiomes.C_INT,
            Cubiomes.C_INT,
            Cubiomes.C_DOUBLE,
            Cubiomes.C_DOUBLE,
            Cubiomes.C_DOUBLE
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("sampleFinalDensity");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * double sampleFinalDensity(TerrainNoise *params, int x, int y, int z, double spaghettiRoughness, double entrances, double slopedCheese)
     * }
     */
    public static FunctionDescriptor sampleFinalDensity$descriptor() {
        return sampleFinalDensity.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * double sampleFinalDensity(TerrainNoise *params, int x, int y, int z, double spaghettiRoughness, double entrances, double slopedCheese)
     * }
     */
    public static MethodHandle sampleFinalDensity$handle() {
        return sampleFinalDensity.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * double sampleFinalDensity(TerrainNoise *params, int x, int y, int z, double spaghettiRoughness, double entrances, double slopedCheese)
     * }
     */
    public static MemorySegment sampleFinalDensity$address() {
        return sampleFinalDensity.ADDR;
    }

    /**
     * {@snippet lang=c :
     * double sampleFinalDensity(TerrainNoise *params, int x, int y, int z, double spaghettiRoughness, double entrances, double slopedCheese)
     * }
     */
    public static double sampleFinalDensity(MemorySegment params, int x, int y, int z, double spaghettiRoughness, double entrances, double slopedCheese) {
        var mh$ = sampleFinalDensity.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("sampleFinalDensity", params, x, y, z, spaghettiRoughness, entrances, slopedCheese);
            }
            return (double)mh$.invokeExact(params, x, y, z, spaghettiRoughness, entrances, slopedCheese);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class samplePreliminarySurfaceLevel {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Cubiomes.C_INT,
            Cubiomes.C_POINTER,
            Cubiomes.C_INT,
            Cubiomes.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("samplePreliminarySurfaceLevel");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int samplePreliminarySurfaceLevel(TerrainNoise *params, int x, int z)
     * }
     */
    public static FunctionDescriptor samplePreliminarySurfaceLevel$descriptor() {
        return samplePreliminarySurfaceLevel.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int samplePreliminarySurfaceLevel(TerrainNoise *params, int x, int z)
     * }
     */
    public static MethodHandle samplePreliminarySurfaceLevel$handle() {
        return samplePreliminarySurfaceLevel.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int samplePreliminarySurfaceLevel(TerrainNoise *params, int x, int z)
     * }
     */
    public static MemorySegment samplePreliminarySurfaceLevel$address() {
        return samplePreliminarySurfaceLevel.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int samplePreliminarySurfaceLevel(TerrainNoise *params, int x, int z)
     * }
     */
    public static int samplePreliminarySurfaceLevel(MemorySegment params, int x, int z) {
        var mh$ = samplePreliminarySurfaceLevel.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("samplePreliminarySurfaceLevel", params, x, z);
            }
            return (int)mh$.invokeExact(params, x, z);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class sampleNoiseColumn {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            Cubiomes.C_POINTER,
            Cubiomes.C_INT,
            Cubiomes.C_INT,
            Cubiomes.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("sampleNoiseColumn");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void sampleNoiseColumn(TerrainNoise *params, int cellX, int cellZ, double buffer[49])
     * }
     */
    public static FunctionDescriptor sampleNoiseColumn$descriptor() {
        return sampleNoiseColumn.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void sampleNoiseColumn(TerrainNoise *params, int cellX, int cellZ, double buffer[49])
     * }
     */
    public static MethodHandle sampleNoiseColumn$handle() {
        return sampleNoiseColumn.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void sampleNoiseColumn(TerrainNoise *params, int cellX, int cellZ, double buffer[49])
     * }
     */
    public static MemorySegment sampleNoiseColumn$address() {
        return sampleNoiseColumn.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void sampleNoiseColumn(TerrainNoise *params, int cellX, int cellZ, double buffer[49])
     * }
     */
    public static void sampleNoiseColumn(MemorySegment params, int cellX, int cellZ, MemorySegment buffer) {
        var mh$ = sampleNoiseColumn.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("sampleNoiseColumn", params, cellX, cellZ, buffer);
            }
            mh$.invokeExact(params, cellX, cellZ, buffer);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class generateColumn {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Cubiomes.C_INT,
            Cubiomes.C_INT,
            Cubiomes.C_INT,
            Cubiomes.C_POINTER,
            Cubiomes.C_POINTER,
            Cubiomes.C_POINTER,
            Cubiomes.C_POINTER,
            Cubiomes.C_POINTER,
            Cubiomes.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("generateColumn");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int generateColumn(int x, int z, int blocks[384], const double ds00[49], const double ds01[49], const double ds10[49], const double ds11[49], int flag)
     * }
     */
    public static FunctionDescriptor generateColumn$descriptor() {
        return generateColumn.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int generateColumn(int x, int z, int blocks[384], const double ds00[49], const double ds01[49], const double ds10[49], const double ds11[49], int flag)
     * }
     */
    public static MethodHandle generateColumn$handle() {
        return generateColumn.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int generateColumn(int x, int z, int blocks[384], const double ds00[49], const double ds01[49], const double ds10[49], const double ds11[49], int flag)
     * }
     */
    public static MemorySegment generateColumn$address() {
        return generateColumn.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int generateColumn(int x, int z, int blocks[384], const double ds00[49], const double ds01[49], const double ds10[49], const double ds11[49], int flag)
     * }
     */
    public static int generateColumn(int x, int z, MemorySegment blocks, MemorySegment ds00, MemorySegment ds01, MemorySegment ds10, MemorySegment ds11, int flag) {
        var mh$ = generateColumn.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("generateColumn", x, z, blocks, ds00, ds01, ds10, ds11, flag);
            }
            return (int)mh$.invokeExact(x, z, blocks, ds00, ds01, ds10, ds11, flag);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class generateRegion {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            Cubiomes.C_POINTER,
            Cubiomes.C_INT,
            Cubiomes.C_INT,
            Cubiomes.C_INT,
            Cubiomes.C_INT,
            Cubiomes.C_POINTER,
            Cubiomes.C_POINTER,
            Cubiomes.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("generateRegion");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void generateRegion(TerrainNoise *params, int chunkX, int chunkZ, int chunkW, int chunkH, int (*blocks)[384], int *ys, int flag)
     * }
     */
    public static FunctionDescriptor generateRegion$descriptor() {
        return generateRegion.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void generateRegion(TerrainNoise *params, int chunkX, int chunkZ, int chunkW, int chunkH, int (*blocks)[384], int *ys, int flag)
     * }
     */
    public static MethodHandle generateRegion$handle() {
        return generateRegion.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void generateRegion(TerrainNoise *params, int chunkX, int chunkZ, int chunkW, int chunkH, int (*blocks)[384], int *ys, int flag)
     * }
     */
    public static MemorySegment generateRegion$address() {
        return generateRegion.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void generateRegion(TerrainNoise *params, int chunkX, int chunkZ, int chunkW, int chunkH, int (*blocks)[384], int *ys, int flag)
     * }
     */
    public static void generateRegion(MemorySegment params, int chunkX, int chunkZ, int chunkW, int chunkH, MemorySegment blocks, MemorySegment ys, int flag) {
        var mh$ = generateRegion.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("generateRegion", params, chunkX, chunkZ, chunkW, chunkH, blocks, ys, flag);
            }
            mh$.invokeExact(params, chunkX, chunkZ, chunkW, chunkH, blocks, ys, flag);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class loadSavedSeeds {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Cubiomes.C_POINTER,
            Cubiomes.C_POINTER,
            Cubiomes.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("loadSavedSeeds");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * uint64_t *loadSavedSeeds(const char *fnam, uint64_t *scnt)
     * }
     */
    public static FunctionDescriptor loadSavedSeeds$descriptor() {
        return loadSavedSeeds.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * uint64_t *loadSavedSeeds(const char *fnam, uint64_t *scnt)
     * }
     */
    public static MethodHandle loadSavedSeeds$handle() {
        return loadSavedSeeds.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * uint64_t *loadSavedSeeds(const char *fnam, uint64_t *scnt)
     * }
     */
    public static MemorySegment loadSavedSeeds$address() {
        return loadSavedSeeds.ADDR;
    }

    /**
     * {@snippet lang=c :
     * uint64_t *loadSavedSeeds(const char *fnam, uint64_t *scnt)
     * }
     */
    public static MemorySegment loadSavedSeeds(MemorySegment fnam, MemorySegment scnt) {
        var mh$ = loadSavedSeeds.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("loadSavedSeeds", fnam, scnt);
            }
            return (MemorySegment)mh$.invokeExact(fnam, scnt);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class mc2str {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Cubiomes.C_POINTER,
            Cubiomes.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("mc2str");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * const char *mc2str(int mc)
     * }
     */
    public static FunctionDescriptor mc2str$descriptor() {
        return mc2str.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * const char *mc2str(int mc)
     * }
     */
    public static MethodHandle mc2str$handle() {
        return mc2str.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * const char *mc2str(int mc)
     * }
     */
    public static MemorySegment mc2str$address() {
        return mc2str.ADDR;
    }

    /**
     * {@snippet lang=c :
     * const char *mc2str(int mc)
     * }
     */
    public static MemorySegment mc2str(int mc) {
        var mh$ = mc2str.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("mc2str", mc);
            }
            return (MemorySegment)mh$.invokeExact(mc);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class str2mc {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Cubiomes.C_INT,
            Cubiomes.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("str2mc");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int str2mc(const char *s)
     * }
     */
    public static FunctionDescriptor str2mc$descriptor() {
        return str2mc.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int str2mc(const char *s)
     * }
     */
    public static MethodHandle str2mc$handle() {
        return str2mc.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int str2mc(const char *s)
     * }
     */
    public static MemorySegment str2mc$address() {
        return str2mc.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int str2mc(const char *s)
     * }
     */
    public static int str2mc(MemorySegment s) {
        var mh$ = str2mc.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("str2mc", s);
            }
            return (int)mh$.invokeExact(s);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class biome2str {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Cubiomes.C_POINTER,
            Cubiomes.C_INT,
            Cubiomes.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("biome2str");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * const char *biome2str(int mc, int id)
     * }
     */
    public static FunctionDescriptor biome2str$descriptor() {
        return biome2str.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * const char *biome2str(int mc, int id)
     * }
     */
    public static MethodHandle biome2str$handle() {
        return biome2str.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * const char *biome2str(int mc, int id)
     * }
     */
    public static MemorySegment biome2str$address() {
        return biome2str.ADDR;
    }

    /**
     * {@snippet lang=c :
     * const char *biome2str(int mc, int id)
     * }
     */
    public static MemorySegment biome2str(int mc, int id) {
        var mh$ = biome2str.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("biome2str", mc, id);
            }
            return (MemorySegment)mh$.invokeExact(mc, id);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class struct2str {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Cubiomes.C_POINTER,
            Cubiomes.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("struct2str");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * const char *struct2str(int stype)
     * }
     */
    public static FunctionDescriptor struct2str$descriptor() {
        return struct2str.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * const char *struct2str(int stype)
     * }
     */
    public static MethodHandle struct2str$handle() {
        return struct2str.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * const char *struct2str(int stype)
     * }
     */
    public static MemorySegment struct2str$address() {
        return struct2str.ADDR;
    }

    /**
     * {@snippet lang=c :
     * const char *struct2str(int stype)
     * }
     */
    public static MemorySegment struct2str(int stype) {
        var mh$ = struct2str.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("struct2str", stype);
            }
            return (MemorySegment)mh$.invokeExact(stype);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ore2str {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Cubiomes.C_POINTER,
            Cubiomes.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("ore2str");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * const char *ore2str(int otype)
     * }
     */
    public static FunctionDescriptor ore2str$descriptor() {
        return ore2str.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * const char *ore2str(int otype)
     * }
     */
    public static MethodHandle ore2str$handle() {
        return ore2str.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * const char *ore2str(int otype)
     * }
     */
    public static MemorySegment ore2str$address() {
        return ore2str.ADDR;
    }

    /**
     * {@snippet lang=c :
     * const char *ore2str(int otype)
     * }
     */
    public static MemorySegment ore2str(int otype) {
        var mh$ = ore2str.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ore2str", otype);
            }
            return (MemorySegment)mh$.invokeExact(otype);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class initBiomeColors {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            Cubiomes.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("initBiomeColors");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void initBiomeColors(unsigned char biomeColors[256][3])
     * }
     */
    public static FunctionDescriptor initBiomeColors$descriptor() {
        return initBiomeColors.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void initBiomeColors(unsigned char biomeColors[256][3])
     * }
     */
    public static MethodHandle initBiomeColors$handle() {
        return initBiomeColors.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void initBiomeColors(unsigned char biomeColors[256][3])
     * }
     */
    public static MemorySegment initBiomeColors$address() {
        return initBiomeColors.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void initBiomeColors(unsigned char biomeColors[256][3])
     * }
     */
    public static void initBiomeColors(MemorySegment biomeColors) {
        var mh$ = initBiomeColors.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("initBiomeColors", biomeColors);
            }
            mh$.invokeExact(biomeColors);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class initBiomeTypeColors {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            Cubiomes.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("initBiomeTypeColors");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void initBiomeTypeColors(unsigned char biomeColors[256][3])
     * }
     */
    public static FunctionDescriptor initBiomeTypeColors$descriptor() {
        return initBiomeTypeColors.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void initBiomeTypeColors(unsigned char biomeColors[256][3])
     * }
     */
    public static MethodHandle initBiomeTypeColors$handle() {
        return initBiomeTypeColors.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void initBiomeTypeColors(unsigned char biomeColors[256][3])
     * }
     */
    public static MemorySegment initBiomeTypeColors$address() {
        return initBiomeTypeColors.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void initBiomeTypeColors(unsigned char biomeColors[256][3])
     * }
     */
    public static void initBiomeTypeColors(MemorySegment biomeColors) {
        var mh$ = initBiomeTypeColors.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("initBiomeTypeColors", biomeColors);
            }
            mh$.invokeExact(biomeColors);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class parseBiomeColors {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Cubiomes.C_INT,
            Cubiomes.C_POINTER,
            Cubiomes.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("parseBiomeColors");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int parseBiomeColors(unsigned char biomeColors[256][3], const char *buf)
     * }
     */
    public static FunctionDescriptor parseBiomeColors$descriptor() {
        return parseBiomeColors.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int parseBiomeColors(unsigned char biomeColors[256][3], const char *buf)
     * }
     */
    public static MethodHandle parseBiomeColors$handle() {
        return parseBiomeColors.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int parseBiomeColors(unsigned char biomeColors[256][3], const char *buf)
     * }
     */
    public static MemorySegment parseBiomeColors$address() {
        return parseBiomeColors.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int parseBiomeColors(unsigned char biomeColors[256][3], const char *buf)
     * }
     */
    public static int parseBiomeColors(MemorySegment biomeColors, MemorySegment buf) {
        var mh$ = parseBiomeColors.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("parseBiomeColors", biomeColors, buf);
            }
            return (int)mh$.invokeExact(biomeColors, buf);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class biomesToImage {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Cubiomes.C_INT,
            Cubiomes.C_POINTER,
            Cubiomes.C_POINTER,
            Cubiomes.C_POINTER,
            Cubiomes.C_INT,
            Cubiomes.C_INT,
            Cubiomes.C_INT,
            Cubiomes.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("biomesToImage");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int biomesToImage(unsigned char *pixels, unsigned char biomeColors[256][3], const int *biomes, const unsigned int sx, const unsigned int sy, const unsigned int pixscale, const int flip)
     * }
     */
    public static FunctionDescriptor biomesToImage$descriptor() {
        return biomesToImage.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int biomesToImage(unsigned char *pixels, unsigned char biomeColors[256][3], const int *biomes, const unsigned int sx, const unsigned int sy, const unsigned int pixscale, const int flip)
     * }
     */
    public static MethodHandle biomesToImage$handle() {
        return biomesToImage.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int biomesToImage(unsigned char *pixels, unsigned char biomeColors[256][3], const int *biomes, const unsigned int sx, const unsigned int sy, const unsigned int pixscale, const int flip)
     * }
     */
    public static MemorySegment biomesToImage$address() {
        return biomesToImage.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int biomesToImage(unsigned char *pixels, unsigned char biomeColors[256][3], const int *biomes, const unsigned int sx, const unsigned int sy, const unsigned int pixscale, const int flip)
     * }
     */
    public static int biomesToImage(MemorySegment pixels, MemorySegment biomeColors, MemorySegment biomes, int sx, int sy, int pixscale, int flip) {
        var mh$ = biomesToImage.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("biomesToImage", pixels, biomeColors, biomes, sx, sy, pixscale, flip);
            }
            return (int)mh$.invokeExact(pixels, biomeColors, biomes, sx, sy, pixscale, flip);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class savePPM {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Cubiomes.C_INT,
            Cubiomes.C_POINTER,
            Cubiomes.C_POINTER,
            Cubiomes.C_INT,
            Cubiomes.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("savePPM");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int savePPM(const char *path, const unsigned char *pixels, const unsigned int sx, const unsigned int sy)
     * }
     */
    public static FunctionDescriptor savePPM$descriptor() {
        return savePPM.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int savePPM(const char *path, const unsigned char *pixels, const unsigned int sx, const unsigned int sy)
     * }
     */
    public static MethodHandle savePPM$handle() {
        return savePPM.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int savePPM(const char *path, const unsigned char *pixels, const unsigned int sx, const unsigned int sy)
     * }
     */
    public static MemorySegment savePPM$address() {
        return savePPM.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int savePPM(const char *path, const unsigned char *pixels, const unsigned int sx, const unsigned int sy)
     * }
     */
    public static int savePPM(MemorySegment path, MemorySegment pixels, int sx, int sy) {
        var mh$ = savePPM.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("savePPM", path, pixels, sx, sy);
            }
            return (int)mh$.invokeExact(path, pixels, sx, sy);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    private static final int CST_NONE = (int)0L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.CST_NONE = 0
     * }
     */
    public static int CST_NONE() {
        return CST_NONE;
    }
    private static final int CST_IDEAL = (int)1L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.CST_IDEAL = 1
     * }
     */
    public static int CST_IDEAL() {
        return CST_IDEAL;
    }
    private static final int CST_CLASSIC = (int)2L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.CST_CLASSIC = 2
     * }
     */
    public static int CST_CLASSIC() {
        return CST_CLASSIC;
    }
    private static final int CST_NORMAL = (int)3L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.CST_NORMAL = 3
     * }
     */
    public static int CST_NORMAL() {
        return CST_NORMAL;
    }
    private static final int CST_BARELY = (int)4L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.CST_BARELY = 4
     * }
     */
    public static int CST_BARELY() {
        return CST_BARELY;
    }

    private static class getQuadHutCst {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Cubiomes.C_INT,
            Cubiomes.C_LONG
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("getQuadHutCst");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int getQuadHutCst(uint64_t low20)
     * }
     */
    public static FunctionDescriptor getQuadHutCst$descriptor() {
        return getQuadHutCst.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int getQuadHutCst(uint64_t low20)
     * }
     */
    public static MethodHandle getQuadHutCst$handle() {
        return getQuadHutCst.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int getQuadHutCst(uint64_t low20)
     * }
     */
    public static MemorySegment getQuadHutCst$address() {
        return getQuadHutCst.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int getQuadHutCst(uint64_t low20)
     * }
     */
    public static int getQuadHutCst(long low20) {
        var mh$ = getQuadHutCst.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("getQuadHutCst", low20);
            }
            return (int)mh$.invokeExact(low20);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class searchAll48 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Cubiomes.C_INT,
            Cubiomes.C_POINTER,
            Cubiomes.C_POINTER,
            Cubiomes.C_POINTER,
            Cubiomes.C_INT,
            Cubiomes.C_POINTER,
            Cubiomes.C_INT,
            Cubiomes.C_POINTER,
            Cubiomes.C_POINTER,
            Cubiomes.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("searchAll48");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int searchAll48(uint64_t **seedbuf, uint64_t *buflen, const char *path, int threads, const uint64_t *lowBits, int lowBitN, int (*check)(uint64_t, void *), void *data, volatile char *stop)
     * }
     */
    public static FunctionDescriptor searchAll48$descriptor() {
        return searchAll48.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int searchAll48(uint64_t **seedbuf, uint64_t *buflen, const char *path, int threads, const uint64_t *lowBits, int lowBitN, int (*check)(uint64_t, void *), void *data, volatile char *stop)
     * }
     */
    public static MethodHandle searchAll48$handle() {
        return searchAll48.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int searchAll48(uint64_t **seedbuf, uint64_t *buflen, const char *path, int threads, const uint64_t *lowBits, int lowBitN, int (*check)(uint64_t, void *), void *data, volatile char *stop)
     * }
     */
    public static MemorySegment searchAll48$address() {
        return searchAll48.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int searchAll48(uint64_t **seedbuf, uint64_t *buflen, const char *path, int threads, const uint64_t *lowBits, int lowBitN, int (*check)(uint64_t, void *), void *data, volatile char *stop)
     * }
     */
    public static int searchAll48(MemorySegment seedbuf, MemorySegment buflen, MemorySegment path, int threads, MemorySegment lowBits, int lowBitN, MemorySegment check, MemorySegment data, MemorySegment stop) {
        var mh$ = searchAll48.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("searchAll48", seedbuf, buflen, path, threads, lowBits, lowBitN, check, data, stop);
            }
            return (int)mh$.invokeExact(seedbuf, buflen, path, threads, lowBits, lowBitN, check, data, stop);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class getOptimalAfk {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Pos.layout(),
            Cubiomes.C_POINTER,
            Cubiomes.C_INT,
            Cubiomes.C_INT,
            Cubiomes.C_INT,
            Cubiomes.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("getOptimalAfk");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * Pos getOptimalAfk(Pos p[4], int ax, int ay, int az, int *spcnt)
     * }
     */
    public static FunctionDescriptor getOptimalAfk$descriptor() {
        return getOptimalAfk.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * Pos getOptimalAfk(Pos p[4], int ax, int ay, int az, int *spcnt)
     * }
     */
    public static MethodHandle getOptimalAfk$handle() {
        return getOptimalAfk.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * Pos getOptimalAfk(Pos p[4], int ax, int ay, int az, int *spcnt)
     * }
     */
    public static MemorySegment getOptimalAfk$address() {
        return getOptimalAfk.ADDR;
    }

    /**
     * {@snippet lang=c :
     * Pos getOptimalAfk(Pos p[4], int ax, int ay, int az, int *spcnt)
     * }
     */
    public static MemorySegment getOptimalAfk(SegmentAllocator allocator, MemorySegment p, int ax, int ay, int az, MemorySegment spcnt) {
        var mh$ = getOptimalAfk.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("getOptimalAfk", allocator, p, ax, ay, az, spcnt);
            }
            return (MemorySegment)mh$.invokeExact(allocator, p, ax, ay, az, spcnt);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class scanForQuads {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Cubiomes.C_INT,
            StructureConfig.layout(),
            Cubiomes.C_INT,
            Cubiomes.C_LONG,
            Cubiomes.C_POINTER,
            Cubiomes.C_INT,
            Cubiomes.C_LONG,
            Cubiomes.C_INT,
            Cubiomes.C_INT,
            Cubiomes.C_INT,
            Cubiomes.C_INT,
            Cubiomes.C_POINTER,
            Cubiomes.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("scanForQuads");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int scanForQuads(const StructureConfig sconf, int radius, uint64_t s48, const uint64_t *lowBits, int lowBitN, uint64_t salt, int x, int z, int w, int h, Pos *qplist, int n)
     * }
     */
    public static FunctionDescriptor scanForQuads$descriptor() {
        return scanForQuads.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int scanForQuads(const StructureConfig sconf, int radius, uint64_t s48, const uint64_t *lowBits, int lowBitN, uint64_t salt, int x, int z, int w, int h, Pos *qplist, int n)
     * }
     */
    public static MethodHandle scanForQuads$handle() {
        return scanForQuads.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int scanForQuads(const StructureConfig sconf, int radius, uint64_t s48, const uint64_t *lowBits, int lowBitN, uint64_t salt, int x, int z, int w, int h, Pos *qplist, int n)
     * }
     */
    public static MemorySegment scanForQuads$address() {
        return scanForQuads.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int scanForQuads(const StructureConfig sconf, int radius, uint64_t s48, const uint64_t *lowBits, int lowBitN, uint64_t salt, int x, int z, int w, int h, Pos *qplist, int n)
     * }
     */
    public static int scanForQuads(MemorySegment sconf, int radius, long s48, MemorySegment lowBits, int lowBitN, long salt, int x, int z, int w, int h, MemorySegment qplist, int n) {
        var mh$ = scanForQuads.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("scanForQuads", sconf, radius, s48, lowBits, lowBitN, salt, x, z, w, h, qplist, n);
            }
            return (int)mh$.invokeExact(sconf, radius, s48, lowBits, lowBitN, salt, x, z, w, h, qplist, n);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    private static final int ITEM_UNKNOWN = (int)-1L;
    /**
     * {@snippet lang=c :
     * enum Item.ITEM_UNKNOWN = -1
     * }
     */
    public static int ITEM_UNKNOWN() {
        return ITEM_UNKNOWN;
    }
    private static final int ITEM_ANCIENT_DEBRIS = (int)0L;
    /**
     * {@snippet lang=c :
     * enum Item.ITEM_ANCIENT_DEBRIS = 0
     * }
     */
    public static int ITEM_ANCIENT_DEBRIS() {
        return ITEM_ANCIENT_DEBRIS;
    }
    private static final int ITEM_APPLE = (int)1L;
    /**
     * {@snippet lang=c :
     * enum Item.ITEM_APPLE = 1
     * }
     */
    public static int ITEM_APPLE() {
        return ITEM_APPLE;
    }
    private static final int ITEM_ARROW = (int)2L;
    /**
     * {@snippet lang=c :
     * enum Item.ITEM_ARROW = 2
     * }
     */
    public static int ITEM_ARROW() {
        return ITEM_ARROW;
    }
    private static final int ITEM_BAMBOO = (int)3L;
    /**
     * {@snippet lang=c :
     * enum Item.ITEM_BAMBOO = 3
     * }
     */
    public static int ITEM_BAMBOO() {
        return ITEM_BAMBOO;
    }
    private static final int ITEM_BEETROOT_SEEDS = (int)4L;
    /**
     * {@snippet lang=c :
     * enum Item.ITEM_BEETROOT_SEEDS = 4
     * }
     */
    public static int ITEM_BEETROOT_SEEDS() {
        return ITEM_BEETROOT_SEEDS;
    }
    private static final int ITEM_BELL = (int)5L;
    /**
     * {@snippet lang=c :
     * enum Item.ITEM_BELL = 5
     * }
     */
    public static int ITEM_BELL() {
        return ITEM_BELL;
    }
    private static final int ITEM_BONE = (int)6L;
    /**
     * {@snippet lang=c :
     * enum Item.ITEM_BONE = 6
     * }
     */
    public static int ITEM_BONE() {
        return ITEM_BONE;
    }
    private static final int ITEM_BONE_BLOCK = (int)7L;
    /**
     * {@snippet lang=c :
     * enum Item.ITEM_BONE_BLOCK = 7
     * }
     */
    public static int ITEM_BONE_BLOCK() {
        return ITEM_BONE_BLOCK;
    }
    private static final int ITEM_BOOK = (int)8L;
    /**
     * {@snippet lang=c :
     * enum Item.ITEM_BOOK = 8
     * }
     */
    public static int ITEM_BOOK() {
        return ITEM_BOOK;
    }
    private static final int ITEM_CARROT = (int)9L;
    /**
     * {@snippet lang=c :
     * enum Item.ITEM_CARROT = 9
     * }
     */
    public static int ITEM_CARROT() {
        return ITEM_CARROT;
    }
    private static final int ITEM_CHAIN = (int)10L;
    /**
     * {@snippet lang=c :
     * enum Item.ITEM_CHAIN = 10
     * }
     */
    public static int ITEM_CHAIN() {
        return ITEM_CHAIN;
    }
    private static final int ITEM_IRON_CHAIN = (int)10L;
    /**
     * {@snippet lang=c :
     * enum Item.ITEM_IRON_CHAIN = 10
     * }
     */
    public static int ITEM_IRON_CHAIN() {
        return ITEM_IRON_CHAIN;
    }
    private static final int ITEM_CLOCK = (int)11L;
    /**
     * {@snippet lang=c :
     * enum Item.ITEM_CLOCK = 11
     * }
     */
    public static int ITEM_CLOCK() {
        return ITEM_CLOCK;
    }
    private static final int ITEM_COAL = (int)12L;
    /**
     * {@snippet lang=c :
     * enum Item.ITEM_COAL = 12
     * }
     */
    public static int ITEM_COAL() {
        return ITEM_COAL;
    }
    private static final int ITEM_COAST_ARMOR_TRIM_SMITHING_TEMPLATE = (int)13L;
    /**
     * {@snippet lang=c :
     * enum Item.ITEM_COAST_ARMOR_TRIM_SMITHING_TEMPLATE = 13
     * }
     */
    public static int ITEM_COAST_ARMOR_TRIM_SMITHING_TEMPLATE() {
        return ITEM_COAST_ARMOR_TRIM_SMITHING_TEMPLATE;
    }
    private static final int ITEM_COMPASS = (int)14L;
    /**
     * {@snippet lang=c :
     * enum Item.ITEM_COMPASS = 14
     * }
     */
    public static int ITEM_COMPASS() {
        return ITEM_COMPASS;
    }
    private static final int ITEM_COOKED_COD = (int)15L;
    /**
     * {@snippet lang=c :
     * enum Item.ITEM_COOKED_COD = 15
     * }
     */
    public static int ITEM_COOKED_COD() {
        return ITEM_COOKED_COD;
    }
    private static final int ITEM_COOKED_PORKCHOP = (int)16L;
    /**
     * {@snippet lang=c :
     * enum Item.ITEM_COOKED_PORKCHOP = 16
     * }
     */
    public static int ITEM_COOKED_PORKCHOP() {
        return ITEM_COOKED_PORKCHOP;
    }
    private static final int ITEM_COOKED_SALMON = (int)17L;
    /**
     * {@snippet lang=c :
     * enum Item.ITEM_COOKED_SALMON = 17
     * }
     */
    public static int ITEM_COOKED_SALMON() {
        return ITEM_COOKED_SALMON;
    }
    private static final int ITEM_COPPER_HORSE_ARMOR = (int)18L;
    /**
     * {@snippet lang=c :
     * enum Item.ITEM_COPPER_HORSE_ARMOR = 18
     * }
     */
    public static int ITEM_COPPER_HORSE_ARMOR() {
        return ITEM_COPPER_HORSE_ARMOR;
    }
    private static final int ITEM_COPPER_NAUTILUS_ARMOR = (int)19L;
    /**
     * {@snippet lang=c :
     * enum Item.ITEM_COPPER_NAUTILUS_ARMOR = 19
     * }
     */
    public static int ITEM_COPPER_NAUTILUS_ARMOR() {
        return ITEM_COPPER_NAUTILUS_ARMOR;
    }
    private static final int ITEM_CROSSBOW = (int)20L;
    /**
     * {@snippet lang=c :
     * enum Item.ITEM_CROSSBOW = 20
     * }
     */
    public static int ITEM_CROSSBOW() {
        return ITEM_CROSSBOW;
    }
    private static final int ITEM_CRYING_OBSIDIAN = (int)21L;
    /**
     * {@snippet lang=c :
     * enum Item.ITEM_CRYING_OBSIDIAN = 21
     * }
     */
    public static int ITEM_CRYING_OBSIDIAN() {
        return ITEM_CRYING_OBSIDIAN;
    }
    private static final int ITEM_DARK_OAK_LOG = (int)22L;
    /**
     * {@snippet lang=c :
     * enum Item.ITEM_DARK_OAK_LOG = 22
     * }
     */
    public static int ITEM_DARK_OAK_LOG() {
        return ITEM_DARK_OAK_LOG;
    }
    private static final int ITEM_DIAMOND = (int)23L;
    /**
     * {@snippet lang=c :
     * enum Item.ITEM_DIAMOND = 23
     * }
     */
    public static int ITEM_DIAMOND() {
        return ITEM_DIAMOND;
    }
    private static final int ITEM_DIAMOND_BOOTS = (int)24L;
    /**
     * {@snippet lang=c :
     * enum Item.ITEM_DIAMOND_BOOTS = 24
     * }
     */
    public static int ITEM_DIAMOND_BOOTS() {
        return ITEM_DIAMOND_BOOTS;
    }
    private static final int ITEM_DIAMOND_CHESTPLATE = (int)25L;
    /**
     * {@snippet lang=c :
     * enum Item.ITEM_DIAMOND_CHESTPLATE = 25
     * }
     */
    public static int ITEM_DIAMOND_CHESTPLATE() {
        return ITEM_DIAMOND_CHESTPLATE;
    }
    private static final int ITEM_DIAMOND_HELMET = (int)26L;
    /**
     * {@snippet lang=c :
     * enum Item.ITEM_DIAMOND_HELMET = 26
     * }
     */
    public static int ITEM_DIAMOND_HELMET() {
        return ITEM_DIAMOND_HELMET;
    }
    private static final int ITEM_DIAMOND_HORSE_ARMOR = (int)27L;
    /**
     * {@snippet lang=c :
     * enum Item.ITEM_DIAMOND_HORSE_ARMOR = 27
     * }
     */
    public static int ITEM_DIAMOND_HORSE_ARMOR() {
        return ITEM_DIAMOND_HORSE_ARMOR;
    }
    private static final int ITEM_DIAMOND_LEGGINGS = (int)28L;
    /**
     * {@snippet lang=c :
     * enum Item.ITEM_DIAMOND_LEGGINGS = 28
     * }
     */
    public static int ITEM_DIAMOND_LEGGINGS() {
        return ITEM_DIAMOND_LEGGINGS;
    }
    private static final int ITEM_DIAMOND_NAUTILUS_ARMOR = (int)29L;
    /**
     * {@snippet lang=c :
     * enum Item.ITEM_DIAMOND_NAUTILUS_ARMOR = 29
     * }
     */
    public static int ITEM_DIAMOND_NAUTILUS_ARMOR() {
        return ITEM_DIAMOND_NAUTILUS_ARMOR;
    }
    private static final int ITEM_DIAMOND_PICKAXE = (int)30L;
    /**
     * {@snippet lang=c :
     * enum Item.ITEM_DIAMOND_PICKAXE = 30
     * }
     */
    public static int ITEM_DIAMOND_PICKAXE() {
        return ITEM_DIAMOND_PICKAXE;
    }
    private static final int ITEM_DIAMOND_SHOVEL = (int)31L;
    /**
     * {@snippet lang=c :
     * enum Item.ITEM_DIAMOND_SHOVEL = 31
     * }
     */
    public static int ITEM_DIAMOND_SHOVEL() {
        return ITEM_DIAMOND_SHOVEL;
    }
    private static final int ITEM_DIAMOND_SPEAR = (int)32L;
    /**
     * {@snippet lang=c :
     * enum Item.ITEM_DIAMOND_SPEAR = 32
     * }
     */
    public static int ITEM_DIAMOND_SPEAR() {
        return ITEM_DIAMOND_SPEAR;
    }
    private static final int ITEM_DIAMOND_SWORD = (int)33L;
    /**
     * {@snippet lang=c :
     * enum Item.ITEM_DIAMOND_SWORD = 33
     * }
     */
    public static int ITEM_DIAMOND_SWORD() {
        return ITEM_DIAMOND_SWORD;
    }
    private static final int ITEM_DUNE_ARMOR_TRIM_SMITHING_TEMPLATE = (int)34L;
    /**
     * {@snippet lang=c :
     * enum Item.ITEM_DUNE_ARMOR_TRIM_SMITHING_TEMPLATE = 34
     * }
     */
    public static int ITEM_DUNE_ARMOR_TRIM_SMITHING_TEMPLATE() {
        return ITEM_DUNE_ARMOR_TRIM_SMITHING_TEMPLATE;
    }
    private static final int ITEM_EMERALD = (int)35L;
    /**
     * {@snippet lang=c :
     * enum Item.ITEM_EMERALD = 35
     * }
     */
    public static int ITEM_EMERALD() {
        return ITEM_EMERALD;
    }
    private static final int ITEM_ENCHANTED_GOLDEN_APPLE = (int)36L;
    /**
     * {@snippet lang=c :
     * enum Item.ITEM_ENCHANTED_GOLDEN_APPLE = 36
     * }
     */
    public static int ITEM_ENCHANTED_GOLDEN_APPLE() {
        return ITEM_ENCHANTED_GOLDEN_APPLE;
    }
    private static final int ITEM_EXPERIENCE_BOTTLE = (int)37L;
    /**
     * {@snippet lang=c :
     * enum Item.ITEM_EXPERIENCE_BOTTLE = 37
     * }
     */
    public static int ITEM_EXPERIENCE_BOTTLE() {
        return ITEM_EXPERIENCE_BOTTLE;
    }
    private static final int ITEM_FEATHER = (int)38L;
    /**
     * {@snippet lang=c :
     * enum Item.ITEM_FEATHER = 38
     * }
     */
    public static int ITEM_FEATHER() {
        return ITEM_FEATHER;
    }
    private static final int ITEM_FIRE_CHARGE = (int)39L;
    /**
     * {@snippet lang=c :
     * enum Item.ITEM_FIRE_CHARGE = 39
     * }
     */
    public static int ITEM_FIRE_CHARGE() {
        return ITEM_FIRE_CHARGE;
    }
    private static final int ITEM_FLINT = (int)40L;
    /**
     * {@snippet lang=c :
     * enum Item.ITEM_FLINT = 40
     * }
     */
    public static int ITEM_FLINT() {
        return ITEM_FLINT;
    }
    private static final int ITEM_FLINT_AND_STEEL = (int)41L;
    /**
     * {@snippet lang=c :
     * enum Item.ITEM_FLINT_AND_STEEL = 41
     * }
     */
    public static int ITEM_FLINT_AND_STEEL() {
        return ITEM_FLINT_AND_STEEL;
    }
    private static final int ITEM_GILDED_BLACKSTONE = (int)42L;
    /**
     * {@snippet lang=c :
     * enum Item.ITEM_GILDED_BLACKSTONE = 42
     * }
     */
    public static int ITEM_GILDED_BLACKSTONE() {
        return ITEM_GILDED_BLACKSTONE;
    }
    private static final int ITEM_GLISTERING_MELON_SLICE = (int)43L;
    /**
     * {@snippet lang=c :
     * enum Item.ITEM_GLISTERING_MELON_SLICE = 43
     * }
     */
    public static int ITEM_GLISTERING_MELON_SLICE() {
        return ITEM_GLISTERING_MELON_SLICE;
    }
    private static final int ITEM_GOAT_HORN = (int)44L;
    /**
     * {@snippet lang=c :
     * enum Item.ITEM_GOAT_HORN = 44
     * }
     */
    public static int ITEM_GOAT_HORN() {
        return ITEM_GOAT_HORN;
    }
    private static final int ITEM_GOLDEN_APPLE = (int)45L;
    /**
     * {@snippet lang=c :
     * enum Item.ITEM_GOLDEN_APPLE = 45
     * }
     */
    public static int ITEM_GOLDEN_APPLE() {
        return ITEM_GOLDEN_APPLE;
    }
    private static final int ITEM_GOLDEN_AXE = (int)46L;
    /**
     * {@snippet lang=c :
     * enum Item.ITEM_GOLDEN_AXE = 46
     * }
     */
    public static int ITEM_GOLDEN_AXE() {
        return ITEM_GOLDEN_AXE;
    }
    private static final int ITEM_GOLDEN_BOOTS = (int)47L;
    /**
     * {@snippet lang=c :
     * enum Item.ITEM_GOLDEN_BOOTS = 47
     * }
     */
    public static int ITEM_GOLDEN_BOOTS() {
        return ITEM_GOLDEN_BOOTS;
    }
    private static final int ITEM_GOLDEN_CARROT = (int)48L;
    /**
     * {@snippet lang=c :
     * enum Item.ITEM_GOLDEN_CARROT = 48
     * }
     */
    public static int ITEM_GOLDEN_CARROT() {
        return ITEM_GOLDEN_CARROT;
    }
    private static final int ITEM_GOLDEN_CHESTPLATE = (int)49L;
    /**
     * {@snippet lang=c :
     * enum Item.ITEM_GOLDEN_CHESTPLATE = 49
     * }
     */
    public static int ITEM_GOLDEN_CHESTPLATE() {
        return ITEM_GOLDEN_CHESTPLATE;
    }
    private static final int ITEM_GOLDEN_HELMET = (int)50L;
    /**
     * {@snippet lang=c :
     * enum Item.ITEM_GOLDEN_HELMET = 50
     * }
     */
    public static int ITEM_GOLDEN_HELMET() {
        return ITEM_GOLDEN_HELMET;
    }
    private static final int ITEM_GOLDEN_HOE = (int)51L;
    /**
     * {@snippet lang=c :
     * enum Item.ITEM_GOLDEN_HOE = 51
     * }
     */
    public static int ITEM_GOLDEN_HOE() {
        return ITEM_GOLDEN_HOE;
    }
    private static final int ITEM_GOLDEN_HORSE_ARMOR = (int)52L;
    /**
     * {@snippet lang=c :
     * enum Item.ITEM_GOLDEN_HORSE_ARMOR = 52
     * }
     */
    public static int ITEM_GOLDEN_HORSE_ARMOR() {
        return ITEM_GOLDEN_HORSE_ARMOR;
    }
    private static final int ITEM_GOLDEN_LEGGINGS = (int)53L;
    /**
     * {@snippet lang=c :
     * enum Item.ITEM_GOLDEN_LEGGINGS = 53
     * }
     */
    public static int ITEM_GOLDEN_LEGGINGS() {
        return ITEM_GOLDEN_LEGGINGS;
    }
    private static final int ITEM_GOLDEN_NAUTILUS_ARMOR = (int)54L;
    /**
     * {@snippet lang=c :
     * enum Item.ITEM_GOLDEN_NAUTILUS_ARMOR = 54
     * }
     */
    public static int ITEM_GOLDEN_NAUTILUS_ARMOR() {
        return ITEM_GOLDEN_NAUTILUS_ARMOR;
    }
    private static final int ITEM_GOLDEN_PICKAXE = (int)55L;
    /**
     * {@snippet lang=c :
     * enum Item.ITEM_GOLDEN_PICKAXE = 55
     * }
     */
    public static int ITEM_GOLDEN_PICKAXE() {
        return ITEM_GOLDEN_PICKAXE;
    }
    private static final int ITEM_GOLDEN_SHOVEL = (int)56L;
    /**
     * {@snippet lang=c :
     * enum Item.ITEM_GOLDEN_SHOVEL = 56
     * }
     */
    public static int ITEM_GOLDEN_SHOVEL() {
        return ITEM_GOLDEN_SHOVEL;
    }
    private static final int ITEM_GOLDEN_SWORD = (int)57L;
    /**
     * {@snippet lang=c :
     * enum Item.ITEM_GOLDEN_SWORD = 57
     * }
     */
    public static int ITEM_GOLDEN_SWORD() {
        return ITEM_GOLDEN_SWORD;
    }
    private static final int ITEM_GOLD_BLOCK = (int)58L;
    /**
     * {@snippet lang=c :
     * enum Item.ITEM_GOLD_BLOCK = 58
     * }
     */
    public static int ITEM_GOLD_BLOCK() {
        return ITEM_GOLD_BLOCK;
    }
    private static final int ITEM_GOLD_INGOT = (int)59L;
    /**
     * {@snippet lang=c :
     * enum Item.ITEM_GOLD_INGOT = 59
     * }
     */
    public static int ITEM_GOLD_INGOT() {
        return ITEM_GOLD_INGOT;
    }
    private static final int ITEM_GOLD_NUGGET = (int)60L;
    /**
     * {@snippet lang=c :
     * enum Item.ITEM_GOLD_NUGGET = 60
     * }
     */
    public static int ITEM_GOLD_NUGGET() {
        return ITEM_GOLD_NUGGET;
    }
    private static final int ITEM_GUNPOWDER = (int)61L;
    /**
     * {@snippet lang=c :
     * enum Item.ITEM_GUNPOWDER = 61
     * }
     */
    public static int ITEM_GUNPOWDER() {
        return ITEM_GUNPOWDER;
    }
    private static final int ITEM_HEART_OF_THE_SEA = (int)62L;
    /**
     * {@snippet lang=c :
     * enum Item.ITEM_HEART_OF_THE_SEA = 62
     * }
     */
    public static int ITEM_HEART_OF_THE_SEA() {
        return ITEM_HEART_OF_THE_SEA;
    }
    private static final int ITEM_IRON_BLOCK = (int)63L;
    /**
     * {@snippet lang=c :
     * enum Item.ITEM_IRON_BLOCK = 63
     * }
     */
    public static int ITEM_IRON_BLOCK() {
        return ITEM_IRON_BLOCK;
    }
    private static final int ITEM_IRON_BOOTS = (int)64L;
    /**
     * {@snippet lang=c :
     * enum Item.ITEM_IRON_BOOTS = 64
     * }
     */
    public static int ITEM_IRON_BOOTS() {
        return ITEM_IRON_BOOTS;
    }
    private static final int ITEM_IRON_CHESTPLATE = (int)65L;
    /**
     * {@snippet lang=c :
     * enum Item.ITEM_IRON_CHESTPLATE = 65
     * }
     */
    public static int ITEM_IRON_CHESTPLATE() {
        return ITEM_IRON_CHESTPLATE;
    }
    private static final int ITEM_IRON_HELMET = (int)66L;
    /**
     * {@snippet lang=c :
     * enum Item.ITEM_IRON_HELMET = 66
     * }
     */
    public static int ITEM_IRON_HELMET() {
        return ITEM_IRON_HELMET;
    }
    private static final int ITEM_IRON_HORSE_ARMOR = (int)67L;
    /**
     * {@snippet lang=c :
     * enum Item.ITEM_IRON_HORSE_ARMOR = 67
     * }
     */
    public static int ITEM_IRON_HORSE_ARMOR() {
        return ITEM_IRON_HORSE_ARMOR;
    }
    private static final int ITEM_IRON_INGOT = (int)68L;
    /**
     * {@snippet lang=c :
     * enum Item.ITEM_IRON_INGOT = 68
     * }
     */
    public static int ITEM_IRON_INGOT() {
        return ITEM_IRON_INGOT;
    }
    private static final int ITEM_IRON_LEGGINGS = (int)69L;
    /**
     * {@snippet lang=c :
     * enum Item.ITEM_IRON_LEGGINGS = 69
     * }
     */
    public static int ITEM_IRON_LEGGINGS() {
        return ITEM_IRON_LEGGINGS;
    }
    private static final int ITEM_IRON_NAUTILUS_ARMOR = (int)70L;
    /**
     * {@snippet lang=c :
     * enum Item.ITEM_IRON_NAUTILUS_ARMOR = 70
     * }
     */
    public static int ITEM_IRON_NAUTILUS_ARMOR() {
        return ITEM_IRON_NAUTILUS_ARMOR;
    }
    private static final int ITEM_IRON_NUGGET = (int)71L;
    /**
     * {@snippet lang=c :
     * enum Item.ITEM_IRON_NUGGET = 71
     * }
     */
    public static int ITEM_IRON_NUGGET() {
        return ITEM_IRON_NUGGET;
    }
    private static final int ITEM_IRON_PICKAXE = (int)72L;
    /**
     * {@snippet lang=c :
     * enum Item.ITEM_IRON_PICKAXE = 72
     * }
     */
    public static int ITEM_IRON_PICKAXE() {
        return ITEM_IRON_PICKAXE;
    }
    private static final int ITEM_IRON_SHOVEL = (int)73L;
    /**
     * {@snippet lang=c :
     * enum Item.ITEM_IRON_SHOVEL = 73
     * }
     */
    public static int ITEM_IRON_SHOVEL() {
        return ITEM_IRON_SHOVEL;
    }
    private static final int ITEM_IRON_SPEAR = (int)74L;
    /**
     * {@snippet lang=c :
     * enum Item.ITEM_IRON_SPEAR = 74
     * }
     */
    public static int ITEM_IRON_SPEAR() {
        return ITEM_IRON_SPEAR;
    }
    private static final int ITEM_IRON_SWORD = (int)75L;
    /**
     * {@snippet lang=c :
     * enum Item.ITEM_IRON_SWORD = 75
     * }
     */
    public static int ITEM_IRON_SWORD() {
        return ITEM_IRON_SWORD;
    }
    private static final int ITEM_LAPIS_LAZULI = (int)76L;
    /**
     * {@snippet lang=c :
     * enum Item.ITEM_LAPIS_LAZULI = 76
     * }
     */
    public static int ITEM_LAPIS_LAZULI() {
        return ITEM_LAPIS_LAZULI;
    }
    private static final int ITEM_LEATHER = (int)77L;
    /**
     * {@snippet lang=c :
     * enum Item.ITEM_LEATHER = 77
     * }
     */
    public static int ITEM_LEATHER() {
        return ITEM_LEATHER;
    }
    private static final int ITEM_LEATHER_BOOTS = (int)78L;
    /**
     * {@snippet lang=c :
     * enum Item.ITEM_LEATHER_BOOTS = 78
     * }
     */
    public static int ITEM_LEATHER_BOOTS() {
        return ITEM_LEATHER_BOOTS;
    }
    private static final int ITEM_LEATHER_CHESTPLATE = (int)79L;
    /**
     * {@snippet lang=c :
     * enum Item.ITEM_LEATHER_CHESTPLATE = 79
     * }
     */
    public static int ITEM_LEATHER_CHESTPLATE() {
        return ITEM_LEATHER_CHESTPLATE;
    }
    private static final int ITEM_LEATHER_HELMET = (int)80L;
    /**
     * {@snippet lang=c :
     * enum Item.ITEM_LEATHER_HELMET = 80
     * }
     */
    public static int ITEM_LEATHER_HELMET() {
        return ITEM_LEATHER_HELMET;
    }
    private static final int ITEM_LEATHER_LEGGINGS = (int)81L;
    /**
     * {@snippet lang=c :
     * enum Item.ITEM_LEATHER_LEGGINGS = 81
     * }
     */
    public static int ITEM_LEATHER_LEGGINGS() {
        return ITEM_LEATHER_LEGGINGS;
    }
    private static final int ITEM_LIGHT_WEIGHTED_PRESSURE_PLATE = (int)82L;
    /**
     * {@snippet lang=c :
     * enum Item.ITEM_LIGHT_WEIGHTED_PRESSURE_PLATE = 82
     * }
     */
    public static int ITEM_LIGHT_WEIGHTED_PRESSURE_PLATE() {
        return ITEM_LIGHT_WEIGHTED_PRESSURE_PLATE;
    }
    private static final int ITEM_LODESTONE = (int)83L;
    /**
     * {@snippet lang=c :
     * enum Item.ITEM_LODESTONE = 83
     * }
     */
    public static int ITEM_LODESTONE() {
        return ITEM_LODESTONE;
    }
    private static final int ITEM_MAGMA_CREAM = (int)84L;
    /**
     * {@snippet lang=c :
     * enum Item.ITEM_MAGMA_CREAM = 84
     * }
     */
    public static int ITEM_MAGMA_CREAM() {
        return ITEM_MAGMA_CREAM;
    }
    private static final int ITEM_MAP = (int)85L;
    /**
     * {@snippet lang=c :
     * enum Item.ITEM_MAP = 85
     * }
     */
    public static int ITEM_MAP() {
        return ITEM_MAP;
    }
    private static final int ITEM_MOSS_BLOCK = (int)86L;
    /**
     * {@snippet lang=c :
     * enum Item.ITEM_MOSS_BLOCK = 86
     * }
     */
    public static int ITEM_MOSS_BLOCK() {
        return ITEM_MOSS_BLOCK;
    }
    private static final int ITEM_MUSIC_DISC_PIGSTEP = (int)87L;
    /**
     * {@snippet lang=c :
     * enum Item.ITEM_MUSIC_DISC_PIGSTEP = 87
     * }
     */
    public static int ITEM_MUSIC_DISC_PIGSTEP() {
        return ITEM_MUSIC_DISC_PIGSTEP;
    }
    private static final int ITEM_NETHERITE_SCRAP = (int)88L;
    /**
     * {@snippet lang=c :
     * enum Item.ITEM_NETHERITE_SCRAP = 88
     * }
     */
    public static int ITEM_NETHERITE_SCRAP() {
        return ITEM_NETHERITE_SCRAP;
    }
    private static final int ITEM_NETHERITE_UPGRADE_SMITHING_TEMPLATE = (int)89L;
    /**
     * {@snippet lang=c :
     * enum Item.ITEM_NETHERITE_UPGRADE_SMITHING_TEMPLATE = 89
     * }
     */
    public static int ITEM_NETHERITE_UPGRADE_SMITHING_TEMPLATE() {
        return ITEM_NETHERITE_UPGRADE_SMITHING_TEMPLATE;
    }
    private static final int ITEM_NETHER_WART = (int)90L;
    /**
     * {@snippet lang=c :
     * enum Item.ITEM_NETHER_WART = 90
     * }
     */
    public static int ITEM_NETHER_WART() {
        return ITEM_NETHER_WART;
    }
    private static final int ITEM_OBSIDIAN = (int)91L;
    /**
     * {@snippet lang=c :
     * enum Item.ITEM_OBSIDIAN = 91
     * }
     */
    public static int ITEM_OBSIDIAN() {
        return ITEM_OBSIDIAN;
    }
    private static final int ITEM_PAPER = (int)92L;
    /**
     * {@snippet lang=c :
     * enum Item.ITEM_PAPER = 92
     * }
     */
    public static int ITEM_PAPER() {
        return ITEM_PAPER;
    }
    private static final int ITEM_PIGLIN_BANNER_PATTERN = (int)93L;
    /**
     * {@snippet lang=c :
     * enum Item.ITEM_PIGLIN_BANNER_PATTERN = 93
     * }
     */
    public static int ITEM_PIGLIN_BANNER_PATTERN() {
        return ITEM_PIGLIN_BANNER_PATTERN;
    }
    private static final int ITEM_POISONOUS_POTATO = (int)94L;
    /**
     * {@snippet lang=c :
     * enum Item.ITEM_POISONOUS_POTATO = 94
     * }
     */
    public static int ITEM_POISONOUS_POTATO() {
        return ITEM_POISONOUS_POTATO;
    }
    private static final int ITEM_POTION = (int)95L;
    /**
     * {@snippet lang=c :
     * enum Item.ITEM_POTION = 95
     * }
     */
    public static int ITEM_POTION() {
        return ITEM_POTION;
    }
    private static final int ITEM_POTATO = (int)96L;
    /**
     * {@snippet lang=c :
     * enum Item.ITEM_POTATO = 96
     * }
     */
    public static int ITEM_POTATO() {
        return ITEM_POTATO;
    }
    private static final int ITEM_PRISMARINE_CRYSTALS = (int)97L;
    /**
     * {@snippet lang=c :
     * enum Item.ITEM_PRISMARINE_CRYSTALS = 97
     * }
     */
    public static int ITEM_PRISMARINE_CRYSTALS() {
        return ITEM_PRISMARINE_CRYSTALS;
    }
    private static final int ITEM_PUMPKIN = (int)98L;
    /**
     * {@snippet lang=c :
     * enum Item.ITEM_PUMPKIN = 98
     * }
     */
    public static int ITEM_PUMPKIN() {
        return ITEM_PUMPKIN;
    }
    private static final int ITEM_RIB_ARMOR_TRIM_SMITHING_TEMPLATE = (int)99L;
    /**
     * {@snippet lang=c :
     * enum Item.ITEM_RIB_ARMOR_TRIM_SMITHING_TEMPLATE = 99
     * }
     */
    public static int ITEM_RIB_ARMOR_TRIM_SMITHING_TEMPLATE() {
        return ITEM_RIB_ARMOR_TRIM_SMITHING_TEMPLATE;
    }
    private static final int ITEM_ROTTEN_FLESH = (int)100L;
    /**
     * {@snippet lang=c :
     * enum Item.ITEM_ROTTEN_FLESH = 100
     * }
     */
    public static int ITEM_ROTTEN_FLESH() {
        return ITEM_ROTTEN_FLESH;
    }
    private static final int ITEM_SADDLE = (int)101L;
    /**
     * {@snippet lang=c :
     * enum Item.ITEM_SADDLE = 101
     * }
     */
    public static int ITEM_SADDLE() {
        return ITEM_SADDLE;
    }
    private static final int ITEM_SAND = (int)102L;
    /**
     * {@snippet lang=c :
     * enum Item.ITEM_SAND = 102
     * }
     */
    public static int ITEM_SAND() {
        return ITEM_SAND;
    }
    private static final int ITEM_SENTRY_ARMOR_TRIM_SMITHING_TEMPLATE = (int)103L;
    /**
     * {@snippet lang=c :
     * enum Item.ITEM_SENTRY_ARMOR_TRIM_SMITHING_TEMPLATE = 103
     * }
     */
    public static int ITEM_SENTRY_ARMOR_TRIM_SMITHING_TEMPLATE() {
        return ITEM_SENTRY_ARMOR_TRIM_SMITHING_TEMPLATE;
    }
    private static final int ITEM_SNOUT_ARMOR_TRIM_SMITHING_TEMPLATE = (int)104L;
    /**
     * {@snippet lang=c :
     * enum Item.ITEM_SNOUT_ARMOR_TRIM_SMITHING_TEMPLATE = 104
     * }
     */
    public static int ITEM_SNOUT_ARMOR_TRIM_SMITHING_TEMPLATE() {
        return ITEM_SNOUT_ARMOR_TRIM_SMITHING_TEMPLATE;
    }
    private static final int ITEM_SPECTRAL_ARROW = (int)105L;
    /**
     * {@snippet lang=c :
     * enum Item.ITEM_SPECTRAL_ARROW = 105
     * }
     */
    public static int ITEM_SPECTRAL_ARROW() {
        return ITEM_SPECTRAL_ARROW;
    }
    private static final int ITEM_SPIDER_EYE = (int)106L;
    /**
     * {@snippet lang=c :
     * enum Item.ITEM_SPIDER_EYE = 106
     * }
     */
    public static int ITEM_SPIDER_EYE() {
        return ITEM_SPIDER_EYE;
    }
    private static final int ITEM_SPIRE_ARMOR_TRIM_SMITHING_TEMPLATE = (int)107L;
    /**
     * {@snippet lang=c :
     * enum Item.ITEM_SPIRE_ARMOR_TRIM_SMITHING_TEMPLATE = 107
     * }
     */
    public static int ITEM_SPIRE_ARMOR_TRIM_SMITHING_TEMPLATE() {
        return ITEM_SPIRE_ARMOR_TRIM_SMITHING_TEMPLATE;
    }
    private static final int ITEM_STONE_AXE = (int)108L;
    /**
     * {@snippet lang=c :
     * enum Item.ITEM_STONE_AXE = 108
     * }
     */
    public static int ITEM_STONE_AXE() {
        return ITEM_STONE_AXE;
    }
    private static final int ITEM_STRING = (int)109L;
    /**
     * {@snippet lang=c :
     * enum Item.ITEM_STRING = 109
     * }
     */
    public static int ITEM_STRING() {
        return ITEM_STRING;
    }
    private static final int ITEM_SUSPICIOUS_STEW = (int)110L;
    /**
     * {@snippet lang=c :
     * enum Item.ITEM_SUSPICIOUS_STEW = 110
     * }
     */
    public static int ITEM_SUSPICIOUS_STEW() {
        return ITEM_SUSPICIOUS_STEW;
    }
    private static final int ITEM_TNT = (int)111L;
    /**
     * {@snippet lang=c :
     * enum Item.ITEM_TNT = 111
     * }
     */
    public static int ITEM_TNT() {
        return ITEM_TNT;
    }
    private static final int ITEM_TRIPWIRE_HOOK = (int)112L;
    /**
     * {@snippet lang=c :
     * enum Item.ITEM_TRIPWIRE_HOOK = 112
     * }
     */
    public static int ITEM_TRIPWIRE_HOOK() {
        return ITEM_TRIPWIRE_HOOK;
    }
    private static final int ITEM_WHEAT = (int)113L;
    /**
     * {@snippet lang=c :
     * enum Item.ITEM_WHEAT = 113
     * }
     */
    public static int ITEM_WHEAT() {
        return ITEM_WHEAT;
    }
    private static final int ITEM_WILD_ARMOR_TRIM_SMITHING_TEMPLATE = (int)114L;
    /**
     * {@snippet lang=c :
     * enum Item.ITEM_WILD_ARMOR_TRIM_SMITHING_TEMPLATE = 114
     * }
     */
    public static int ITEM_WILD_ARMOR_TRIM_SMITHING_TEMPLATE() {
        return ITEM_WILD_ARMOR_TRIM_SMITHING_TEMPLATE;
    }
    private static final int NUM_ITEMS = (int)115L;
    /**
     * {@snippet lang=c :
     * enum Item.NUM_ITEMS = 115
     * }
     */
    public static int NUM_ITEMS() {
        return NUM_ITEMS;
    }

    private static class item_name2global_id {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Cubiomes.C_INT,
            Cubiomes.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("item_name2global_id");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int item_name2global_id(const char *name)
     * }
     */
    public static FunctionDescriptor item_name2global_id$descriptor() {
        return item_name2global_id.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int item_name2global_id(const char *name)
     * }
     */
    public static MethodHandle item_name2global_id$handle() {
        return item_name2global_id.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int item_name2global_id(const char *name)
     * }
     */
    public static MemorySegment item_name2global_id$address() {
        return item_name2global_id.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int item_name2global_id(const char *name)
     * }
     */
    public static int item_name2global_id(MemorySegment name) {
        var mh$ = item_name2global_id.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("item_name2global_id", name);
            }
            return (int)mh$.invokeExact(name);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class global_id2item_name {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Cubiomes.C_POINTER,
            Cubiomes.C_INT,
            Cubiomes.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("global_id2item_name");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * const char *global_id2item_name(int global_id, int mc)
     * }
     */
    public static FunctionDescriptor global_id2item_name$descriptor() {
        return global_id2item_name.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * const char *global_id2item_name(int global_id, int mc)
     * }
     */
    public static MethodHandle global_id2item_name$handle() {
        return global_id2item_name.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * const char *global_id2item_name(int global_id, int mc)
     * }
     */
    public static MemorySegment global_id2item_name$address() {
        return global_id2item_name.ADDR;
    }

    /**
     * {@snippet lang=c :
     * const char *global_id2item_name(int global_id, int mc)
     * }
     */
    public static MemorySegment global_id2item_name(int global_id, int mc) {
        var mh$ = global_id2item_name.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("global_id2item_name", global_id, mc);
            }
            return (MemorySegment)mh$.invokeExact(global_id, mc);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    private static final int NO_ITEM = (int)0L;
    /**
     * {@snippet lang=c :
     * enum ItemType.NO_ITEM = 0
     * }
     */
    public static int NO_ITEM() {
        return NO_ITEM;
    }
    private static final int HELMET = (int)1L;
    /**
     * {@snippet lang=c :
     * enum ItemType.HELMET = 1
     * }
     */
    public static int HELMET() {
        return HELMET;
    }
    private static final int CHESTPLATE = (int)2L;
    /**
     * {@snippet lang=c :
     * enum ItemType.CHESTPLATE = 2
     * }
     */
    public static int CHESTPLATE() {
        return CHESTPLATE;
    }
    private static final int LEGGINGS = (int)3L;
    /**
     * {@snippet lang=c :
     * enum ItemType.LEGGINGS = 3
     * }
     */
    public static int LEGGINGS() {
        return LEGGINGS;
    }
    private static final int BOOTS = (int)4L;
    /**
     * {@snippet lang=c :
     * enum ItemType.BOOTS = 4
     * }
     */
    public static int BOOTS() {
        return BOOTS;
    }
    private static final int SWORD = (int)5L;
    /**
     * {@snippet lang=c :
     * enum ItemType.SWORD = 5
     * }
     */
    public static int SWORD() {
        return SWORD;
    }
    private static final int PICKAXE = (int)6L;
    /**
     * {@snippet lang=c :
     * enum ItemType.PICKAXE = 6
     * }
     */
    public static int PICKAXE() {
        return PICKAXE;
    }
    private static final int SHOVEL = (int)7L;
    /**
     * {@snippet lang=c :
     * enum ItemType.SHOVEL = 7
     * }
     */
    public static int SHOVEL() {
        return SHOVEL;
    }
    private static final int AXE = (int)8L;
    /**
     * {@snippet lang=c :
     * enum ItemType.AXE = 8
     * }
     */
    public static int AXE() {
        return AXE;
    }
    private static final int HOE = (int)9L;
    /**
     * {@snippet lang=c :
     * enum ItemType.HOE = 9
     * }
     */
    public static int HOE() {
        return HOE;
    }
    private static final int FISHING_ROD = (int)10L;
    /**
     * {@snippet lang=c :
     * enum ItemType.FISHING_ROD = 10
     * }
     */
    public static int FISHING_ROD() {
        return FISHING_ROD;
    }
    private static final int BOW = (int)11L;
    /**
     * {@snippet lang=c :
     * enum ItemType.BOW = 11
     * }
     */
    public static int BOW() {
        return BOW;
    }
    private static final int CROSSBOW = (int)12L;
    /**
     * {@snippet lang=c :
     * enum ItemType.CROSSBOW = 12
     * }
     */
    public static int CROSSBOW() {
        return CROSSBOW;
    }
    private static final int TRIDENT = (int)13L;
    /**
     * {@snippet lang=c :
     * enum ItemType.TRIDENT = 13
     * }
     */
    public static int TRIDENT() {
        return TRIDENT;
    }
    private static final int MACE = (int)14L;
    /**
     * {@snippet lang=c :
     * enum ItemType.MACE = 14
     * }
     */
    public static int MACE() {
        return MACE;
    }
    private static final int BOOK = (int)15L;
    /**
     * {@snippet lang=c :
     * enum ItemType.BOOK = 15
     * }
     */
    public static int BOOK() {
        return BOOK;
    }
    private static final int NO_ENCHANTMENT = (int)0L;
    /**
     * {@snippet lang=c :
     * enum Enchantment.NO_ENCHANTMENT = 0
     * }
     */
    public static int NO_ENCHANTMENT() {
        return NO_ENCHANTMENT;
    }
    private static final int PROTECTION = (int)1L;
    /**
     * {@snippet lang=c :
     * enum Enchantment.PROTECTION = 1
     * }
     */
    public static int PROTECTION() {
        return PROTECTION;
    }
    private static final int FIRE_PROTECTION = (int)2L;
    /**
     * {@snippet lang=c :
     * enum Enchantment.FIRE_PROTECTION = 2
     * }
     */
    public static int FIRE_PROTECTION() {
        return FIRE_PROTECTION;
    }
    private static final int BLAST_PROTECTION = (int)3L;
    /**
     * {@snippet lang=c :
     * enum Enchantment.BLAST_PROTECTION = 3
     * }
     */
    public static int BLAST_PROTECTION() {
        return BLAST_PROTECTION;
    }
    private static final int PROJECTILE_PROTECTION = (int)4L;
    /**
     * {@snippet lang=c :
     * enum Enchantment.PROJECTILE_PROTECTION = 4
     * }
     */
    public static int PROJECTILE_PROTECTION() {
        return PROJECTILE_PROTECTION;
    }
    private static final int RESPIRATION = (int)5L;
    /**
     * {@snippet lang=c :
     * enum Enchantment.RESPIRATION = 5
     * }
     */
    public static int RESPIRATION() {
        return RESPIRATION;
    }
    private static final int AQUA_AFFINITY = (int)6L;
    /**
     * {@snippet lang=c :
     * enum Enchantment.AQUA_AFFINITY = 6
     * }
     */
    public static int AQUA_AFFINITY() {
        return AQUA_AFFINITY;
    }
    private static final int THORNS = (int)7L;
    /**
     * {@snippet lang=c :
     * enum Enchantment.THORNS = 7
     * }
     */
    public static int THORNS() {
        return THORNS;
    }
    private static final int SWIFT_SNEAK = (int)8L;
    /**
     * {@snippet lang=c :
     * enum Enchantment.SWIFT_SNEAK = 8
     * }
     */
    public static int SWIFT_SNEAK() {
        return SWIFT_SNEAK;
    }
    private static final int FEATHER_FALLING = (int)9L;
    /**
     * {@snippet lang=c :
     * enum Enchantment.FEATHER_FALLING = 9
     * }
     */
    public static int FEATHER_FALLING() {
        return FEATHER_FALLING;
    }
    private static final int DEPTH_STRIDER = (int)10L;
    /**
     * {@snippet lang=c :
     * enum Enchantment.DEPTH_STRIDER = 10
     * }
     */
    public static int DEPTH_STRIDER() {
        return DEPTH_STRIDER;
    }
    private static final int FROST_WALKER = (int)11L;
    /**
     * {@snippet lang=c :
     * enum Enchantment.FROST_WALKER = 11
     * }
     */
    public static int FROST_WALKER() {
        return FROST_WALKER;
    }
    private static final int SOUL_SPEED = (int)12L;
    /**
     * {@snippet lang=c :
     * enum Enchantment.SOUL_SPEED = 12
     * }
     */
    public static int SOUL_SPEED() {
        return SOUL_SPEED;
    }
    private static final int SHARPNESS = (int)13L;
    /**
     * {@snippet lang=c :
     * enum Enchantment.SHARPNESS = 13
     * }
     */
    public static int SHARPNESS() {
        return SHARPNESS;
    }
    private static final int SMITE = (int)14L;
    /**
     * {@snippet lang=c :
     * enum Enchantment.SMITE = 14
     * }
     */
    public static int SMITE() {
        return SMITE;
    }
    private static final int BANE_OF_ARTHROPODS = (int)15L;
    /**
     * {@snippet lang=c :
     * enum Enchantment.BANE_OF_ARTHROPODS = 15
     * }
     */
    public static int BANE_OF_ARTHROPODS() {
        return BANE_OF_ARTHROPODS;
    }
    private static final int KNOCKBACK = (int)16L;
    /**
     * {@snippet lang=c :
     * enum Enchantment.KNOCKBACK = 16
     * }
     */
    public static int KNOCKBACK() {
        return KNOCKBACK;
    }
    private static final int FIRE_ASPECT = (int)17L;
    /**
     * {@snippet lang=c :
     * enum Enchantment.FIRE_ASPECT = 17
     * }
     */
    public static int FIRE_ASPECT() {
        return FIRE_ASPECT;
    }
    private static final int LOOTING = (int)18L;
    /**
     * {@snippet lang=c :
     * enum Enchantment.LOOTING = 18
     * }
     */
    public static int LOOTING() {
        return LOOTING;
    }
    private static final int SWEEPING_EDGE = (int)19L;
    /**
     * {@snippet lang=c :
     * enum Enchantment.SWEEPING_EDGE = 19
     * }
     */
    public static int SWEEPING_EDGE() {
        return SWEEPING_EDGE;
    }
    private static final int EFFICIENCY = (int)20L;
    /**
     * {@snippet lang=c :
     * enum Enchantment.EFFICIENCY = 20
     * }
     */
    public static int EFFICIENCY() {
        return EFFICIENCY;
    }
    private static final int SILK_TOUCH = (int)21L;
    /**
     * {@snippet lang=c :
     * enum Enchantment.SILK_TOUCH = 21
     * }
     */
    public static int SILK_TOUCH() {
        return SILK_TOUCH;
    }
    private static final int FORTUNE = (int)22L;
    /**
     * {@snippet lang=c :
     * enum Enchantment.FORTUNE = 22
     * }
     */
    public static int FORTUNE() {
        return FORTUNE;
    }
    private static final int LUCK_OF_THE_SEA = (int)23L;
    /**
     * {@snippet lang=c :
     * enum Enchantment.LUCK_OF_THE_SEA = 23
     * }
     */
    public static int LUCK_OF_THE_SEA() {
        return LUCK_OF_THE_SEA;
    }
    private static final int LURE = (int)24L;
    /**
     * {@snippet lang=c :
     * enum Enchantment.LURE = 24
     * }
     */
    public static int LURE() {
        return LURE;
    }
    private static final int POWER = (int)25L;
    /**
     * {@snippet lang=c :
     * enum Enchantment.POWER = 25
     * }
     */
    public static int POWER() {
        return POWER;
    }
    private static final int PUNCH = (int)26L;
    /**
     * {@snippet lang=c :
     * enum Enchantment.PUNCH = 26
     * }
     */
    public static int PUNCH() {
        return PUNCH;
    }
    private static final int FLAME = (int)27L;
    /**
     * {@snippet lang=c :
     * enum Enchantment.FLAME = 27
     * }
     */
    public static int FLAME() {
        return FLAME;
    }
    private static final int INFINITY_ENCHANTMENT = (int)28L;
    /**
     * {@snippet lang=c :
     * enum Enchantment.INFINITY_ENCHANTMENT = 28
     * }
     */
    public static int INFINITY_ENCHANTMENT() {
        return INFINITY_ENCHANTMENT;
    }
    private static final int QUICK_CHARGE = (int)29L;
    /**
     * {@snippet lang=c :
     * enum Enchantment.QUICK_CHARGE = 29
     * }
     */
    public static int QUICK_CHARGE() {
        return QUICK_CHARGE;
    }
    private static final int MULTISHOT = (int)30L;
    /**
     * {@snippet lang=c :
     * enum Enchantment.MULTISHOT = 30
     * }
     */
    public static int MULTISHOT() {
        return MULTISHOT;
    }
    private static final int PIERCING = (int)31L;
    /**
     * {@snippet lang=c :
     * enum Enchantment.PIERCING = 31
     * }
     */
    public static int PIERCING() {
        return PIERCING;
    }
    private static final int IMPALING = (int)32L;
    /**
     * {@snippet lang=c :
     * enum Enchantment.IMPALING = 32
     * }
     */
    public static int IMPALING() {
        return IMPALING;
    }
    private static final int RIPTIDE = (int)33L;
    /**
     * {@snippet lang=c :
     * enum Enchantment.RIPTIDE = 33
     * }
     */
    public static int RIPTIDE() {
        return RIPTIDE;
    }
    private static final int LOYALTY = (int)34L;
    /**
     * {@snippet lang=c :
     * enum Enchantment.LOYALTY = 34
     * }
     */
    public static int LOYALTY() {
        return LOYALTY;
    }
    private static final int CHANNELING = (int)35L;
    /**
     * {@snippet lang=c :
     * enum Enchantment.CHANNELING = 35
     * }
     */
    public static int CHANNELING() {
        return CHANNELING;
    }
    private static final int DENSITY = (int)36L;
    /**
     * {@snippet lang=c :
     * enum Enchantment.DENSITY = 36
     * }
     */
    public static int DENSITY() {
        return DENSITY;
    }
    private static final int BREACH = (int)37L;
    /**
     * {@snippet lang=c :
     * enum Enchantment.BREACH = 37
     * }
     */
    public static int BREACH() {
        return BREACH;
    }
    private static final int WIND_BURST = (int)38L;
    /**
     * {@snippet lang=c :
     * enum Enchantment.WIND_BURST = 38
     * }
     */
    public static int WIND_BURST() {
        return WIND_BURST;
    }
    private static final int MENDING = (int)39L;
    /**
     * {@snippet lang=c :
     * enum Enchantment.MENDING = 39
     * }
     */
    public static int MENDING() {
        return MENDING;
    }
    private static final int UNBREAKING = (int)40L;
    /**
     * {@snippet lang=c :
     * enum Enchantment.UNBREAKING = 40
     * }
     */
    public static int UNBREAKING() {
        return UNBREAKING;
    }
    private static final int CURSE_OF_VANISHING = (int)41L;
    /**
     * {@snippet lang=c :
     * enum Enchantment.CURSE_OF_VANISHING = 41
     * }
     */
    public static int CURSE_OF_VANISHING() {
        return CURSE_OF_VANISHING;
    }
    private static final int CURSE_OF_BINDING = (int)42L;
    /**
     * {@snippet lang=c :
     * enum Enchantment.CURSE_OF_BINDING = 42
     * }
     */
    public static int CURSE_OF_BINDING() {
        return CURSE_OF_BINDING;
    }

    private static class create_set_count {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            Cubiomes.C_POINTER,
            Cubiomes.C_INT,
            Cubiomes.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("create_set_count");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void create_set_count(LootFunction *lf, const int min, const int max)
     * }
     */
    public static FunctionDescriptor create_set_count$descriptor() {
        return create_set_count.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void create_set_count(LootFunction *lf, const int min, const int max)
     * }
     */
    public static MethodHandle create_set_count$handle() {
        return create_set_count.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void create_set_count(LootFunction *lf, const int min, const int max)
     * }
     */
    public static MemorySegment create_set_count$address() {
        return create_set_count.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void create_set_count(LootFunction *lf, const int min, const int max)
     * }
     */
    public static void create_set_count(MemorySegment lf, int min, int max) {
        var mh$ = create_set_count.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("create_set_count", lf, min, max);
            }
            mh$.invokeExact(lf, min, max);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class create_set_effect {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            Cubiomes.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("create_set_effect");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void create_set_effect(LootFunction *lf)
     * }
     */
    public static FunctionDescriptor create_set_effect$descriptor() {
        return create_set_effect.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void create_set_effect(LootFunction *lf)
     * }
     */
    public static MethodHandle create_set_effect$handle() {
        return create_set_effect.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void create_set_effect(LootFunction *lf)
     * }
     */
    public static MemorySegment create_set_effect$address() {
        return create_set_effect.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void create_set_effect(LootFunction *lf)
     * }
     */
    public static void create_set_effect(MemorySegment lf) {
        var mh$ = create_set_effect.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("create_set_effect", lf);
            }
            mh$.invokeExact(lf);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class create_set_damage {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            Cubiomes.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("create_set_damage");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void create_set_damage(LootFunction *lf)
     * }
     */
    public static FunctionDescriptor create_set_damage$descriptor() {
        return create_set_damage.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void create_set_damage(LootFunction *lf)
     * }
     */
    public static MethodHandle create_set_damage$handle() {
        return create_set_damage.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void create_set_damage(LootFunction *lf)
     * }
     */
    public static MemorySegment create_set_damage$address() {
        return create_set_damage.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void create_set_damage(LootFunction *lf)
     * }
     */
    public static void create_set_damage(MemorySegment lf) {
        var mh$ = create_set_damage.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("create_set_damage", lf);
            }
            mh$.invokeExact(lf);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class create_skip_calls {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            Cubiomes.C_POINTER,
            Cubiomes.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("create_skip_calls");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void create_skip_calls(LootFunction *lf, const int skip_count)
     * }
     */
    public static FunctionDescriptor create_skip_calls$descriptor() {
        return create_skip_calls.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void create_skip_calls(LootFunction *lf, const int skip_count)
     * }
     */
    public static MethodHandle create_skip_calls$handle() {
        return create_skip_calls.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void create_skip_calls(LootFunction *lf, const int skip_count)
     * }
     */
    public static MemorySegment create_skip_calls$address() {
        return create_skip_calls.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void create_skip_calls(LootFunction *lf, const int skip_count)
     * }
     */
    public static void create_skip_calls(MemorySegment lf, int skip_count) {
        var mh$ = create_skip_calls.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("create_skip_calls", lf, skip_count);
            }
            mh$.invokeExact(lf, skip_count);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class create_no_op {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            Cubiomes.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("create_no_op");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void create_no_op(LootFunction *lf)
     * }
     */
    public static FunctionDescriptor create_no_op$descriptor() {
        return create_no_op.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void create_no_op(LootFunction *lf)
     * }
     */
    public static MethodHandle create_no_op$handle() {
        return create_no_op.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void create_no_op(LootFunction *lf)
     * }
     */
    public static MemorySegment create_no_op$address() {
        return create_no_op.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void create_no_op(LootFunction *lf)
     * }
     */
    public static void create_no_op(MemorySegment lf) {
        var mh$ = create_no_op.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("create_no_op", lf);
            }
            mh$.invokeExact(lf);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class create_enchant_randomly_one_enchant {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            Cubiomes.C_POINTER,
            Cubiomes.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("create_enchant_randomly_one_enchant");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void create_enchant_randomly_one_enchant(LootFunction *lf, const Enchantment enchantment)
     * }
     */
    public static FunctionDescriptor create_enchant_randomly_one_enchant$descriptor() {
        return create_enchant_randomly_one_enchant.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void create_enchant_randomly_one_enchant(LootFunction *lf, const Enchantment enchantment)
     * }
     */
    public static MethodHandle create_enchant_randomly_one_enchant$handle() {
        return create_enchant_randomly_one_enchant.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void create_enchant_randomly_one_enchant(LootFunction *lf, const Enchantment enchantment)
     * }
     */
    public static MemorySegment create_enchant_randomly_one_enchant$address() {
        return create_enchant_randomly_one_enchant.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void create_enchant_randomly_one_enchant(LootFunction *lf, const Enchantment enchantment)
     * }
     */
    public static void create_enchant_randomly_one_enchant(MemorySegment lf, int enchantment) {
        var mh$ = create_enchant_randomly_one_enchant.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("create_enchant_randomly_one_enchant", lf, enchantment);
            }
            mh$.invokeExact(lf, enchantment);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class create_enchant_randomly_list {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            Cubiomes.C_POINTER,
            Cubiomes.C_POINTER,
            Cubiomes.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("create_enchant_randomly_list");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void create_enchant_randomly_list(LootFunction *lf, const Enchantment *list, const int list_length)
     * }
     */
    public static FunctionDescriptor create_enchant_randomly_list$descriptor() {
        return create_enchant_randomly_list.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void create_enchant_randomly_list(LootFunction *lf, const Enchantment *list, const int list_length)
     * }
     */
    public static MethodHandle create_enchant_randomly_list$handle() {
        return create_enchant_randomly_list.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void create_enchant_randomly_list(LootFunction *lf, const Enchantment *list, const int list_length)
     * }
     */
    public static MemorySegment create_enchant_randomly_list$address() {
        return create_enchant_randomly_list.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void create_enchant_randomly_list(LootFunction *lf, const Enchantment *list, const int list_length)
     * }
     */
    public static void create_enchant_randomly_list(MemorySegment lf, MemorySegment list, int list_length) {
        var mh$ = create_enchant_randomly_list.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("create_enchant_randomly_list", lf, list, list_length);
            }
            mh$.invokeExact(lf, list, list_length);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class create_enchant_randomly {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            Cubiomes.C_POINTER,
            Cubiomes.C_INT,
            Cubiomes.C_INT,
            Cubiomes.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("create_enchant_randomly");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void create_enchant_randomly(LootFunction *lf, const int version, const ItemType item, const int isTreasure)
     * }
     */
    public static FunctionDescriptor create_enchant_randomly$descriptor() {
        return create_enchant_randomly.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void create_enchant_randomly(LootFunction *lf, const int version, const ItemType item, const int isTreasure)
     * }
     */
    public static MethodHandle create_enchant_randomly$handle() {
        return create_enchant_randomly.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void create_enchant_randomly(LootFunction *lf, const int version, const ItemType item, const int isTreasure)
     * }
     */
    public static MemorySegment create_enchant_randomly$address() {
        return create_enchant_randomly.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void create_enchant_randomly(LootFunction *lf, const int version, const ItemType item, const int isTreasure)
     * }
     */
    public static void create_enchant_randomly(MemorySegment lf, int version, int item, int isTreasure) {
        var mh$ = create_enchant_randomly.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("create_enchant_randomly", lf, version, item, isTreasure);
            }
            mh$.invokeExact(lf, version, item, isTreasure);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class create_enchant_with_levels {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            Cubiomes.C_POINTER,
            Cubiomes.C_INT,
            Cubiomes.C_POINTER,
            Cubiomes.C_INT,
            Cubiomes.C_INT,
            Cubiomes.C_INT,
            Cubiomes.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("create_enchant_with_levels");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void create_enchant_with_levels(LootFunction *lf, const int version, const char *item_name, const ItemType item_type, const int min_level, const int max_level, const int isTreasure)
     * }
     */
    public static FunctionDescriptor create_enchant_with_levels$descriptor() {
        return create_enchant_with_levels.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void create_enchant_with_levels(LootFunction *lf, const int version, const char *item_name, const ItemType item_type, const int min_level, const int max_level, const int isTreasure)
     * }
     */
    public static MethodHandle create_enchant_with_levels$handle() {
        return create_enchant_with_levels.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void create_enchant_with_levels(LootFunction *lf, const int version, const char *item_name, const ItemType item_type, const int min_level, const int max_level, const int isTreasure)
     * }
     */
    public static MemorySegment create_enchant_with_levels$address() {
        return create_enchant_with_levels.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void create_enchant_with_levels(LootFunction *lf, const int version, const char *item_name, const ItemType item_type, const int min_level, const int max_level, const int isTreasure)
     * }
     */
    public static void create_enchant_with_levels(MemorySegment lf, int version, MemorySegment item_name, int item_type, int min_level, int max_level, int isTreasure) {
        var mh$ = create_enchant_with_levels.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("create_enchant_with_levels", lf, version, item_name, item_type, min_level, max_level, isTreasure);
            }
            mh$.invokeExact(lf, version, item_name, item_type, min_level, max_level, isTreasure);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class get_enchantment_name {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Cubiomes.C_POINTER,
            Cubiomes.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("get_enchantment_name");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * const char *get_enchantment_name(const Enchantment enchantment)
     * }
     */
    public static FunctionDescriptor get_enchantment_name$descriptor() {
        return get_enchantment_name.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * const char *get_enchantment_name(const Enchantment enchantment)
     * }
     */
    public static MethodHandle get_enchantment_name$handle() {
        return get_enchantment_name.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * const char *get_enchantment_name(const Enchantment enchantment)
     * }
     */
    public static MemorySegment get_enchantment_name$address() {
        return get_enchantment_name.ADDR;
    }

    /**
     * {@snippet lang=c :
     * const char *get_enchantment_name(const Enchantment enchantment)
     * }
     */
    public static MemorySegment get_enchantment_name(int enchantment) {
        var mh$ = get_enchantment_name.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("get_enchantment_name", enchantment);
            }
            return (MemorySegment)mh$.invokeExact(enchantment);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    /**
     * Variadic invoker class for:
     * {@snippet lang=c :
     * void test_enchant_vec()
     * }
     */
    public static class test_enchant_vec {
        private static final FunctionDescriptor BASE_DESC = FunctionDescriptor.ofVoid(        );
        private static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("test_enchant_vec");

        private final MethodHandle handle;
        private final FunctionDescriptor descriptor;
        private final MethodHandle spreader;

        private test_enchant_vec(MethodHandle handle, FunctionDescriptor descriptor, MethodHandle spreader) {
            this.handle = handle;
            this.descriptor = descriptor;
            this.spreader = spreader;
        }

        /**
         * Variadic invoker factory for:
         * {@snippet lang=c :
         * void test_enchant_vec()
         * }
         */
        public static test_enchant_vec makeInvoker(MemoryLayout... layouts) {
            FunctionDescriptor desc$ = BASE_DESC.appendArgumentLayouts(layouts);
            Linker.Option fva$ = Linker.Option.firstVariadicArg(BASE_DESC.argumentLayouts().size());
            var mh$ = Linker.nativeLinker().downcallHandle(ADDR, desc$, fva$);
            var spreader$ = mh$.asSpreader(Object[].class, layouts.length);
            return new test_enchant_vec(mh$, desc$, spreader$);
        }

        /**
         * {@return the address}
         */
        public static MemorySegment address() {
            return ADDR;
        }

        /**
         * {@return the specialized method handle}
         */
        public MethodHandle handle() {
            return handle;
        }

        /**
         * {@return the specialized descriptor}
         */
        public FunctionDescriptor descriptor() {
            return descriptor;
        }

        public void apply(Object... x0) {
            try {
                if (TRACE_DOWNCALLS) {
                    traceDowncall("test_enchant_vec", x0);
                }
                 spreader.invokeExact(x0);
            } catch(IllegalArgumentException | ClassCastException ex$)  {
                throw ex$; // rethrow IAE from passing wrong number/type of args
            } catch (Throwable ex$) {
               throw new AssertionError("should not reach here", ex$);
            }
        }
    }
    private static final int GENERATE_NATURAL = (int)0L;
    /**
     * {@snippet lang=c :
     * enum GenerationMode.GENERATE_NATURAL = 0
     * }
     */
    public static int GENERATE_NATURAL() {
        return GENERATE_NATURAL;
    }
    private static final int GENERATE_INDEXED = (int)1L;
    /**
     * {@snippet lang=c :
     * enum GenerationMode.GENERATE_INDEXED = 1
     * }
     */
    public static int GENERATE_INDEXED() {
        return GENERATE_INDEXED;
    }
    private static final int GENERATE_AGGREGATED = (int)2L;
    /**
     * {@snippet lang=c :
     * enum GenerationMode.GENERATE_AGGREGATED = 2
     * }
     */
    public static int GENERATE_AGGREGATED() {
        return GENERATE_AGGREGATED;
    }
    private static final int SKIP_ENCHANTMENTS = (int)4L;
    /**
     * {@snippet lang=c :
     * enum GenerationMode.SKIP_ENCHANTMENTS = 4
     * }
     */
    public static int SKIP_ENCHANTMENTS() {
        return SKIP_ENCHANTMENTS;
    }
    private static final int STOP_AT_PREDICATE_MATCH = (int)8L;
    /**
     * {@snippet lang=c :
     * enum GenerationMode.STOP_AT_PREDICATE_MATCH = 8
     * }
     */
    public static int STOP_AT_PREDICATE_MATCH() {
        return STOP_AT_PREDICATE_MATCH;
    }

    private static class set_loot_seed {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            Cubiomes.C_POINTER,
            Cubiomes.C_LONG
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("set_loot_seed");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void set_loot_seed(LootTableContext *context, uint64_t seed)
     * }
     */
    public static FunctionDescriptor set_loot_seed$descriptor() {
        return set_loot_seed.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void set_loot_seed(LootTableContext *context, uint64_t seed)
     * }
     */
    public static MethodHandle set_loot_seed$handle() {
        return set_loot_seed.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void set_loot_seed(LootTableContext *context, uint64_t seed)
     * }
     */
    public static MemorySegment set_loot_seed$address() {
        return set_loot_seed.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void set_loot_seed(LootTableContext *context, uint64_t seed)
     * }
     */
    public static void set_loot_seed(MemorySegment context, long seed) {
        var mh$ = set_loot_seed.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("set_loot_seed", context, seed);
            }
            mh$.invokeExact(context, seed);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class set_internal_loot_seed {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            Cubiomes.C_POINTER,
            Cubiomes.C_LONG
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("set_internal_loot_seed");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void set_internal_loot_seed(LootTableContext *context, uint64_t internal_seed)
     * }
     */
    public static FunctionDescriptor set_internal_loot_seed$descriptor() {
        return set_internal_loot_seed.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void set_internal_loot_seed(LootTableContext *context, uint64_t internal_seed)
     * }
     */
    public static MethodHandle set_internal_loot_seed$handle() {
        return set_internal_loot_seed.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void set_internal_loot_seed(LootTableContext *context, uint64_t internal_seed)
     * }
     */
    public static MemorySegment set_internal_loot_seed$address() {
        return set_internal_loot_seed.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void set_internal_loot_seed(LootTableContext *context, uint64_t internal_seed)
     * }
     */
    public static void set_internal_loot_seed(MemorySegment context, long internal_seed) {
        var mh$ = set_internal_loot_seed.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("set_internal_loot_seed", context, internal_seed);
            }
            mh$.invokeExact(context, internal_seed);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class get_item_id {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Cubiomes.C_INT,
            Cubiomes.C_POINTER,
            Cubiomes.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("get_item_id");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int get_item_id(LootTableContext *context, const char *item_name)
     * }
     */
    public static FunctionDescriptor get_item_id$descriptor() {
        return get_item_id.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int get_item_id(LootTableContext *context, const char *item_name)
     * }
     */
    public static MethodHandle get_item_id$handle() {
        return get_item_id.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int get_item_id(LootTableContext *context, const char *item_name)
     * }
     */
    public static MemorySegment get_item_id$address() {
        return get_item_id.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int get_item_id(LootTableContext *context, const char *item_name)
     * }
     */
    public static int get_item_id(MemorySegment context, MemorySegment item_name) {
        var mh$ = get_item_id.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("get_item_id", context, item_name);
            }
            return (int)mh$.invokeExact(context, item_name);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class get_global_item_id {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Cubiomes.C_INT,
            Cubiomes.C_POINTER,
            Cubiomes.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("get_global_item_id");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int get_global_item_id(LootTableContext *context, int item_id)
     * }
     */
    public static FunctionDescriptor get_global_item_id$descriptor() {
        return get_global_item_id.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int get_global_item_id(LootTableContext *context, int item_id)
     * }
     */
    public static MethodHandle get_global_item_id$handle() {
        return get_global_item_id.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int get_global_item_id(LootTableContext *context, int item_id)
     * }
     */
    public static MemorySegment get_global_item_id$address() {
        return get_global_item_id.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int get_global_item_id(LootTableContext *context, int item_id)
     * }
     */
    public static int get_global_item_id(MemorySegment context, int item_id) {
        var mh$ = get_global_item_id.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("get_global_item_id", context, item_id);
            }
            return (int)mh$.invokeExact(context, item_id);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class get_item_name {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Cubiomes.C_POINTER,
            Cubiomes.C_POINTER,
            Cubiomes.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("get_item_name");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * const char *get_item_name(LootTableContext *context, int item_id)
     * }
     */
    public static FunctionDescriptor get_item_name$descriptor() {
        return get_item_name.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * const char *get_item_name(LootTableContext *context, int item_id)
     * }
     */
    public static MethodHandle get_item_name$handle() {
        return get_item_name.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * const char *get_item_name(LootTableContext *context, int item_id)
     * }
     */
    public static MemorySegment get_item_name$address() {
        return get_item_name.ADDR;
    }

    /**
     * {@snippet lang=c :
     * const char *get_item_name(LootTableContext *context, int item_id)
     * }
     */
    public static MemorySegment get_item_name(MemorySegment context, int item_id) {
        var mh$ = get_item_name.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("get_item_name", context, item_id);
            }
            return (MemorySegment)mh$.invokeExact(context, item_id);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class has_item {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Cubiomes.C_INT,
            Cubiomes.C_POINTER,
            Cubiomes.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("has_item");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int has_item(LootTableContext *context, int global_item_id)
     * }
     */
    public static FunctionDescriptor has_item$descriptor() {
        return has_item.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int has_item(LootTableContext *context, int global_item_id)
     * }
     */
    public static MethodHandle has_item$handle() {
        return has_item.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int has_item(LootTableContext *context, int global_item_id)
     * }
     */
    public static MemorySegment has_item$address() {
        return has_item.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int has_item(LootTableContext *context, int global_item_id)
     * }
     */
    public static int has_item(MemorySegment context, int global_item_id) {
        var mh$ = has_item.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("has_item", context, global_item_id);
            }
            return (int)mh$.invokeExact(context, global_item_id);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class generate_loot {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            Cubiomes.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("generate_loot");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void generate_loot(LootTableContext *context)
     * }
     */
    public static FunctionDescriptor generate_loot$descriptor() {
        return generate_loot.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void generate_loot(LootTableContext *context)
     * }
     */
    public static MethodHandle generate_loot$handle() {
        return generate_loot.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void generate_loot(LootTableContext *context)
     * }
     */
    public static MemorySegment generate_loot$address() {
        return generate_loot.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void generate_loot(LootTableContext *context)
     * }
     */
    public static void generate_loot(MemorySegment context) {
        var mh$ = generate_loot.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("generate_loot", context);
            }
            mh$.invokeExact(context);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class get_item_type {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Cubiomes.C_INT,
            Cubiomes.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("get_item_type");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * ItemType get_item_type(const char *item_name)
     * }
     */
    public static FunctionDescriptor get_item_type$descriptor() {
        return get_item_type.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * ItemType get_item_type(const char *item_name)
     * }
     */
    public static MethodHandle get_item_type$handle() {
        return get_item_type.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * ItemType get_item_type(const char *item_name)
     * }
     */
    public static MemorySegment get_item_type$address() {
        return get_item_type.ADDR;
    }

    /**
     * {@snippet lang=c :
     * ItemType get_item_type(const char *item_name)
     * }
     */
    public static int get_item_type(MemorySegment item_name) {
        var mh$ = get_item_type.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("get_item_type", item_name);
            }
            return (int)mh$.invokeExact(item_name);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class get_enchantment_from_name {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Cubiomes.C_INT,
            Cubiomes.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("get_enchantment_from_name");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * Enchantment get_enchantment_from_name(const char *ench)
     * }
     */
    public static FunctionDescriptor get_enchantment_from_name$descriptor() {
        return get_enchantment_from_name.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * Enchantment get_enchantment_from_name(const char *ench)
     * }
     */
    public static MethodHandle get_enchantment_from_name$handle() {
        return get_enchantment_from_name.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * Enchantment get_enchantment_from_name(const char *ench)
     * }
     */
    public static MemorySegment get_enchantment_from_name$address() {
        return get_enchantment_from_name.ADDR;
    }

    /**
     * {@snippet lang=c :
     * Enchantment get_enchantment_from_name(const char *ench)
     * }
     */
    public static int get_enchantment_from_name(MemorySegment ench) {
        var mh$ = get_enchantment_from_name.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("get_enchantment_from_name", ench);
            }
            return (int)mh$.invokeExact(ench);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class free_loot_function {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            Cubiomes.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("free_loot_function");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void free_loot_function(LootFunction *lf)
     * }
     */
    public static FunctionDescriptor free_loot_function$descriptor() {
        return free_loot_function.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void free_loot_function(LootFunction *lf)
     * }
     */
    public static MethodHandle free_loot_function$handle() {
        return free_loot_function.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void free_loot_function(LootFunction *lf)
     * }
     */
    public static MemorySegment free_loot_function$address() {
        return free_loot_function.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void free_loot_function(LootFunction *lf)
     * }
     */
    public static void free_loot_function(MemorySegment lf) {
        var mh$ = free_loot_function.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("free_loot_function", lf);
            }
            mh$.invokeExact(lf);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class init_loot_table_name {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Cubiomes.C_INT,
            Cubiomes.C_POINTER,
            Cubiomes.C_POINTER,
            Cubiomes.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("init_loot_table_name");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int init_loot_table_name(LootTableContext **context, const char *loot_table, int version)
     * }
     */
    public static FunctionDescriptor init_loot_table_name$descriptor() {
        return init_loot_table_name.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int init_loot_table_name(LootTableContext **context, const char *loot_table, int version)
     * }
     */
    public static MethodHandle init_loot_table_name$handle() {
        return init_loot_table_name.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int init_loot_table_name(LootTableContext **context, const char *loot_table, int version)
     * }
     */
    public static MemorySegment init_loot_table_name$address() {
        return init_loot_table_name.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int init_loot_table_name(LootTableContext **context, const char *loot_table, int version)
     * }
     */
    public static int init_loot_table_name(MemorySegment context, MemorySegment loot_table, int version) {
        var mh$ = init_loot_table_name.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("init_loot_table_name", context, loot_table, version);
            }
            return (int)mh$.invokeExact(context, loot_table, version);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class init_bastion_bridge {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Cubiomes.C_INT,
            Cubiomes.C_POINTER,
            Cubiomes.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("init_bastion_bridge");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int init_bastion_bridge(LootTableContext **context, int version)
     * }
     */
    public static FunctionDescriptor init_bastion_bridge$descriptor() {
        return init_bastion_bridge.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int init_bastion_bridge(LootTableContext **context, int version)
     * }
     */
    public static MethodHandle init_bastion_bridge$handle() {
        return init_bastion_bridge.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int init_bastion_bridge(LootTableContext **context, int version)
     * }
     */
    public static MemorySegment init_bastion_bridge$address() {
        return init_bastion_bridge.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int init_bastion_bridge(LootTableContext **context, int version)
     * }
     */
    public static int init_bastion_bridge(MemorySegment context, int version) {
        var mh$ = init_bastion_bridge.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("init_bastion_bridge", context, version);
            }
            return (int)mh$.invokeExact(context, version);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class init_bastion_other {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Cubiomes.C_INT,
            Cubiomes.C_POINTER,
            Cubiomes.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("init_bastion_other");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int init_bastion_other(LootTableContext **context, int version)
     * }
     */
    public static FunctionDescriptor init_bastion_other$descriptor() {
        return init_bastion_other.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int init_bastion_other(LootTableContext **context, int version)
     * }
     */
    public static MethodHandle init_bastion_other$handle() {
        return init_bastion_other.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int init_bastion_other(LootTableContext **context, int version)
     * }
     */
    public static MemorySegment init_bastion_other$address() {
        return init_bastion_other.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int init_bastion_other(LootTableContext **context, int version)
     * }
     */
    public static int init_bastion_other(MemorySegment context, int version) {
        var mh$ = init_bastion_other.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("init_bastion_other", context, version);
            }
            return (int)mh$.invokeExact(context, version);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class init_buried_treasure {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Cubiomes.C_INT,
            Cubiomes.C_POINTER,
            Cubiomes.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("init_buried_treasure");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int init_buried_treasure(LootTableContext **context, int version)
     * }
     */
    public static FunctionDescriptor init_buried_treasure$descriptor() {
        return init_buried_treasure.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int init_buried_treasure(LootTableContext **context, int version)
     * }
     */
    public static MethodHandle init_buried_treasure$handle() {
        return init_buried_treasure.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int init_buried_treasure(LootTableContext **context, int version)
     * }
     */
    public static MemorySegment init_buried_treasure$address() {
        return init_buried_treasure.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int init_buried_treasure(LootTableContext **context, int version)
     * }
     */
    public static int init_buried_treasure(MemorySegment context, int version) {
        var mh$ = init_buried_treasure.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("init_buried_treasure", context, version);
            }
            return (int)mh$.invokeExact(context, version);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class init_desert_pyramid {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Cubiomes.C_INT,
            Cubiomes.C_POINTER,
            Cubiomes.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("init_desert_pyramid");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int init_desert_pyramid(LootTableContext **context, int version)
     * }
     */
    public static FunctionDescriptor init_desert_pyramid$descriptor() {
        return init_desert_pyramid.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int init_desert_pyramid(LootTableContext **context, int version)
     * }
     */
    public static MethodHandle init_desert_pyramid$handle() {
        return init_desert_pyramid.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int init_desert_pyramid(LootTableContext **context, int version)
     * }
     */
    public static MemorySegment init_desert_pyramid$address() {
        return init_desert_pyramid.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int init_desert_pyramid(LootTableContext **context, int version)
     * }
     */
    public static int init_desert_pyramid(MemorySegment context, int version) {
        var mh$ = init_desert_pyramid.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("init_desert_pyramid", context, version);
            }
            return (int)mh$.invokeExact(context, version);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class init_end_city_treasure {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Cubiomes.C_INT,
            Cubiomes.C_POINTER,
            Cubiomes.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("init_end_city_treasure");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int init_end_city_treasure(LootTableContext **context, int version)
     * }
     */
    public static FunctionDescriptor init_end_city_treasure$descriptor() {
        return init_end_city_treasure.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int init_end_city_treasure(LootTableContext **context, int version)
     * }
     */
    public static MethodHandle init_end_city_treasure$handle() {
        return init_end_city_treasure.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int init_end_city_treasure(LootTableContext **context, int version)
     * }
     */
    public static MemorySegment init_end_city_treasure$address() {
        return init_end_city_treasure.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int init_end_city_treasure(LootTableContext **context, int version)
     * }
     */
    public static int init_end_city_treasure(MemorySegment context, int version) {
        var mh$ = init_end_city_treasure.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("init_end_city_treasure", context, version);
            }
            return (int)mh$.invokeExact(context, version);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class init_igloo_chest {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Cubiomes.C_INT,
            Cubiomes.C_POINTER,
            Cubiomes.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("init_igloo_chest");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int init_igloo_chest(LootTableContext **context, int version)
     * }
     */
    public static FunctionDescriptor init_igloo_chest$descriptor() {
        return init_igloo_chest.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int init_igloo_chest(LootTableContext **context, int version)
     * }
     */
    public static MethodHandle init_igloo_chest$handle() {
        return init_igloo_chest.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int init_igloo_chest(LootTableContext **context, int version)
     * }
     */
    public static MemorySegment init_igloo_chest$address() {
        return init_igloo_chest.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int init_igloo_chest(LootTableContext **context, int version)
     * }
     */
    public static int init_igloo_chest(MemorySegment context, int version) {
        var mh$ = init_igloo_chest.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("init_igloo_chest", context, version);
            }
            return (int)mh$.invokeExact(context, version);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class init_jungle_temple {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Cubiomes.C_INT,
            Cubiomes.C_POINTER,
            Cubiomes.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("init_jungle_temple");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int init_jungle_temple(LootTableContext **context, int version)
     * }
     */
    public static FunctionDescriptor init_jungle_temple$descriptor() {
        return init_jungle_temple.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int init_jungle_temple(LootTableContext **context, int version)
     * }
     */
    public static MethodHandle init_jungle_temple$handle() {
        return init_jungle_temple.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int init_jungle_temple(LootTableContext **context, int version)
     * }
     */
    public static MemorySegment init_jungle_temple$address() {
        return init_jungle_temple.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int init_jungle_temple(LootTableContext **context, int version)
     * }
     */
    public static int init_jungle_temple(MemorySegment context, int version) {
        var mh$ = init_jungle_temple.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("init_jungle_temple", context, version);
            }
            return (int)mh$.invokeExact(context, version);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class init_jungle_temple_dispenser {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Cubiomes.C_INT,
            Cubiomes.C_POINTER,
            Cubiomes.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("init_jungle_temple_dispenser");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int init_jungle_temple_dispenser(LootTableContext **context, int version)
     * }
     */
    public static FunctionDescriptor init_jungle_temple_dispenser$descriptor() {
        return init_jungle_temple_dispenser.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int init_jungle_temple_dispenser(LootTableContext **context, int version)
     * }
     */
    public static MethodHandle init_jungle_temple_dispenser$handle() {
        return init_jungle_temple_dispenser.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int init_jungle_temple_dispenser(LootTableContext **context, int version)
     * }
     */
    public static MemorySegment init_jungle_temple_dispenser$address() {
        return init_jungle_temple_dispenser.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int init_jungle_temple_dispenser(LootTableContext **context, int version)
     * }
     */
    public static int init_jungle_temple_dispenser(MemorySegment context, int version) {
        var mh$ = init_jungle_temple_dispenser.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("init_jungle_temple_dispenser", context, version);
            }
            return (int)mh$.invokeExact(context, version);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class init_nether_bridge {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Cubiomes.C_INT,
            Cubiomes.C_POINTER,
            Cubiomes.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("init_nether_bridge");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int init_nether_bridge(LootTableContext **context, int version)
     * }
     */
    public static FunctionDescriptor init_nether_bridge$descriptor() {
        return init_nether_bridge.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int init_nether_bridge(LootTableContext **context, int version)
     * }
     */
    public static MethodHandle init_nether_bridge$handle() {
        return init_nether_bridge.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int init_nether_bridge(LootTableContext **context, int version)
     * }
     */
    public static MemorySegment init_nether_bridge$address() {
        return init_nether_bridge.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int init_nether_bridge(LootTableContext **context, int version)
     * }
     */
    public static int init_nether_bridge(MemorySegment context, int version) {
        var mh$ = init_nether_bridge.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("init_nether_bridge", context, version);
            }
            return (int)mh$.invokeExact(context, version);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class init_pillager_outpost {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Cubiomes.C_INT,
            Cubiomes.C_POINTER,
            Cubiomes.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("init_pillager_outpost");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int init_pillager_outpost(LootTableContext **context, int version)
     * }
     */
    public static FunctionDescriptor init_pillager_outpost$descriptor() {
        return init_pillager_outpost.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int init_pillager_outpost(LootTableContext **context, int version)
     * }
     */
    public static MethodHandle init_pillager_outpost$handle() {
        return init_pillager_outpost.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int init_pillager_outpost(LootTableContext **context, int version)
     * }
     */
    public static MemorySegment init_pillager_outpost$address() {
        return init_pillager_outpost.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int init_pillager_outpost(LootTableContext **context, int version)
     * }
     */
    public static int init_pillager_outpost(MemorySegment context, int version) {
        var mh$ = init_pillager_outpost.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("init_pillager_outpost", context, version);
            }
            return (int)mh$.invokeExact(context, version);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class init_ruined_portal {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Cubiomes.C_INT,
            Cubiomes.C_POINTER,
            Cubiomes.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("init_ruined_portal");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int init_ruined_portal(LootTableContext **context, int version)
     * }
     */
    public static FunctionDescriptor init_ruined_portal$descriptor() {
        return init_ruined_portal.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int init_ruined_portal(LootTableContext **context, int version)
     * }
     */
    public static MethodHandle init_ruined_portal$handle() {
        return init_ruined_portal.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int init_ruined_portal(LootTableContext **context, int version)
     * }
     */
    public static MemorySegment init_ruined_portal$address() {
        return init_ruined_portal.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int init_ruined_portal(LootTableContext **context, int version)
     * }
     */
    public static int init_ruined_portal(MemorySegment context, int version) {
        var mh$ = init_ruined_portal.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("init_ruined_portal", context, version);
            }
            return (int)mh$.invokeExact(context, version);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class init_shipwreck_map {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Cubiomes.C_INT,
            Cubiomes.C_POINTER,
            Cubiomes.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("init_shipwreck_map");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int init_shipwreck_map(LootTableContext **context, int version)
     * }
     */
    public static FunctionDescriptor init_shipwreck_map$descriptor() {
        return init_shipwreck_map.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int init_shipwreck_map(LootTableContext **context, int version)
     * }
     */
    public static MethodHandle init_shipwreck_map$handle() {
        return init_shipwreck_map.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int init_shipwreck_map(LootTableContext **context, int version)
     * }
     */
    public static MemorySegment init_shipwreck_map$address() {
        return init_shipwreck_map.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int init_shipwreck_map(LootTableContext **context, int version)
     * }
     */
    public static int init_shipwreck_map(MemorySegment context, int version) {
        var mh$ = init_shipwreck_map.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("init_shipwreck_map", context, version);
            }
            return (int)mh$.invokeExact(context, version);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class init_shipwreck_supply {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Cubiomes.C_INT,
            Cubiomes.C_POINTER,
            Cubiomes.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("init_shipwreck_supply");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int init_shipwreck_supply(LootTableContext **context, int version)
     * }
     */
    public static FunctionDescriptor init_shipwreck_supply$descriptor() {
        return init_shipwreck_supply.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int init_shipwreck_supply(LootTableContext **context, int version)
     * }
     */
    public static MethodHandle init_shipwreck_supply$handle() {
        return init_shipwreck_supply.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int init_shipwreck_supply(LootTableContext **context, int version)
     * }
     */
    public static MemorySegment init_shipwreck_supply$address() {
        return init_shipwreck_supply.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int init_shipwreck_supply(LootTableContext **context, int version)
     * }
     */
    public static int init_shipwreck_supply(MemorySegment context, int version) {
        var mh$ = init_shipwreck_supply.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("init_shipwreck_supply", context, version);
            }
            return (int)mh$.invokeExact(context, version);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class init_shipwreck_treasure {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Cubiomes.C_INT,
            Cubiomes.C_POINTER,
            Cubiomes.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("init_shipwreck_treasure");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int init_shipwreck_treasure(LootTableContext **context, int version)
     * }
     */
    public static FunctionDescriptor init_shipwreck_treasure$descriptor() {
        return init_shipwreck_treasure.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int init_shipwreck_treasure(LootTableContext **context, int version)
     * }
     */
    public static MethodHandle init_shipwreck_treasure$handle() {
        return init_shipwreck_treasure.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int init_shipwreck_treasure(LootTableContext **context, int version)
     * }
     */
    public static MemorySegment init_shipwreck_treasure$address() {
        return init_shipwreck_treasure.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int init_shipwreck_treasure(LootTableContext **context, int version)
     * }
     */
    public static int init_shipwreck_treasure(MemorySegment context, int version) {
        var mh$ = init_shipwreck_treasure.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("init_shipwreck_treasure", context, version);
            }
            return (int)mh$.invokeExact(context, version);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class init_loot_table {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Cubiomes.C_INT,
            Cubiomes.C_POINTER,
            Cubiomes.C_POINTER,
            Cubiomes.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("init_loot_table");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int init_loot_table(const char *loot_table_string, LootTableContext *context, const int version)
     * }
     */
    public static FunctionDescriptor init_loot_table$descriptor() {
        return init_loot_table.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int init_loot_table(const char *loot_table_string, LootTableContext *context, const int version)
     * }
     */
    public static MethodHandle init_loot_table$handle() {
        return init_loot_table.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int init_loot_table(const char *loot_table_string, LootTableContext *context, const int version)
     * }
     */
    public static MemorySegment init_loot_table$address() {
        return init_loot_table.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int init_loot_table(const char *loot_table_string, LootTableContext *context, const int version)
     * }
     */
    public static int init_loot_table(MemorySegment loot_table_string, MemorySegment context, int version) {
        var mh$ = init_loot_table.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("init_loot_table", loot_table_string, context, version);
            }
            return (int)mh$.invokeExact(loot_table_string, context, version);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class init_loot_table_file {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Cubiomes.C_INT,
            Cubiomes.C_POINTER,
            Cubiomes.C_POINTER,
            Cubiomes.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("init_loot_table_file");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int init_loot_table_file(FILE *file, LootTableContext *context, const int version)
     * }
     */
    public static FunctionDescriptor init_loot_table_file$descriptor() {
        return init_loot_table_file.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int init_loot_table_file(FILE *file, LootTableContext *context, const int version)
     * }
     */
    public static MethodHandle init_loot_table_file$handle() {
        return init_loot_table_file.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int init_loot_table_file(FILE *file, LootTableContext *context, const int version)
     * }
     */
    public static MemorySegment init_loot_table_file$address() {
        return init_loot_table_file.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int init_loot_table_file(FILE *file, LootTableContext *context, const int version)
     * }
     */
    public static int init_loot_table_file(MemorySegment file, MemorySegment context, int version) {
        var mh$ = init_loot_table_file.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("init_loot_table_file", file, context, version);
            }
            return (int)mh$.invokeExact(file, context, version);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class resolve_subtable {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Cubiomes.C_INT,
            Cubiomes.C_POINTER,
            Cubiomes.C_POINTER,
            Cubiomes.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("resolve_subtable");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int resolve_subtable(LootTableContext *context, const char *subtable_name, const char *subtable_string)
     * }
     */
    public static FunctionDescriptor resolve_subtable$descriptor() {
        return resolve_subtable.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int resolve_subtable(LootTableContext *context, const char *subtable_name, const char *subtable_string)
     * }
     */
    public static MethodHandle resolve_subtable$handle() {
        return resolve_subtable.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int resolve_subtable(LootTableContext *context, const char *subtable_name, const char *subtable_string)
     * }
     */
    public static MemorySegment resolve_subtable$address() {
        return resolve_subtable.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int resolve_subtable(LootTableContext *context, const char *subtable_name, const char *subtable_string)
     * }
     */
    public static int resolve_subtable(MemorySegment context, MemorySegment subtable_name, MemorySegment subtable_string) {
        var mh$ = resolve_subtable.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("resolve_subtable", context, subtable_name, subtable_string);
            }
            return (int)mh$.invokeExact(context, subtable_name, subtable_string);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class resolve_subtable_file {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Cubiomes.C_INT,
            Cubiomes.C_POINTER,
            Cubiomes.C_POINTER,
            Cubiomes.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("resolve_subtable_file");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int resolve_subtable_file(LootTableContext *context, const char *subtable_name, FILE *subtable_file)
     * }
     */
    public static FunctionDescriptor resolve_subtable_file$descriptor() {
        return resolve_subtable_file.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int resolve_subtable_file(LootTableContext *context, const char *subtable_name, FILE *subtable_file)
     * }
     */
    public static MethodHandle resolve_subtable_file$handle() {
        return resolve_subtable_file.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int resolve_subtable_file(LootTableContext *context, const char *subtable_name, FILE *subtable_file)
     * }
     */
    public static MemorySegment resolve_subtable_file$address() {
        return resolve_subtable_file.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int resolve_subtable_file(LootTableContext *context, const char *subtable_name, FILE *subtable_file)
     * }
     */
    public static int resolve_subtable_file(MemorySegment context, MemorySegment subtable_name, MemorySegment subtable_file) {
        var mh$ = resolve_subtable_file.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("resolve_subtable_file", context, subtable_name, subtable_file);
            }
            return (int)mh$.invokeExact(context, subtable_name, subtable_file);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class free_loot_table {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            Cubiomes.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("free_loot_table");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void free_loot_table(LootTableContext *context)
     * }
     */
    public static FunctionDescriptor free_loot_table$descriptor() {
        return free_loot_table.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void free_loot_table(LootTableContext *context)
     * }
     */
    public static MethodHandle free_loot_table$handle() {
        return free_loot_table.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void free_loot_table(LootTableContext *context)
     * }
     */
    public static MemorySegment free_loot_table$address() {
        return free_loot_table.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void free_loot_table(LootTableContext *context)
     * }
     */
    public static void free_loot_table(MemorySegment context) {
        var mh$ = free_loot_table.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("free_loot_table", context);
            }
            mh$.invokeExact(context);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    private static final long LAYER_INIT_SHA = -1L;
    /**
     * {@snippet lang=c :
     * #define LAYER_INIT_SHA -1
     * }
     */
    public static long LAYER_INIT_SHA() {
        return LAYER_INIT_SHA;
    }
    private static final long MASK48 = 281474976710655L;
    /**
     * {@snippet lang=c :
     * #define MASK48 281474976710655
     * }
     */
    public static long MASK48() {
        return MASK48;
    }
}

