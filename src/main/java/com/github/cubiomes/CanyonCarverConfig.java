// Generated by jextract

package com.github.cubiomes;

import java.lang.invoke.*;
import java.lang.foreign.*;
import java.nio.ByteOrder;
import java.util.*;
import java.util.function.*;
import java.util.stream.*;

import static java.lang.foreign.ValueLayout.*;
import static java.lang.foreign.MemoryLayout.PathElement.*;

/**
 * {@snippet lang=c :
 * struct CanyonCarverConfig {
 *     int dim;
 *     float probability;
 *     int carverIndex;
 *     int range;
 *     int (*y)(uint64_t *, int, int, int);
 *     int minY;
 *     int maxY;
 *     int innerY;
 *     float yScale;
 *     float (*verticalRotation)(uint64_t *, float, float);
 *     float minVerRot;
 *     float maxVerRot;
 *     float (*distanceFactor)(uint64_t *, float, float);
 *     float minDistance;
 *     float maxDistance;
 *     float (*thickness)(uint64_t *, float, float, float);
 *     float minThickness;
 *     float maxThickness;
 *     float plateauThickness;
 *     int widthSmoothness;
 *     float (*horizontalRadiusFactor)(uint64_t *, float, float);
 *     float minHorRadius;
 *     float maxHorRadius;
 *     float verticalRadiusDefaultFactor;
 *     float verticalRadiusCenterFactor;
 * }
 * }
 */
public class CanyonCarverConfig {

    CanyonCarverConfig() {
        // Should not be called directly
    }

    private static final GroupLayout $LAYOUT = MemoryLayout.structLayout(
        Cubiomes.C_INT.withName("dim"),
        Cubiomes.C_FLOAT.withName("probability"),
        Cubiomes.C_INT.withName("carverIndex"),
        Cubiomes.C_INT.withName("range"),
        Cubiomes.C_POINTER.withName("y"),
        Cubiomes.C_INT.withName("minY"),
        Cubiomes.C_INT.withName("maxY"),
        Cubiomes.C_INT.withName("innerY"),
        Cubiomes.C_FLOAT.withName("yScale"),
        Cubiomes.C_POINTER.withName("verticalRotation"),
        Cubiomes.C_FLOAT.withName("minVerRot"),
        Cubiomes.C_FLOAT.withName("maxVerRot"),
        Cubiomes.C_POINTER.withName("distanceFactor"),
        Cubiomes.C_FLOAT.withName("minDistance"),
        Cubiomes.C_FLOAT.withName("maxDistance"),
        Cubiomes.C_POINTER.withName("thickness"),
        Cubiomes.C_FLOAT.withName("minThickness"),
        Cubiomes.C_FLOAT.withName("maxThickness"),
        Cubiomes.C_FLOAT.withName("plateauThickness"),
        Cubiomes.C_INT.withName("widthSmoothness"),
        Cubiomes.C_POINTER.withName("horizontalRadiusFactor"),
        Cubiomes.C_FLOAT.withName("minHorRadius"),
        Cubiomes.C_FLOAT.withName("maxHorRadius"),
        Cubiomes.C_FLOAT.withName("verticalRadiusDefaultFactor"),
        Cubiomes.C_FLOAT.withName("verticalRadiusCenterFactor")
    ).withName("CanyonCarverConfig");

    /**
     * The layout of this struct
     */
    public static final GroupLayout layout() {
        return $LAYOUT;
    }

    private static final OfInt dim$LAYOUT = (OfInt)$LAYOUT.select(groupElement("dim"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * int dim
     * }
     */
    public static final OfInt dim$layout() {
        return dim$LAYOUT;
    }

    private static final long dim$OFFSET = $LAYOUT.byteOffset(groupElement("dim"));

    /**
     * Offset for field:
     * {@snippet lang=c :
     * int dim
     * }
     */
    public static final long dim$offset() {
        return dim$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * int dim
     * }
     */
    public static int dim(MemorySegment struct) {
        return struct.get(dim$LAYOUT, dim$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * int dim
     * }
     */
    public static void dim(MemorySegment struct, int fieldValue) {
        struct.set(dim$LAYOUT, dim$OFFSET, fieldValue);
    }

    private static final OfFloat probability$LAYOUT = (OfFloat)$LAYOUT.select(groupElement("probability"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * float probability
     * }
     */
    public static final OfFloat probability$layout() {
        return probability$LAYOUT;
    }

    private static final long probability$OFFSET = $LAYOUT.byteOffset(groupElement("probability"));

    /**
     * Offset for field:
     * {@snippet lang=c :
     * float probability
     * }
     */
    public static final long probability$offset() {
        return probability$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * float probability
     * }
     */
    public static float probability(MemorySegment struct) {
        return struct.get(probability$LAYOUT, probability$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * float probability
     * }
     */
    public static void probability(MemorySegment struct, float fieldValue) {
        struct.set(probability$LAYOUT, probability$OFFSET, fieldValue);
    }

    private static final OfInt carverIndex$LAYOUT = (OfInt)$LAYOUT.select(groupElement("carverIndex"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * int carverIndex
     * }
     */
    public static final OfInt carverIndex$layout() {
        return carverIndex$LAYOUT;
    }

    private static final long carverIndex$OFFSET = $LAYOUT.byteOffset(groupElement("carverIndex"));

    /**
     * Offset for field:
     * {@snippet lang=c :
     * int carverIndex
     * }
     */
    public static final long carverIndex$offset() {
        return carverIndex$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * int carverIndex
     * }
     */
    public static int carverIndex(MemorySegment struct) {
        return struct.get(carverIndex$LAYOUT, carverIndex$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * int carverIndex
     * }
     */
    public static void carverIndex(MemorySegment struct, int fieldValue) {
        struct.set(carverIndex$LAYOUT, carverIndex$OFFSET, fieldValue);
    }

    private static final OfInt range$LAYOUT = (OfInt)$LAYOUT.select(groupElement("range"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * int range
     * }
     */
    public static final OfInt range$layout() {
        return range$LAYOUT;
    }

    private static final long range$OFFSET = $LAYOUT.byteOffset(groupElement("range"));

    /**
     * Offset for field:
     * {@snippet lang=c :
     * int range
     * }
     */
    public static final long range$offset() {
        return range$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * int range
     * }
     */
    public static int range(MemorySegment struct) {
        return struct.get(range$LAYOUT, range$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * int range
     * }
     */
    public static void range(MemorySegment struct, int fieldValue) {
        struct.set(range$LAYOUT, range$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * int (*y)(uint64_t *, int, int, int)
     * }
     */
    public static class y {

        y() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            int apply(MemorySegment _x0, int _x1, int _x2, int _x3);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            Cubiomes.C_INT,
            Cubiomes.C_POINTER,
            Cubiomes.C_INT,
            Cubiomes.C_INT,
            Cubiomes.C_INT
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = Cubiomes.upcallHandle(y.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(y.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static int invoke(MemorySegment funcPtr,MemorySegment _x0, int _x1, int _x2, int _x3) {
            try {
                return (int) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2, _x3);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout y$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("y"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * int (*y)(uint64_t *, int, int, int)
     * }
     */
    public static final AddressLayout y$layout() {
        return y$LAYOUT;
    }

    private static final long y$OFFSET = $LAYOUT.byteOffset(groupElement("y"));

    /**
     * Offset for field:
     * {@snippet lang=c :
     * int (*y)(uint64_t *, int, int, int)
     * }
     */
    public static final long y$offset() {
        return y$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * int (*y)(uint64_t *, int, int, int)
     * }
     */
    public static MemorySegment y(MemorySegment struct) {
        return struct.get(y$LAYOUT, y$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * int (*y)(uint64_t *, int, int, int)
     * }
     */
    public static void y(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(y$LAYOUT, y$OFFSET, fieldValue);
    }

    private static final OfInt minY$LAYOUT = (OfInt)$LAYOUT.select(groupElement("minY"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * int minY
     * }
     */
    public static final OfInt minY$layout() {
        return minY$LAYOUT;
    }

    private static final long minY$OFFSET = $LAYOUT.byteOffset(groupElement("minY"));

    /**
     * Offset for field:
     * {@snippet lang=c :
     * int minY
     * }
     */
    public static final long minY$offset() {
        return minY$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * int minY
     * }
     */
    public static int minY(MemorySegment struct) {
        return struct.get(minY$LAYOUT, minY$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * int minY
     * }
     */
    public static void minY(MemorySegment struct, int fieldValue) {
        struct.set(minY$LAYOUT, minY$OFFSET, fieldValue);
    }

    private static final OfInt maxY$LAYOUT = (OfInt)$LAYOUT.select(groupElement("maxY"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * int maxY
     * }
     */
    public static final OfInt maxY$layout() {
        return maxY$LAYOUT;
    }

    private static final long maxY$OFFSET = $LAYOUT.byteOffset(groupElement("maxY"));

    /**
     * Offset for field:
     * {@snippet lang=c :
     * int maxY
     * }
     */
    public static final long maxY$offset() {
        return maxY$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * int maxY
     * }
     */
    public static int maxY(MemorySegment struct) {
        return struct.get(maxY$LAYOUT, maxY$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * int maxY
     * }
     */
    public static void maxY(MemorySegment struct, int fieldValue) {
        struct.set(maxY$LAYOUT, maxY$OFFSET, fieldValue);
    }

    private static final OfInt innerY$LAYOUT = (OfInt)$LAYOUT.select(groupElement("innerY"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * int innerY
     * }
     */
    public static final OfInt innerY$layout() {
        return innerY$LAYOUT;
    }

    private static final long innerY$OFFSET = $LAYOUT.byteOffset(groupElement("innerY"));

    /**
     * Offset for field:
     * {@snippet lang=c :
     * int innerY
     * }
     */
    public static final long innerY$offset() {
        return innerY$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * int innerY
     * }
     */
    public static int innerY(MemorySegment struct) {
        return struct.get(innerY$LAYOUT, innerY$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * int innerY
     * }
     */
    public static void innerY(MemorySegment struct, int fieldValue) {
        struct.set(innerY$LAYOUT, innerY$OFFSET, fieldValue);
    }

    private static final OfFloat yScale$LAYOUT = (OfFloat)$LAYOUT.select(groupElement("yScale"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * float yScale
     * }
     */
    public static final OfFloat yScale$layout() {
        return yScale$LAYOUT;
    }

    private static final long yScale$OFFSET = $LAYOUT.byteOffset(groupElement("yScale"));

    /**
     * Offset for field:
     * {@snippet lang=c :
     * float yScale
     * }
     */
    public static final long yScale$offset() {
        return yScale$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * float yScale
     * }
     */
    public static float yScale(MemorySegment struct) {
        return struct.get(yScale$LAYOUT, yScale$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * float yScale
     * }
     */
    public static void yScale(MemorySegment struct, float fieldValue) {
        struct.set(yScale$LAYOUT, yScale$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * float (*verticalRotation)(uint64_t *, float, float)
     * }
     */
    public static class verticalRotation {

        verticalRotation() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            float apply(MemorySegment _x0, float _x1, float _x2);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            Cubiomes.C_FLOAT,
            Cubiomes.C_POINTER,
            Cubiomes.C_FLOAT,
            Cubiomes.C_FLOAT
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = Cubiomes.upcallHandle(verticalRotation.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(verticalRotation.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static float invoke(MemorySegment funcPtr,MemorySegment _x0, float _x1, float _x2) {
            try {
                return (float) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout verticalRotation$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("verticalRotation"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * float (*verticalRotation)(uint64_t *, float, float)
     * }
     */
    public static final AddressLayout verticalRotation$layout() {
        return verticalRotation$LAYOUT;
    }

    private static final long verticalRotation$OFFSET = $LAYOUT.byteOffset(groupElement("verticalRotation"));

    /**
     * Offset for field:
     * {@snippet lang=c :
     * float (*verticalRotation)(uint64_t *, float, float)
     * }
     */
    public static final long verticalRotation$offset() {
        return verticalRotation$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * float (*verticalRotation)(uint64_t *, float, float)
     * }
     */
    public static MemorySegment verticalRotation(MemorySegment struct) {
        return struct.get(verticalRotation$LAYOUT, verticalRotation$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * float (*verticalRotation)(uint64_t *, float, float)
     * }
     */
    public static void verticalRotation(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(verticalRotation$LAYOUT, verticalRotation$OFFSET, fieldValue);
    }

    private static final OfFloat minVerRot$LAYOUT = (OfFloat)$LAYOUT.select(groupElement("minVerRot"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * float minVerRot
     * }
     */
    public static final OfFloat minVerRot$layout() {
        return minVerRot$LAYOUT;
    }

    private static final long minVerRot$OFFSET = $LAYOUT.byteOffset(groupElement("minVerRot"));

    /**
     * Offset for field:
     * {@snippet lang=c :
     * float minVerRot
     * }
     */
    public static final long minVerRot$offset() {
        return minVerRot$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * float minVerRot
     * }
     */
    public static float minVerRot(MemorySegment struct) {
        return struct.get(minVerRot$LAYOUT, minVerRot$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * float minVerRot
     * }
     */
    public static void minVerRot(MemorySegment struct, float fieldValue) {
        struct.set(minVerRot$LAYOUT, minVerRot$OFFSET, fieldValue);
    }

    private static final OfFloat maxVerRot$LAYOUT = (OfFloat)$LAYOUT.select(groupElement("maxVerRot"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * float maxVerRot
     * }
     */
    public static final OfFloat maxVerRot$layout() {
        return maxVerRot$LAYOUT;
    }

    private static final long maxVerRot$OFFSET = $LAYOUT.byteOffset(groupElement("maxVerRot"));

    /**
     * Offset for field:
     * {@snippet lang=c :
     * float maxVerRot
     * }
     */
    public static final long maxVerRot$offset() {
        return maxVerRot$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * float maxVerRot
     * }
     */
    public static float maxVerRot(MemorySegment struct) {
        return struct.get(maxVerRot$LAYOUT, maxVerRot$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * float maxVerRot
     * }
     */
    public static void maxVerRot(MemorySegment struct, float fieldValue) {
        struct.set(maxVerRot$LAYOUT, maxVerRot$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * float (*distanceFactor)(uint64_t *, float, float)
     * }
     */
    public static class distanceFactor {

        distanceFactor() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            float apply(MemorySegment _x0, float _x1, float _x2);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            Cubiomes.C_FLOAT,
            Cubiomes.C_POINTER,
            Cubiomes.C_FLOAT,
            Cubiomes.C_FLOAT
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = Cubiomes.upcallHandle(distanceFactor.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(distanceFactor.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static float invoke(MemorySegment funcPtr,MemorySegment _x0, float _x1, float _x2) {
            try {
                return (float) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout distanceFactor$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("distanceFactor"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * float (*distanceFactor)(uint64_t *, float, float)
     * }
     */
    public static final AddressLayout distanceFactor$layout() {
        return distanceFactor$LAYOUT;
    }

    private static final long distanceFactor$OFFSET = $LAYOUT.byteOffset(groupElement("distanceFactor"));

    /**
     * Offset for field:
     * {@snippet lang=c :
     * float (*distanceFactor)(uint64_t *, float, float)
     * }
     */
    public static final long distanceFactor$offset() {
        return distanceFactor$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * float (*distanceFactor)(uint64_t *, float, float)
     * }
     */
    public static MemorySegment distanceFactor(MemorySegment struct) {
        return struct.get(distanceFactor$LAYOUT, distanceFactor$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * float (*distanceFactor)(uint64_t *, float, float)
     * }
     */
    public static void distanceFactor(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(distanceFactor$LAYOUT, distanceFactor$OFFSET, fieldValue);
    }

    private static final OfFloat minDistance$LAYOUT = (OfFloat)$LAYOUT.select(groupElement("minDistance"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * float minDistance
     * }
     */
    public static final OfFloat minDistance$layout() {
        return minDistance$LAYOUT;
    }

    private static final long minDistance$OFFSET = $LAYOUT.byteOffset(groupElement("minDistance"));

    /**
     * Offset for field:
     * {@snippet lang=c :
     * float minDistance
     * }
     */
    public static final long minDistance$offset() {
        return minDistance$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * float minDistance
     * }
     */
    public static float minDistance(MemorySegment struct) {
        return struct.get(minDistance$LAYOUT, minDistance$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * float minDistance
     * }
     */
    public static void minDistance(MemorySegment struct, float fieldValue) {
        struct.set(minDistance$LAYOUT, minDistance$OFFSET, fieldValue);
    }

    private static final OfFloat maxDistance$LAYOUT = (OfFloat)$LAYOUT.select(groupElement("maxDistance"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * float maxDistance
     * }
     */
    public static final OfFloat maxDistance$layout() {
        return maxDistance$LAYOUT;
    }

    private static final long maxDistance$OFFSET = $LAYOUT.byteOffset(groupElement("maxDistance"));

    /**
     * Offset for field:
     * {@snippet lang=c :
     * float maxDistance
     * }
     */
    public static final long maxDistance$offset() {
        return maxDistance$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * float maxDistance
     * }
     */
    public static float maxDistance(MemorySegment struct) {
        return struct.get(maxDistance$LAYOUT, maxDistance$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * float maxDistance
     * }
     */
    public static void maxDistance(MemorySegment struct, float fieldValue) {
        struct.set(maxDistance$LAYOUT, maxDistance$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * float (*thickness)(uint64_t *, float, float, float)
     * }
     */
    public static class thickness {

        thickness() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            float apply(MemorySegment _x0, float _x1, float _x2, float _x3);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            Cubiomes.C_FLOAT,
            Cubiomes.C_POINTER,
            Cubiomes.C_FLOAT,
            Cubiomes.C_FLOAT,
            Cubiomes.C_FLOAT
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = Cubiomes.upcallHandle(thickness.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(thickness.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static float invoke(MemorySegment funcPtr,MemorySegment _x0, float _x1, float _x2, float _x3) {
            try {
                return (float) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2, _x3);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout thickness$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("thickness"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * float (*thickness)(uint64_t *, float, float, float)
     * }
     */
    public static final AddressLayout thickness$layout() {
        return thickness$LAYOUT;
    }

    private static final long thickness$OFFSET = $LAYOUT.byteOffset(groupElement("thickness"));

    /**
     * Offset for field:
     * {@snippet lang=c :
     * float (*thickness)(uint64_t *, float, float, float)
     * }
     */
    public static final long thickness$offset() {
        return thickness$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * float (*thickness)(uint64_t *, float, float, float)
     * }
     */
    public static MemorySegment thickness(MemorySegment struct) {
        return struct.get(thickness$LAYOUT, thickness$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * float (*thickness)(uint64_t *, float, float, float)
     * }
     */
    public static void thickness(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(thickness$LAYOUT, thickness$OFFSET, fieldValue);
    }

    private static final OfFloat minThickness$LAYOUT = (OfFloat)$LAYOUT.select(groupElement("minThickness"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * float minThickness
     * }
     */
    public static final OfFloat minThickness$layout() {
        return minThickness$LAYOUT;
    }

    private static final long minThickness$OFFSET = $LAYOUT.byteOffset(groupElement("minThickness"));

    /**
     * Offset for field:
     * {@snippet lang=c :
     * float minThickness
     * }
     */
    public static final long minThickness$offset() {
        return minThickness$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * float minThickness
     * }
     */
    public static float minThickness(MemorySegment struct) {
        return struct.get(minThickness$LAYOUT, minThickness$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * float minThickness
     * }
     */
    public static void minThickness(MemorySegment struct, float fieldValue) {
        struct.set(minThickness$LAYOUT, minThickness$OFFSET, fieldValue);
    }

    private static final OfFloat maxThickness$LAYOUT = (OfFloat)$LAYOUT.select(groupElement("maxThickness"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * float maxThickness
     * }
     */
    public static final OfFloat maxThickness$layout() {
        return maxThickness$LAYOUT;
    }

    private static final long maxThickness$OFFSET = $LAYOUT.byteOffset(groupElement("maxThickness"));

    /**
     * Offset for field:
     * {@snippet lang=c :
     * float maxThickness
     * }
     */
    public static final long maxThickness$offset() {
        return maxThickness$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * float maxThickness
     * }
     */
    public static float maxThickness(MemorySegment struct) {
        return struct.get(maxThickness$LAYOUT, maxThickness$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * float maxThickness
     * }
     */
    public static void maxThickness(MemorySegment struct, float fieldValue) {
        struct.set(maxThickness$LAYOUT, maxThickness$OFFSET, fieldValue);
    }

    private static final OfFloat plateauThickness$LAYOUT = (OfFloat)$LAYOUT.select(groupElement("plateauThickness"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * float plateauThickness
     * }
     */
    public static final OfFloat plateauThickness$layout() {
        return plateauThickness$LAYOUT;
    }

    private static final long plateauThickness$OFFSET = $LAYOUT.byteOffset(groupElement("plateauThickness"));

    /**
     * Offset for field:
     * {@snippet lang=c :
     * float plateauThickness
     * }
     */
    public static final long plateauThickness$offset() {
        return plateauThickness$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * float plateauThickness
     * }
     */
    public static float plateauThickness(MemorySegment struct) {
        return struct.get(plateauThickness$LAYOUT, plateauThickness$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * float plateauThickness
     * }
     */
    public static void plateauThickness(MemorySegment struct, float fieldValue) {
        struct.set(plateauThickness$LAYOUT, plateauThickness$OFFSET, fieldValue);
    }

    private static final OfInt widthSmoothness$LAYOUT = (OfInt)$LAYOUT.select(groupElement("widthSmoothness"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * int widthSmoothness
     * }
     */
    public static final OfInt widthSmoothness$layout() {
        return widthSmoothness$LAYOUT;
    }

    private static final long widthSmoothness$OFFSET = $LAYOUT.byteOffset(groupElement("widthSmoothness"));

    /**
     * Offset for field:
     * {@snippet lang=c :
     * int widthSmoothness
     * }
     */
    public static final long widthSmoothness$offset() {
        return widthSmoothness$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * int widthSmoothness
     * }
     */
    public static int widthSmoothness(MemorySegment struct) {
        return struct.get(widthSmoothness$LAYOUT, widthSmoothness$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * int widthSmoothness
     * }
     */
    public static void widthSmoothness(MemorySegment struct, int fieldValue) {
        struct.set(widthSmoothness$LAYOUT, widthSmoothness$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * float (*horizontalRadiusFactor)(uint64_t *, float, float)
     * }
     */
    public static class horizontalRadiusFactor {

        horizontalRadiusFactor() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            float apply(MemorySegment _x0, float _x1, float _x2);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            Cubiomes.C_FLOAT,
            Cubiomes.C_POINTER,
            Cubiomes.C_FLOAT,
            Cubiomes.C_FLOAT
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = Cubiomes.upcallHandle(horizontalRadiusFactor.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(horizontalRadiusFactor.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static float invoke(MemorySegment funcPtr,MemorySegment _x0, float _x1, float _x2) {
            try {
                return (float) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout horizontalRadiusFactor$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("horizontalRadiusFactor"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * float (*horizontalRadiusFactor)(uint64_t *, float, float)
     * }
     */
    public static final AddressLayout horizontalRadiusFactor$layout() {
        return horizontalRadiusFactor$LAYOUT;
    }

    private static final long horizontalRadiusFactor$OFFSET = $LAYOUT.byteOffset(groupElement("horizontalRadiusFactor"));

    /**
     * Offset for field:
     * {@snippet lang=c :
     * float (*horizontalRadiusFactor)(uint64_t *, float, float)
     * }
     */
    public static final long horizontalRadiusFactor$offset() {
        return horizontalRadiusFactor$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * float (*horizontalRadiusFactor)(uint64_t *, float, float)
     * }
     */
    public static MemorySegment horizontalRadiusFactor(MemorySegment struct) {
        return struct.get(horizontalRadiusFactor$LAYOUT, horizontalRadiusFactor$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * float (*horizontalRadiusFactor)(uint64_t *, float, float)
     * }
     */
    public static void horizontalRadiusFactor(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(horizontalRadiusFactor$LAYOUT, horizontalRadiusFactor$OFFSET, fieldValue);
    }

    private static final OfFloat minHorRadius$LAYOUT = (OfFloat)$LAYOUT.select(groupElement("minHorRadius"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * float minHorRadius
     * }
     */
    public static final OfFloat minHorRadius$layout() {
        return minHorRadius$LAYOUT;
    }

    private static final long minHorRadius$OFFSET = $LAYOUT.byteOffset(groupElement("minHorRadius"));

    /**
     * Offset for field:
     * {@snippet lang=c :
     * float minHorRadius
     * }
     */
    public static final long minHorRadius$offset() {
        return minHorRadius$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * float minHorRadius
     * }
     */
    public static float minHorRadius(MemorySegment struct) {
        return struct.get(minHorRadius$LAYOUT, minHorRadius$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * float minHorRadius
     * }
     */
    public static void minHorRadius(MemorySegment struct, float fieldValue) {
        struct.set(minHorRadius$LAYOUT, minHorRadius$OFFSET, fieldValue);
    }

    private static final OfFloat maxHorRadius$LAYOUT = (OfFloat)$LAYOUT.select(groupElement("maxHorRadius"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * float maxHorRadius
     * }
     */
    public static final OfFloat maxHorRadius$layout() {
        return maxHorRadius$LAYOUT;
    }

    private static final long maxHorRadius$OFFSET = $LAYOUT.byteOffset(groupElement("maxHorRadius"));

    /**
     * Offset for field:
     * {@snippet lang=c :
     * float maxHorRadius
     * }
     */
    public static final long maxHorRadius$offset() {
        return maxHorRadius$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * float maxHorRadius
     * }
     */
    public static float maxHorRadius(MemorySegment struct) {
        return struct.get(maxHorRadius$LAYOUT, maxHorRadius$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * float maxHorRadius
     * }
     */
    public static void maxHorRadius(MemorySegment struct, float fieldValue) {
        struct.set(maxHorRadius$LAYOUT, maxHorRadius$OFFSET, fieldValue);
    }

    private static final OfFloat verticalRadiusDefaultFactor$LAYOUT = (OfFloat)$LAYOUT.select(groupElement("verticalRadiusDefaultFactor"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * float verticalRadiusDefaultFactor
     * }
     */
    public static final OfFloat verticalRadiusDefaultFactor$layout() {
        return verticalRadiusDefaultFactor$LAYOUT;
    }

    private static final long verticalRadiusDefaultFactor$OFFSET = $LAYOUT.byteOffset(groupElement("verticalRadiusDefaultFactor"));

    /**
     * Offset for field:
     * {@snippet lang=c :
     * float verticalRadiusDefaultFactor
     * }
     */
    public static final long verticalRadiusDefaultFactor$offset() {
        return verticalRadiusDefaultFactor$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * float verticalRadiusDefaultFactor
     * }
     */
    public static float verticalRadiusDefaultFactor(MemorySegment struct) {
        return struct.get(verticalRadiusDefaultFactor$LAYOUT, verticalRadiusDefaultFactor$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * float verticalRadiusDefaultFactor
     * }
     */
    public static void verticalRadiusDefaultFactor(MemorySegment struct, float fieldValue) {
        struct.set(verticalRadiusDefaultFactor$LAYOUT, verticalRadiusDefaultFactor$OFFSET, fieldValue);
    }

    private static final OfFloat verticalRadiusCenterFactor$LAYOUT = (OfFloat)$LAYOUT.select(groupElement("verticalRadiusCenterFactor"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * float verticalRadiusCenterFactor
     * }
     */
    public static final OfFloat verticalRadiusCenterFactor$layout() {
        return verticalRadiusCenterFactor$LAYOUT;
    }

    private static final long verticalRadiusCenterFactor$OFFSET = $LAYOUT.byteOffset(groupElement("verticalRadiusCenterFactor"));

    /**
     * Offset for field:
     * {@snippet lang=c :
     * float verticalRadiusCenterFactor
     * }
     */
    public static final long verticalRadiusCenterFactor$offset() {
        return verticalRadiusCenterFactor$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * float verticalRadiusCenterFactor
     * }
     */
    public static float verticalRadiusCenterFactor(MemorySegment struct) {
        return struct.get(verticalRadiusCenterFactor$LAYOUT, verticalRadiusCenterFactor$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * float verticalRadiusCenterFactor
     * }
     */
    public static void verticalRadiusCenterFactor(MemorySegment struct, float fieldValue) {
        struct.set(verticalRadiusCenterFactor$LAYOUT, verticalRadiusCenterFactor$OFFSET, fieldValue);
    }

    /**
     * Obtains a slice of {@code arrayParam} which selects the array element at {@code index}.
     * The returned segment has address {@code arrayParam.address() + index * layout().byteSize()}
     */
    public static MemorySegment asSlice(MemorySegment array, long index) {
        return array.asSlice(layout().byteSize() * index);
    }

    /**
     * The size (in bytes) of this struct
     */
    public static long sizeof() { return layout().byteSize(); }

    /**
     * Allocate a segment of size {@code layout().byteSize()} using {@code allocator}
     */
    public static MemorySegment allocate(SegmentAllocator allocator) {
        return allocator.allocate(layout());
    }

    /**
     * Allocate an array of size {@code elementCount} using {@code allocator}.
     * The returned segment has size {@code elementCount * layout().byteSize()}.
     */
    public static MemorySegment allocateArray(long elementCount, SegmentAllocator allocator) {
        return allocator.allocate(MemoryLayout.sequenceLayout(elementCount, layout()));
    }

    /**
     * Reinterprets {@code addr} using target {@code arena} and {@code cleanupAction} (if any).
     * The returned segment has size {@code layout().byteSize()}
     */
    public static MemorySegment reinterpret(MemorySegment addr, Arena arena, Consumer<MemorySegment> cleanup) {
        return reinterpret(addr, 1, arena, cleanup);
    }

    /**
     * Reinterprets {@code addr} using target {@code arena} and {@code cleanupAction} (if any).
     * The returned segment has size {@code elementCount * layout().byteSize()}
     */
    public static MemorySegment reinterpret(MemorySegment addr, long elementCount, Arena arena, Consumer<MemorySegment> cleanup) {
        return addr.reinterpret(layout().byteSize() * elementCount, arena, cleanup);
    }
}

