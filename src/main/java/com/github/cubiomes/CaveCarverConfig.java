// Generated by jextract

package com.github.cubiomes;

import java.lang.invoke.*;
import java.lang.foreign.*;
import java.nio.ByteOrder;
import java.util.*;
import java.util.function.*;
import java.util.stream.*;

import static java.lang.foreign.ValueLayout.*;
import static java.lang.foreign.MemoryLayout.PathElement.*;

/**
 * {@snippet lang=c :
 * struct CaveCarverConfig {
 *     int dim;
 *     float probability;
 *     int carverIndex;
 *     int range;
 *     int caveBound;
 *     float (*thickness)(uint64_t *);
 *     double tunnelYScale;
 *     int (*y)(uint64_t *, int, int, int);
 *     int minY;
 *     int maxY;
 *     int innerY;
 *     float (*yScale)(uint64_t *, float, float);
 *     float minYScale;
 *     float maxYScale;
 *     float (*horizontalRadiusMultiplier)(uint64_t *, float, float);
 *     float minHorRadius;
 *     float maxHorRadius;
 *     float (*verticalRadiusMultiplier)(uint64_t *, float, float);
 *     float minVerRadius;
 *     float maxVerRadius;
 *     float (*floorLevel)(uint64_t *, float, float);
 *     float minFloorLevel;
 *     float maxFloorLevel;
 * }
 * }
 */
public class CaveCarverConfig {

    CaveCarverConfig() {
        // Should not be called directly
    }

    private static final GroupLayout $LAYOUT = MemoryLayout.structLayout(
        Cubiomes.C_INT.withName("dim"),
        Cubiomes.C_FLOAT.withName("probability"),
        Cubiomes.C_INT.withName("carverIndex"),
        Cubiomes.C_INT.withName("range"),
        Cubiomes.C_INT.withName("caveBound"),
        MemoryLayout.paddingLayout(4),
        Cubiomes.C_POINTER.withName("thickness"),
        Cubiomes.C_DOUBLE.withName("tunnelYScale"),
        Cubiomes.C_POINTER.withName("y"),
        Cubiomes.C_INT.withName("minY"),
        Cubiomes.C_INT.withName("maxY"),
        Cubiomes.C_INT.withName("innerY"),
        MemoryLayout.paddingLayout(4),
        Cubiomes.C_POINTER.withName("yScale"),
        Cubiomes.C_FLOAT.withName("minYScale"),
        Cubiomes.C_FLOAT.withName("maxYScale"),
        Cubiomes.C_POINTER.withName("horizontalRadiusMultiplier"),
        Cubiomes.C_FLOAT.withName("minHorRadius"),
        Cubiomes.C_FLOAT.withName("maxHorRadius"),
        Cubiomes.C_POINTER.withName("verticalRadiusMultiplier"),
        Cubiomes.C_FLOAT.withName("minVerRadius"),
        Cubiomes.C_FLOAT.withName("maxVerRadius"),
        Cubiomes.C_POINTER.withName("floorLevel"),
        Cubiomes.C_FLOAT.withName("minFloorLevel"),
        Cubiomes.C_FLOAT.withName("maxFloorLevel")
    ).withName("CaveCarverConfig");

    /**
     * The layout of this struct
     */
    public static final GroupLayout layout() {
        return $LAYOUT;
    }

    private static final OfInt dim$LAYOUT = (OfInt)$LAYOUT.select(groupElement("dim"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * int dim
     * }
     */
    public static final OfInt dim$layout() {
        return dim$LAYOUT;
    }

    private static final long dim$OFFSET = $LAYOUT.byteOffset(groupElement("dim"));

    /**
     * Offset for field:
     * {@snippet lang=c :
     * int dim
     * }
     */
    public static final long dim$offset() {
        return dim$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * int dim
     * }
     */
    public static int dim(MemorySegment struct) {
        return struct.get(dim$LAYOUT, dim$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * int dim
     * }
     */
    public static void dim(MemorySegment struct, int fieldValue) {
        struct.set(dim$LAYOUT, dim$OFFSET, fieldValue);
    }

    private static final OfFloat probability$LAYOUT = (OfFloat)$LAYOUT.select(groupElement("probability"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * float probability
     * }
     */
    public static final OfFloat probability$layout() {
        return probability$LAYOUT;
    }

    private static final long probability$OFFSET = $LAYOUT.byteOffset(groupElement("probability"));

    /**
     * Offset for field:
     * {@snippet lang=c :
     * float probability
     * }
     */
    public static final long probability$offset() {
        return probability$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * float probability
     * }
     */
    public static float probability(MemorySegment struct) {
        return struct.get(probability$LAYOUT, probability$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * float probability
     * }
     */
    public static void probability(MemorySegment struct, float fieldValue) {
        struct.set(probability$LAYOUT, probability$OFFSET, fieldValue);
    }

    private static final OfInt carverIndex$LAYOUT = (OfInt)$LAYOUT.select(groupElement("carverIndex"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * int carverIndex
     * }
     */
    public static final OfInt carverIndex$layout() {
        return carverIndex$LAYOUT;
    }

    private static final long carverIndex$OFFSET = $LAYOUT.byteOffset(groupElement("carverIndex"));

    /**
     * Offset for field:
     * {@snippet lang=c :
     * int carverIndex
     * }
     */
    public static final long carverIndex$offset() {
        return carverIndex$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * int carverIndex
     * }
     */
    public static int carverIndex(MemorySegment struct) {
        return struct.get(carverIndex$LAYOUT, carverIndex$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * int carverIndex
     * }
     */
    public static void carverIndex(MemorySegment struct, int fieldValue) {
        struct.set(carverIndex$LAYOUT, carverIndex$OFFSET, fieldValue);
    }

    private static final OfInt range$LAYOUT = (OfInt)$LAYOUT.select(groupElement("range"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * int range
     * }
     */
    public static final OfInt range$layout() {
        return range$LAYOUT;
    }

    private static final long range$OFFSET = $LAYOUT.byteOffset(groupElement("range"));

    /**
     * Offset for field:
     * {@snippet lang=c :
     * int range
     * }
     */
    public static final long range$offset() {
        return range$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * int range
     * }
     */
    public static int range(MemorySegment struct) {
        return struct.get(range$LAYOUT, range$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * int range
     * }
     */
    public static void range(MemorySegment struct, int fieldValue) {
        struct.set(range$LAYOUT, range$OFFSET, fieldValue);
    }

    private static final OfInt caveBound$LAYOUT = (OfInt)$LAYOUT.select(groupElement("caveBound"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * int caveBound
     * }
     */
    public static final OfInt caveBound$layout() {
        return caveBound$LAYOUT;
    }

    private static final long caveBound$OFFSET = $LAYOUT.byteOffset(groupElement("caveBound"));

    /**
     * Offset for field:
     * {@snippet lang=c :
     * int caveBound
     * }
     */
    public static final long caveBound$offset() {
        return caveBound$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * int caveBound
     * }
     */
    public static int caveBound(MemorySegment struct) {
        return struct.get(caveBound$LAYOUT, caveBound$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * int caveBound
     * }
     */
    public static void caveBound(MemorySegment struct, int fieldValue) {
        struct.set(caveBound$LAYOUT, caveBound$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * float (*thickness)(uint64_t *)
     * }
     */
    public static class thickness {

        thickness() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            float apply(MemorySegment _x0);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            Cubiomes.C_FLOAT,
            Cubiomes.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = Cubiomes.upcallHandle(thickness.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(thickness.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static float invoke(MemorySegment funcPtr,MemorySegment _x0) {
            try {
                return (float) DOWN$MH.invokeExact(funcPtr, _x0);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout thickness$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("thickness"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * float (*thickness)(uint64_t *)
     * }
     */
    public static final AddressLayout thickness$layout() {
        return thickness$LAYOUT;
    }

    private static final long thickness$OFFSET = $LAYOUT.byteOffset(groupElement("thickness"));

    /**
     * Offset for field:
     * {@snippet lang=c :
     * float (*thickness)(uint64_t *)
     * }
     */
    public static final long thickness$offset() {
        return thickness$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * float (*thickness)(uint64_t *)
     * }
     */
    public static MemorySegment thickness(MemorySegment struct) {
        return struct.get(thickness$LAYOUT, thickness$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * float (*thickness)(uint64_t *)
     * }
     */
    public static void thickness(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(thickness$LAYOUT, thickness$OFFSET, fieldValue);
    }

    private static final OfDouble tunnelYScale$LAYOUT = (OfDouble)$LAYOUT.select(groupElement("tunnelYScale"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * double tunnelYScale
     * }
     */
    public static final OfDouble tunnelYScale$layout() {
        return tunnelYScale$LAYOUT;
    }

    private static final long tunnelYScale$OFFSET = $LAYOUT.byteOffset(groupElement("tunnelYScale"));

    /**
     * Offset for field:
     * {@snippet lang=c :
     * double tunnelYScale
     * }
     */
    public static final long tunnelYScale$offset() {
        return tunnelYScale$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * double tunnelYScale
     * }
     */
    public static double tunnelYScale(MemorySegment struct) {
        return struct.get(tunnelYScale$LAYOUT, tunnelYScale$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * double tunnelYScale
     * }
     */
    public static void tunnelYScale(MemorySegment struct, double fieldValue) {
        struct.set(tunnelYScale$LAYOUT, tunnelYScale$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * int (*y)(uint64_t *, int, int, int)
     * }
     */
    public static class y {

        y() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            int apply(MemorySegment _x0, int _x1, int _x2, int _x3);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            Cubiomes.C_INT,
            Cubiomes.C_POINTER,
            Cubiomes.C_INT,
            Cubiomes.C_INT,
            Cubiomes.C_INT
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = Cubiomes.upcallHandle(y.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(y.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static int invoke(MemorySegment funcPtr,MemorySegment _x0, int _x1, int _x2, int _x3) {
            try {
                return (int) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2, _x3);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout y$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("y"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * int (*y)(uint64_t *, int, int, int)
     * }
     */
    public static final AddressLayout y$layout() {
        return y$LAYOUT;
    }

    private static final long y$OFFSET = $LAYOUT.byteOffset(groupElement("y"));

    /**
     * Offset for field:
     * {@snippet lang=c :
     * int (*y)(uint64_t *, int, int, int)
     * }
     */
    public static final long y$offset() {
        return y$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * int (*y)(uint64_t *, int, int, int)
     * }
     */
    public static MemorySegment y(MemorySegment struct) {
        return struct.get(y$LAYOUT, y$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * int (*y)(uint64_t *, int, int, int)
     * }
     */
    public static void y(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(y$LAYOUT, y$OFFSET, fieldValue);
    }

    private static final OfInt minY$LAYOUT = (OfInt)$LAYOUT.select(groupElement("minY"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * int minY
     * }
     */
    public static final OfInt minY$layout() {
        return minY$LAYOUT;
    }

    private static final long minY$OFFSET = $LAYOUT.byteOffset(groupElement("minY"));

    /**
     * Offset for field:
     * {@snippet lang=c :
     * int minY
     * }
     */
    public static final long minY$offset() {
        return minY$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * int minY
     * }
     */
    public static int minY(MemorySegment struct) {
        return struct.get(minY$LAYOUT, minY$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * int minY
     * }
     */
    public static void minY(MemorySegment struct, int fieldValue) {
        struct.set(minY$LAYOUT, minY$OFFSET, fieldValue);
    }

    private static final OfInt maxY$LAYOUT = (OfInt)$LAYOUT.select(groupElement("maxY"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * int maxY
     * }
     */
    public static final OfInt maxY$layout() {
        return maxY$LAYOUT;
    }

    private static final long maxY$OFFSET = $LAYOUT.byteOffset(groupElement("maxY"));

    /**
     * Offset for field:
     * {@snippet lang=c :
     * int maxY
     * }
     */
    public static final long maxY$offset() {
        return maxY$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * int maxY
     * }
     */
    public static int maxY(MemorySegment struct) {
        return struct.get(maxY$LAYOUT, maxY$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * int maxY
     * }
     */
    public static void maxY(MemorySegment struct, int fieldValue) {
        struct.set(maxY$LAYOUT, maxY$OFFSET, fieldValue);
    }

    private static final OfInt innerY$LAYOUT = (OfInt)$LAYOUT.select(groupElement("innerY"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * int innerY
     * }
     */
    public static final OfInt innerY$layout() {
        return innerY$LAYOUT;
    }

    private static final long innerY$OFFSET = $LAYOUT.byteOffset(groupElement("innerY"));

    /**
     * Offset for field:
     * {@snippet lang=c :
     * int innerY
     * }
     */
    public static final long innerY$offset() {
        return innerY$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * int innerY
     * }
     */
    public static int innerY(MemorySegment struct) {
        return struct.get(innerY$LAYOUT, innerY$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * int innerY
     * }
     */
    public static void innerY(MemorySegment struct, int fieldValue) {
        struct.set(innerY$LAYOUT, innerY$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * float (*yScale)(uint64_t *, float, float)
     * }
     */
    public static class yScale {

        yScale() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            float apply(MemorySegment _x0, float _x1, float _x2);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            Cubiomes.C_FLOAT,
            Cubiomes.C_POINTER,
            Cubiomes.C_FLOAT,
            Cubiomes.C_FLOAT
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = Cubiomes.upcallHandle(yScale.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(yScale.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static float invoke(MemorySegment funcPtr,MemorySegment _x0, float _x1, float _x2) {
            try {
                return (float) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout yScale$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("yScale"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * float (*yScale)(uint64_t *, float, float)
     * }
     */
    public static final AddressLayout yScale$layout() {
        return yScale$LAYOUT;
    }

    private static final long yScale$OFFSET = $LAYOUT.byteOffset(groupElement("yScale"));

    /**
     * Offset for field:
     * {@snippet lang=c :
     * float (*yScale)(uint64_t *, float, float)
     * }
     */
    public static final long yScale$offset() {
        return yScale$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * float (*yScale)(uint64_t *, float, float)
     * }
     */
    public static MemorySegment yScale(MemorySegment struct) {
        return struct.get(yScale$LAYOUT, yScale$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * float (*yScale)(uint64_t *, float, float)
     * }
     */
    public static void yScale(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(yScale$LAYOUT, yScale$OFFSET, fieldValue);
    }

    private static final OfFloat minYScale$LAYOUT = (OfFloat)$LAYOUT.select(groupElement("minYScale"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * float minYScale
     * }
     */
    public static final OfFloat minYScale$layout() {
        return minYScale$LAYOUT;
    }

    private static final long minYScale$OFFSET = $LAYOUT.byteOffset(groupElement("minYScale"));

    /**
     * Offset for field:
     * {@snippet lang=c :
     * float minYScale
     * }
     */
    public static final long minYScale$offset() {
        return minYScale$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * float minYScale
     * }
     */
    public static float minYScale(MemorySegment struct) {
        return struct.get(minYScale$LAYOUT, minYScale$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * float minYScale
     * }
     */
    public static void minYScale(MemorySegment struct, float fieldValue) {
        struct.set(minYScale$LAYOUT, minYScale$OFFSET, fieldValue);
    }

    private static final OfFloat maxYScale$LAYOUT = (OfFloat)$LAYOUT.select(groupElement("maxYScale"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * float maxYScale
     * }
     */
    public static final OfFloat maxYScale$layout() {
        return maxYScale$LAYOUT;
    }

    private static final long maxYScale$OFFSET = $LAYOUT.byteOffset(groupElement("maxYScale"));

    /**
     * Offset for field:
     * {@snippet lang=c :
     * float maxYScale
     * }
     */
    public static final long maxYScale$offset() {
        return maxYScale$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * float maxYScale
     * }
     */
    public static float maxYScale(MemorySegment struct) {
        return struct.get(maxYScale$LAYOUT, maxYScale$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * float maxYScale
     * }
     */
    public static void maxYScale(MemorySegment struct, float fieldValue) {
        struct.set(maxYScale$LAYOUT, maxYScale$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * float (*horizontalRadiusMultiplier)(uint64_t *, float, float)
     * }
     */
    public static class horizontalRadiusMultiplier {

        horizontalRadiusMultiplier() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            float apply(MemorySegment _x0, float _x1, float _x2);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            Cubiomes.C_FLOAT,
            Cubiomes.C_POINTER,
            Cubiomes.C_FLOAT,
            Cubiomes.C_FLOAT
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = Cubiomes.upcallHandle(horizontalRadiusMultiplier.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(horizontalRadiusMultiplier.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static float invoke(MemorySegment funcPtr,MemorySegment _x0, float _x1, float _x2) {
            try {
                return (float) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout horizontalRadiusMultiplier$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("horizontalRadiusMultiplier"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * float (*horizontalRadiusMultiplier)(uint64_t *, float, float)
     * }
     */
    public static final AddressLayout horizontalRadiusMultiplier$layout() {
        return horizontalRadiusMultiplier$LAYOUT;
    }

    private static final long horizontalRadiusMultiplier$OFFSET = $LAYOUT.byteOffset(groupElement("horizontalRadiusMultiplier"));

    /**
     * Offset for field:
     * {@snippet lang=c :
     * float (*horizontalRadiusMultiplier)(uint64_t *, float, float)
     * }
     */
    public static final long horizontalRadiusMultiplier$offset() {
        return horizontalRadiusMultiplier$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * float (*horizontalRadiusMultiplier)(uint64_t *, float, float)
     * }
     */
    public static MemorySegment horizontalRadiusMultiplier(MemorySegment struct) {
        return struct.get(horizontalRadiusMultiplier$LAYOUT, horizontalRadiusMultiplier$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * float (*horizontalRadiusMultiplier)(uint64_t *, float, float)
     * }
     */
    public static void horizontalRadiusMultiplier(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(horizontalRadiusMultiplier$LAYOUT, horizontalRadiusMultiplier$OFFSET, fieldValue);
    }

    private static final OfFloat minHorRadius$LAYOUT = (OfFloat)$LAYOUT.select(groupElement("minHorRadius"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * float minHorRadius
     * }
     */
    public static final OfFloat minHorRadius$layout() {
        return minHorRadius$LAYOUT;
    }

    private static final long minHorRadius$OFFSET = $LAYOUT.byteOffset(groupElement("minHorRadius"));

    /**
     * Offset for field:
     * {@snippet lang=c :
     * float minHorRadius
     * }
     */
    public static final long minHorRadius$offset() {
        return minHorRadius$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * float minHorRadius
     * }
     */
    public static float minHorRadius(MemorySegment struct) {
        return struct.get(minHorRadius$LAYOUT, minHorRadius$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * float minHorRadius
     * }
     */
    public static void minHorRadius(MemorySegment struct, float fieldValue) {
        struct.set(minHorRadius$LAYOUT, minHorRadius$OFFSET, fieldValue);
    }

    private static final OfFloat maxHorRadius$LAYOUT = (OfFloat)$LAYOUT.select(groupElement("maxHorRadius"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * float maxHorRadius
     * }
     */
    public static final OfFloat maxHorRadius$layout() {
        return maxHorRadius$LAYOUT;
    }

    private static final long maxHorRadius$OFFSET = $LAYOUT.byteOffset(groupElement("maxHorRadius"));

    /**
     * Offset for field:
     * {@snippet lang=c :
     * float maxHorRadius
     * }
     */
    public static final long maxHorRadius$offset() {
        return maxHorRadius$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * float maxHorRadius
     * }
     */
    public static float maxHorRadius(MemorySegment struct) {
        return struct.get(maxHorRadius$LAYOUT, maxHorRadius$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * float maxHorRadius
     * }
     */
    public static void maxHorRadius(MemorySegment struct, float fieldValue) {
        struct.set(maxHorRadius$LAYOUT, maxHorRadius$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * float (*verticalRadiusMultiplier)(uint64_t *, float, float)
     * }
     */
    public static class verticalRadiusMultiplier {

        verticalRadiusMultiplier() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            float apply(MemorySegment _x0, float _x1, float _x2);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            Cubiomes.C_FLOAT,
            Cubiomes.C_POINTER,
            Cubiomes.C_FLOAT,
            Cubiomes.C_FLOAT
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = Cubiomes.upcallHandle(verticalRadiusMultiplier.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(verticalRadiusMultiplier.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static float invoke(MemorySegment funcPtr,MemorySegment _x0, float _x1, float _x2) {
            try {
                return (float) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout verticalRadiusMultiplier$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("verticalRadiusMultiplier"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * float (*verticalRadiusMultiplier)(uint64_t *, float, float)
     * }
     */
    public static final AddressLayout verticalRadiusMultiplier$layout() {
        return verticalRadiusMultiplier$LAYOUT;
    }

    private static final long verticalRadiusMultiplier$OFFSET = $LAYOUT.byteOffset(groupElement("verticalRadiusMultiplier"));

    /**
     * Offset for field:
     * {@snippet lang=c :
     * float (*verticalRadiusMultiplier)(uint64_t *, float, float)
     * }
     */
    public static final long verticalRadiusMultiplier$offset() {
        return verticalRadiusMultiplier$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * float (*verticalRadiusMultiplier)(uint64_t *, float, float)
     * }
     */
    public static MemorySegment verticalRadiusMultiplier(MemorySegment struct) {
        return struct.get(verticalRadiusMultiplier$LAYOUT, verticalRadiusMultiplier$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * float (*verticalRadiusMultiplier)(uint64_t *, float, float)
     * }
     */
    public static void verticalRadiusMultiplier(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(verticalRadiusMultiplier$LAYOUT, verticalRadiusMultiplier$OFFSET, fieldValue);
    }

    private static final OfFloat minVerRadius$LAYOUT = (OfFloat)$LAYOUT.select(groupElement("minVerRadius"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * float minVerRadius
     * }
     */
    public static final OfFloat minVerRadius$layout() {
        return minVerRadius$LAYOUT;
    }

    private static final long minVerRadius$OFFSET = $LAYOUT.byteOffset(groupElement("minVerRadius"));

    /**
     * Offset for field:
     * {@snippet lang=c :
     * float minVerRadius
     * }
     */
    public static final long minVerRadius$offset() {
        return minVerRadius$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * float minVerRadius
     * }
     */
    public static float minVerRadius(MemorySegment struct) {
        return struct.get(minVerRadius$LAYOUT, minVerRadius$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * float minVerRadius
     * }
     */
    public static void minVerRadius(MemorySegment struct, float fieldValue) {
        struct.set(minVerRadius$LAYOUT, minVerRadius$OFFSET, fieldValue);
    }

    private static final OfFloat maxVerRadius$LAYOUT = (OfFloat)$LAYOUT.select(groupElement("maxVerRadius"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * float maxVerRadius
     * }
     */
    public static final OfFloat maxVerRadius$layout() {
        return maxVerRadius$LAYOUT;
    }

    private static final long maxVerRadius$OFFSET = $LAYOUT.byteOffset(groupElement("maxVerRadius"));

    /**
     * Offset for field:
     * {@snippet lang=c :
     * float maxVerRadius
     * }
     */
    public static final long maxVerRadius$offset() {
        return maxVerRadius$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * float maxVerRadius
     * }
     */
    public static float maxVerRadius(MemorySegment struct) {
        return struct.get(maxVerRadius$LAYOUT, maxVerRadius$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * float maxVerRadius
     * }
     */
    public static void maxVerRadius(MemorySegment struct, float fieldValue) {
        struct.set(maxVerRadius$LAYOUT, maxVerRadius$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * float (*floorLevel)(uint64_t *, float, float)
     * }
     */
    public static class floorLevel {

        floorLevel() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            float apply(MemorySegment _x0, float _x1, float _x2);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            Cubiomes.C_FLOAT,
            Cubiomes.C_POINTER,
            Cubiomes.C_FLOAT,
            Cubiomes.C_FLOAT
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = Cubiomes.upcallHandle(floorLevel.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(floorLevel.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static float invoke(MemorySegment funcPtr,MemorySegment _x0, float _x1, float _x2) {
            try {
                return (float) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout floorLevel$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("floorLevel"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * float (*floorLevel)(uint64_t *, float, float)
     * }
     */
    public static final AddressLayout floorLevel$layout() {
        return floorLevel$LAYOUT;
    }

    private static final long floorLevel$OFFSET = $LAYOUT.byteOffset(groupElement("floorLevel"));

    /**
     * Offset for field:
     * {@snippet lang=c :
     * float (*floorLevel)(uint64_t *, float, float)
     * }
     */
    public static final long floorLevel$offset() {
        return floorLevel$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * float (*floorLevel)(uint64_t *, float, float)
     * }
     */
    public static MemorySegment floorLevel(MemorySegment struct) {
        return struct.get(floorLevel$LAYOUT, floorLevel$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * float (*floorLevel)(uint64_t *, float, float)
     * }
     */
    public static void floorLevel(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(floorLevel$LAYOUT, floorLevel$OFFSET, fieldValue);
    }

    private static final OfFloat minFloorLevel$LAYOUT = (OfFloat)$LAYOUT.select(groupElement("minFloorLevel"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * float minFloorLevel
     * }
     */
    public static final OfFloat minFloorLevel$layout() {
        return minFloorLevel$LAYOUT;
    }

    private static final long minFloorLevel$OFFSET = $LAYOUT.byteOffset(groupElement("minFloorLevel"));

    /**
     * Offset for field:
     * {@snippet lang=c :
     * float minFloorLevel
     * }
     */
    public static final long minFloorLevel$offset() {
        return minFloorLevel$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * float minFloorLevel
     * }
     */
    public static float minFloorLevel(MemorySegment struct) {
        return struct.get(minFloorLevel$LAYOUT, minFloorLevel$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * float minFloorLevel
     * }
     */
    public static void minFloorLevel(MemorySegment struct, float fieldValue) {
        struct.set(minFloorLevel$LAYOUT, minFloorLevel$OFFSET, fieldValue);
    }

    private static final OfFloat maxFloorLevel$LAYOUT = (OfFloat)$LAYOUT.select(groupElement("maxFloorLevel"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * float maxFloorLevel
     * }
     */
    public static final OfFloat maxFloorLevel$layout() {
        return maxFloorLevel$LAYOUT;
    }

    private static final long maxFloorLevel$OFFSET = $LAYOUT.byteOffset(groupElement("maxFloorLevel"));

    /**
     * Offset for field:
     * {@snippet lang=c :
     * float maxFloorLevel
     * }
     */
    public static final long maxFloorLevel$offset() {
        return maxFloorLevel$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * float maxFloorLevel
     * }
     */
    public static float maxFloorLevel(MemorySegment struct) {
        return struct.get(maxFloorLevel$LAYOUT, maxFloorLevel$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * float maxFloorLevel
     * }
     */
    public static void maxFloorLevel(MemorySegment struct, float fieldValue) {
        struct.set(maxFloorLevel$LAYOUT, maxFloorLevel$OFFSET, fieldValue);
    }

    /**
     * Obtains a slice of {@code arrayParam} which selects the array element at {@code index}.
     * The returned segment has address {@code arrayParam.address() + index * layout().byteSize()}
     */
    public static MemorySegment asSlice(MemorySegment array, long index) {
        return array.asSlice(layout().byteSize() * index);
    }

    /**
     * The size (in bytes) of this struct
     */
    public static long sizeof() { return layout().byteSize(); }

    /**
     * Allocate a segment of size {@code layout().byteSize()} using {@code allocator}
     */
    public static MemorySegment allocate(SegmentAllocator allocator) {
        return allocator.allocate(layout());
    }

    /**
     * Allocate an array of size {@code elementCount} using {@code allocator}.
     * The returned segment has size {@code elementCount * layout().byteSize()}.
     */
    public static MemorySegment allocateArray(long elementCount, SegmentAllocator allocator) {
        return allocator.allocate(MemoryLayout.sequenceLayout(elementCount, layout()));
    }

    /**
     * Reinterprets {@code addr} using target {@code arena} and {@code cleanupAction} (if any).
     * The returned segment has size {@code layout().byteSize()}
     */
    public static MemorySegment reinterpret(MemorySegment addr, Arena arena, Consumer<MemorySegment> cleanup) {
        return reinterpret(addr, 1, arena, cleanup);
    }

    /**
     * Reinterprets {@code addr} using target {@code arena} and {@code cleanupAction} (if any).
     * The returned segment has size {@code elementCount * layout().byteSize()}
     */
    public static MemorySegment reinterpret(MemorySegment addr, long elementCount, Arena arena, Consumer<MemorySegment> cleanup) {
        return addr.reinterpret(layout().byteSize() * elementCount, arena, cleanup);
    }
}

